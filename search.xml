<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2023/01/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><p>从今天起，正式开始写博客啦。这次用hexo搭建博客还有许多要完善的地方。一些小的细节方面后续也会持续改进。最近其实还是比较忙的，这次也算是一个总结和记录吧（虽说也没有做啥总结）。总之，依然要做好安排，不断学习，不断进步。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Start</title>
    <url>/2023/01/08/Start/</url>
    <content><![CDATA[<h2 id="1月8日记录"><a href="#1月8日记录" class="headerlink" title="1月8日记录"></a>1月8日记录</h2><p>今天用hexo框架搭建了属于自己的博客，还是很开心的，虽然遇到了许多困难，但是我还是一步一步的实现了自己的博客。感觉很开心。也希望自己以后不断学习，不断提高自己的技术，在IT的旅途上追逐梦想，扬帆起航。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录1</title>
    <url>/2023/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="串和广义表"><a href="#串和广义表" class="headerlink" title="串和广义表"></a>串和广义表</h1><h3 id="串的定义和运算"><a href="#串的定义和运算" class="headerlink" title="串的定义和运算"></a>串的定义和运算</h3><p>1.串是由零个或任意多个字符组成的有限序列<br>2.子串是串中任意连续的字符组成的子序列<br>注：空串是任意串的子串，任意串是自身的子串<br>3.模式匹配是一种求子串在主串中第一次出现的第一个字符的位置<br>4.串的操作有很多种，比如赋值，复制，求串的长度，串的连接，插入删除等等<br>5.串的存储结构有顺序存储和链式存储<br>6.在实际应用中，可以采用堆分配存储（动态存储）<br>堆分配存储的方法：<br>（1）开辟一块地址连续的存储空间，该存储空间称为“堆”<br>（2）建立一个索引表，用来存储串的名字，长度和该串在堆中的起始位置<br>（3）程序执行过程中，每产生一个串，系统就从堆中分配一块大小和串长度相等的连续空间，用来存储该串的值，并且在索引表中增加一个索引项，用于记录串的信息。</p>
<h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p>1.广义表是n个数据元素的有序序列，它是线性表的推广，也称为“列表”<br>2.广义表是一种多层次的数据结构，其中的元素可以是单元素，也可以是子表<br>3.广义表可以是递归的表，即它可以是自身的子表<br>4.广义表可以被其他表所共享<br>5.广义表常采用链式存储结构，有头尾表示法和孩子兄弟表示法两种存储方式</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习记录1</title>
    <url>/2023/01/19/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h3 id="一、选择排序"><a href="#一、选择排序" class="headerlink" title="一、选择排序"></a>一、选择排序</h3><p>1.每一趟从待排序的数据元素中选择最小（或最大）的一个元素，顺序放在待排序的数组最前面，直到数据元素全部排完为止。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1001</span>;</span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,k,i,j;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">		k = i;</span><br><span class="line">		<span class="keyword">for</span>(j = i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;a[k]) k = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k!=i)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = a[i];</span><br><span class="line">			a[i] = a[k];</span><br><span class="line">			a[k] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h3><p>1.n个数据元素，从第一个开始，依次比较相邻的两个是否顺序，如果不满足就交换。直到n-1和n相比，经过n-1轮后，得到有序的队列</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">10001</span>; </span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> flag;</span><br><span class="line">	<span class="type">int</span> n,j;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)  <span class="comment">//n-1轮冒泡排序</span></span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)  <span class="comment">//进行i次的比较</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">swap</span>(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;  <span class="comment">//没有进行交换，直接退出循环</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h3><p>1.当读入一个数据元素时，在已经排序好的序列中，寻找它正确的位置放入。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,i,j,k,temp;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;a[i]) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j!=i<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">			temp = a[i];</span><br><span class="line">			<span class="keyword">for</span>(k=i<span class="number">-1</span>;k&gt;j;k--)</span><br><span class="line">				a[k+<span class="number">1</span>] = a[k];</span><br><span class="line">			a[k+<span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="四、桶排序"><a href="#四、桶排序" class="headerlink" title="四、桶排序"></a>四、桶排序</h3><p>1.若待排序的值在一个明显有限的范围内，可设计有限个有序桶，待排序的值装入相对应的桶，顺序输出各桶的值就可以得到有序的序列。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b[<span class="number">101</span>],n,i,k;</span><br><span class="line">	<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		b[k]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(b[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">			cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			b[i]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="五、快速排序"><a href="#五、快速排序" class="headerlink" title="五、快速排序"></a>五、快速排序</h3><p>1.快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将待排序的序列分为两部分，其中一部分中的每一个数都比另一部分小，则可以对这两部分继续进行排序，最终使得整个序列有序。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> x = q[l],i = l<span class="number">-1</span>,j =r+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">		<span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">		<span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h3><p>1.归并排序算法采用的是分治算法,即把两个(或两个以上)有序表合并成一个新的有序表,把待排序的序列分成若干个子序列,每个子序列都是有序的,然后把有序子序列合并成整体有序序列 。若将两个有序表合并成一个有序表，称为二路归并。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">100001</span>;</span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = low,j = mid + <span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span> [high-low+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">		<span class="keyword">if</span>(arr[i]&lt;=arr[j])</span><br><span class="line">		&#123;</span><br><span class="line">			temp[k++] = arr[i++]; <span class="comment">//较小的哪一个先存入temp数组中</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			temp[k++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">		temp[k++] = arr[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">		temp[k++] = arr[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=low,k=<span class="number">0</span>;i&lt;=high;i++,k++)</span><br><span class="line">		arr[i] = temp[k];</span><br><span class="line">	<span class="keyword">delete</span> []temp; <span class="comment">//释放数组空间，必须用delete[]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &gt;= high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">MergeSort</span>(arr,low,mid);</span><br><span class="line">		<span class="built_in">MergeSort</span>(arr,mid+<span class="number">1</span>,high);</span><br><span class="line">		<span class="built_in">Merge</span>(arr,low,mid,high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">MergeSort</span>(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录3</title>
    <url>/2023/01/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h1><h3 id="图的定义："><a href="#图的定义：" class="headerlink" title="图的定义："></a>图的定义：</h3><p>1.图是一个由非空的顶点集合和一个描述顶点之间的关系即边（Edges）的有限集合组成的一种数据结构。</p>
<p>可以定义为一个二元组：</p>
<p>G&#x3D;（V,E）</p>
<p>V是顶点集合，E是边的集合</p>
<p>2.按照图中的边是否有方向，图分为有向图和无向图两类</p>
<h3 id="图的相关术语："><a href="#图的相关术语：" class="headerlink" title="图的相关术语："></a>图的相关术语：</h3><p>（1）无向图：在一个图中，每条边都没有方向</p>
<p>（2）有向图：在一个图中，每条边都有方向</p>
<p>（3）无向完全图：在一个无向图中，任意两个顶点都有一条直接边相连。在一个含有n个顶点的无向完全图中，有（n-1）n&#x2F;2 条边</p>
<p>（4）有向完全图：在一个有向图中，任意两顶点之间都有方向互为相反的两条弧相连接</p>
<p>（5）顶点的度：一个顶点所拥有的边数</p>
<p>（6）顶点的入度：在有向图中，一个顶点拥有的弧头的数目</p>
<p>（7）顶点的出度：在有向图中，一个顶点拥有的弧尾的数目</p>
<p>一个顶点的度 &#x3D;  顶点的入度 + 顶点的出度</p>
<p>（8）权：图的边或弧有时具有与它相关的数据信息，这个数据信息称为权（权重）</p>
<p>（9）网：带权的图称为网，同样可以分为有向网和无向网</p>
<p>（10）回路或环：在一个路径中，若其第一个顶点和最后一个顶点是相同的，则称该路径为一个回路或环</p>
<p>（11）简单路径：表示路径的顶点序列中的顶点各不相同</p>
<p>（12）简单回路：除了第一个和最后一个顶点之外，其余各顶点均不重复出现</p>
<p>（13）稀疏图：有很少条边的图称为稀疏图</p>
<p>（14）连通图：无向图中，任意两个顶点都是连通的图称为连通图。无向图的极大连通子图称为连通分量</p>
<p>（15）强连通图：对于有向图来说，图中任意一对顶点Vi和Vj均有从一个顶点Vi到另一个顶点Vj有路径，也有从Vj到Vi的路径，则称该有向图是强连通图。有向图的极大强连通子图称为强连通分量</p>
<p>（16）生成树：连通图G的一个子图如果是一棵包含G的所有顶点的树，则该子图称为G的生成树</p>
<h3 id="图的存储结构："><a href="#图的存储结构：" class="headerlink" title="图的存储结构："></a>图的存储结构：</h3><p>（1）邻接矩阵</p>
<p>（2）邻接表</p>
<h3 id="图的遍历："><a href="#图的遍历：" class="headerlink" title="图的遍历："></a>图的遍历：</h3><p>1.深度优先搜索（DFS）</p>
<p>2.广度优先搜索（BFS）</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习记录2</title>
    <url>/2023/01/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="搜索与回溯"><a href="#搜索与回溯" class="headerlink" title="搜索与回溯"></a>搜索与回溯</h1><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>1.深度优先搜索类似于树的先序遍历，是树的先序遍历的推广</p>
<p>2.深度优先搜索方法：</p>
<p>（1）首先从图中某个顶点v出发，首先访问此顶点，将其标记为已经访问</p>
<p>（2）任选一个v的未被访问的邻接点w出发，继续进行深度优先搜索</p>
<p>（3）直到图中所有和v路径想通的顶点被访问到</p>
<p>（4）若此时还有顶点未访问，则选另一个顶点作为起始点，重复上述步骤，直到所有的顶点都被访问为止。</p>
<h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><ol>
<li>广度优先搜索类似于树的按层次遍历</li>
<li>广度优先搜索的思想：</li>
</ol>
<p>（1）从图中的某一个顶点V0开始，访问V0，</p>
<p>（2）访问与V0相邻接的顶点V1，V2，……Vt</p>
<p>（3）依次访问与V1，V2，……..Vt相邻接的点</p>
<p>（4）循环进行，直到所有的顶点都被访问</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>1.回溯法是从初始状出发，按照深度优先搜索的方式，根据产生子结点的条件约束，搜索问题的解。当发现当前节点满足不了求解条件时，就回溯，尝试其他的路径。</p>
<p>注：在搜索中，常采用剪枝的策略进行优化</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习记录3</title>
    <url>/2023/01/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="贪心和分治"><a href="#贪心和分治" class="headerlink" title="贪心和分治"></a>贪心和分治</h1><h3 id="一、贪心算法"><a href="#一、贪心算法" class="headerlink" title="一、贪心算法"></a>一、贪心算法</h3><p>1.选择贪心策略，根据贪心策略，一步一步地得到局部最优解，最后把所有的局部最优解合成原来问题的一个最优解。</p>
<p>2.基本思路：</p>
<p>（1）建立数学模型来描述问题</p>
<p>（2）把求解的问题分成若干个子问题</p>
<p>（3）对每一个子问题求解，得到子问题的局部最优解</p>
<p>（4）把子问题的局部最优解合成原来问题的一个解</p>
<p>3.适用的问题：</p>
<p>局部最优的策略能导致产生全局最优解</p>
<h3 id="二、分治算法"><a href="#二、分治算法" class="headerlink" title="二、分治算法"></a>二、分治算法</h3><p>1.所谓分治，就是分而治之，将大规模的问题分解成几个小规模的问题。通过求解小规模的问题来求出大规模问题的解。</p>
<p>2.当我们将问题分解成两个较小问题求解时的分治称为二分法</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习记录4</title>
    <url>/2023/01/22/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>1.动态规划是解最优化问题的一种途径，一种方法。</p>
<p>2.多阶段决策问题：</p>
<p>一个问题可以看作是一个前后关联具有链状结构的多阶段过程。</p>
<p>3.多阶段决策过程是指一类特殊的活动过程，问题可以按时间顺序分解成若干相互联系的阶段，在每一个阶段都要作出决策，全部过程的决策是一个决策序列。</p>
<p>4.相关的概念：</p>
<p>（1）阶段和阶段变量</p>
<p>（2）状态和状态变量</p>
<p>（3）决策、决策变量和决策允许集合</p>
<p>（4）策略和最优策略</p>
<p>（5）状态转移方程</p>
<p>5.能够用动态规划解决的问题必须满足的条件：</p>
<p>最优化原理和无后效性原则</p>
<p>6.解题步骤：</p>
<p>（1）阶段</p>
<p>（2）状态</p>
<p>（3）决策</p>
<p>（4）策略</p>
<p>（5）状态转移方程</p>
<p>7.注意事项：</p>
<p>（1）确定好dp数组以及下标的含义</p>
<p>（2）确定递推公式</p>
<p>（3）dp数组的初始化</p>
<p>（4）确定遍历顺序</p>
<p>（5）推导dp数组</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习记录1</title>
    <url>/2023/01/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h1><p>1.计算机系统：包含硬件系统和软件系统</p>
<p>2.硬件：借助电、磁、光、机械等原理构成的各种物理部件的有机组合，是系统工作的实体</p>
<p>主要有CPU，主存储器，I&#x2F;O控制系统，外围设备</p>
<p>（1）中央处理器：包含运算单元和控制单元</p>
<p>（2）外围设备：输入、输出设备</p>
<p>（3）总线（BUS）是计算机各种功能部件之间传送信息的公共通信干线，它是CPU、内存、输入输出设备传递信息的公用通道。包括控制总线、地址总线、数据总线</p>
<p>计算机的各个部件通过总线相连接</p>
<p>总线的类型：</p>
<p>内部总线</p>
<p>系统总线</p>
<p>通信总线</p>
<p>（4）CPU：中央处理器是计算机的运算核心，主要包括运算逻辑单元，寄存器部件，控制部件</p>
<p>（5）存储器：</p>
<p>cache：高速缓存</p>
<p>SARM：静态随机存储器</p>
<p>DARM：动态随机存储器（主存）</p>
<p>3.软件：各种程序和文件，用于指挥计算机系统按指定的要求进行协同工作</p>
<p>包括系统软件、支撑软件和应用软件</p>
<p>关键的系统软件是：操作系统和语言处理系统</p>
<p>（1）系统软件：</p>
<p>操作系统、实用程序、语言处理程序、数据库管理程序</p>
<p>（2）支撑软件：</p>
<p>接口软件、工具软件、软件数据库、</p>
<p>（3）应用软件：</p>
<p>用户按其需要自行编写的专用程序</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录1</title>
    <url>/2023/01/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h3 id="一、评估方法"><a href="#一、评估方法" class="headerlink" title="一、评估方法"></a>一、评估方法</h3><p>（获得测试结果）</p>
<h4 id="测试集的获取："><a href="#测试集的获取：" class="headerlink" title="测试集的获取："></a>测试集的获取：</h4><p>1.测试集和训练集应该互斥</p>
<p>2.常见的获取测试集的方法：</p>
<p>（1）留出法：</p>
<p>保持数据的一致性，如分层采样；多次重复划分；测试集不能太大，也不能太小</p>
<p>（2）交叉验证法</p>
<p>k折交叉验证</p>
<p>（3）自助法：自助采样</p>
<h3 id="二、调参与验证集"><a href="#二、调参与验证集" class="headerlink" title="二、调参与验证集"></a>二、调参与验证集</h3><h4 id="调参与最终模型："><a href="#调参与最终模型：" class="headerlink" title="调参与最终模型："></a>调参与最终模型：</h4><p>1.算法的参数：一般由人工设定，亦称为“超参数”</p>
<p>2.模型的参数：一般由学习确定</p>
<p>3.调参过程相似：先产生若干模型，然后基于某种评估方法进行选择</p>
<p>4.验证集：训练集中专门用来调参数的过程</p>
<h3 id="三、性能度量"><a href="#三、性能度量" class="headerlink" title="三、性能度量"></a>三、性能度量</h3><p>（评估性能的优劣）</p>
<p>1.性能度量是衡量模型泛化能力的评估标准，反映了任务需求。使用不同的性能度量往往会导致不同的评估结果。</p>
<p>2.什么样的模型是“好”的，不仅取决于算法和数据，还取决于任务需求。</p>
<p>3.回归任务常采用均方误差</p>
<p>4.对于分类任务，可以得到混淆矩阵。根据混淆矩阵，得到查准率（P）和查全率（R），进而得到F1度量<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.6ex;" xmlns="http://www.w3.org/2000/svg" width="20.533ex" height="4.636ex" role="img" focusable="false" viewBox="0 -1342 9075.4 2049"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(594.5,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mrow" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mn" transform="translate(749,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><rect width="1449" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(1966.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(3022.6,0)"><g data-mml-node="mn" transform="translate(220,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mn" transform="translate(220,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="700" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(4184.8,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="mo" transform="translate(4685,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mfrac" transform="translate(5074,0)"><g data-mml-node="mn" transform="translate(345.5,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(220,-686)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><rect width="951" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(6487.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mfrac" transform="translate(7487.4,0)"><g data-mml-node="mn" transform="translate(349.5,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(220,-686)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><rect width="959" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8686.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
<h3 id="四、比较检验"><a href="#四、比较检验" class="headerlink" title="四、比较检验"></a>四、比较检验</h3><p>（判断实质差别）</p>
<p>1.在某种度量下取得评估结果后，不能直接比较以评判优劣</p>
<p>2.t检验</p>
<p>3.卡方检验</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录2</title>
    <url>/2023/01/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h1><h4 id="一、线性回归"><a href="#一、线性回归" class="headerlink" title="一、线性回归"></a>一、线性回归</h4><p>1.线性回归要把离散转换为连续</p>
<p>2.离散属性的处理：</p>
<p>若有序，则连续化；否则，转换为k维向量</p>
<p>3.使用最小二乘法求解目标函数的最小值</p>
<h4 id="二、多元线性回归"><a href="#二、多元线性回归" class="headerlink" title="二、多元线性回归"></a>二、多元线性回归</h4><p>1.引入正则化（归纳偏好）</p>
<h4 id="三、广义线性模型"><a href="#三、广义线性模型" class="headerlink" title="三、广义线性模型"></a>三、广义线性模型</h4><p>1.对数线性回归，用线性回归来逼近对数的目标</p>
<h4 id="四、对率回归（logistic-regression）"><a href="#四、对率回归（logistic-regression）" class="headerlink" title="四、对率回归（logistic regression）"></a>四、对率回归（logistic regression）</h4><p>1.二分类任务，使用对率函数</p>
<p>2.对率回归的优点：</p>
<p>（1）无需事先假设数据分布</p>
<p>（2）可得到“类别”的近似概率预测</p>
<p>（3）可直接应用现有的数值优化算法求取最优解</p>
<p>3.对率回归是分类学习算法</p>
<h4 id="五、类别不平衡"><a href="#五、类别不平衡" class="headerlink" title="五、类别不平衡"></a>五、类别不平衡</h4><p>1.不同类别的样本比例相差很大，“小类”往往更重要</p>
<p>2.常用的类别不平衡学习方法：</p>
<p>（1）过采样</p>
<p>（2）欠采样</p>
<p>（3）阈值移动</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录3</title>
    <url>/2023/01/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h1><p>之前只是听说过xgboost这个模型，但是没有具体的学习。这次的学习总结就来具体的认识xgboost，这里没有深入的研究其中的数学原理，仅仅是从初学者的角度来认识，一些地方存在错误是在所难免的，希望大家多多指正交流。</p>
<p>1.Xgboost是一个监督模型，其对应于特殊的决策树——分类回归树（CART树）</p>
<p>2.用CART树做预测：将各个树的预测分数相加</p>
<p>3.对于监督学习来说，建立模型后的参数调整是非常重要的，知识藏在这些参数之中</p>
<p>4.xgboost的目标函数包含了损失函数和正则项</p>
<p>5.xgboost模型由CART树组成，参数存在于每棵CART树中</p>
<p>6.xgboost用GBDT（梯度提升树）算法分步骤优化目标函数，先优化第一棵树，在优化第二棵，直到第k棵</p>
<p>7.由官方的文档我们可以得知，xgboost代表极端梯度提升</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录4</title>
    <url>/2023/01/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h1 id="Sklearn"><a href="#Sklearn" class="headerlink" title="Sklearn"></a>Sklearn</h1><h3 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h3><p>1.sklearn是一个开源的python机器学习算法库</p>
<h3 id="二、-线性分类"><a href="#二、-线性分类" class="headerlink" title="二、 线性分类"></a>二、 线性分类</h3><p>1.鸢尾花数据的分类：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X_iris,y_iris = iris.data,iris.target</span><br><span class="line">X,y = X_iris[:, :<span class="number">2</span>],y_iris</span><br><span class="line"><span class="comment"># print(X.shape)</span></span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="number">0.25</span>,random_state=<span class="number">33</span>)</span><br><span class="line"><span class="built_in">print</span>(X_train.shape,y_train.shape)</span><br><span class="line"></span><br><span class="line">scaler = preprocessing.StandardScaler().fit(X_train)</span><br><span class="line">X_train = scaler.transform(X_train)</span><br><span class="line">X_test  = scaler.transform(X_test)</span><br><span class="line"></span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;greenyellow&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(colors)):</span><br><span class="line">	xs = X_train[:,<span class="number">0</span>][y_train == i]</span><br><span class="line">	ys = X_train[:,<span class="number">1</span>][y_train == i]</span><br><span class="line">	plt.scatter(xs,ys,c=colors[i])</span><br><span class="line">plt.legend(iris.target_names)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sepal length&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Sepal width&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 山鸢尾setosa</span></span><br><span class="line"><span class="comment"># 杂色鸢尾vcersicolor</span></span><br><span class="line"><span class="comment"># 弗吉尼亚鸢尾 virginca0</span></span><br><span class="line"><span class="comment"># 上面的模型对山鸢尾的分类效果很好，但是不能将杂色鸢尾和弗吉尼亚鸢尾很好的分开</span></span><br></pre></td></tr></table></figure></div>

<p>2.在线性模型中使用梯度下降法：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X_iris,y_iris = iris.data,iris.target</span><br><span class="line">X,y = X_iris[:, :<span class="number">2</span>],y_iris</span><br><span class="line"><span class="comment"># print(X.shape)</span></span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="number">0.25</span>,random_state=<span class="number">33</span>)</span><br><span class="line"><span class="built_in">print</span>(X_train.shape,y_train.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clf = SGDClassifier()</span><br><span class="line">clf.fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(clf.coef_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sklearn中的三种流行的评估函数</span></span><br><span class="line"><span class="comment"># 精确率</span></span><br><span class="line"><span class="comment"># 召回率</span></span><br><span class="line"><span class="comment"># F1度量</span></span><br><span class="line">y_train_pred = clf.predict(X_train)</span><br><span class="line"><span class="built_in">print</span>(metrics.accuracy_score(y_train,y_train_pred))</span><br><span class="line">y_pred = clf.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(metrics.accuracy_score(y_test,y_pred))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(metrics.classification_report(y_test,y_pred,target_names=iris.target_names))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------&quot;</span>)</span><br><span class="line"><span class="comment"># 打印混淆矩阵</span></span><br><span class="line"><span class="built_in">print</span>(metrics.confusion_matrix(y_test,y_pred))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="二、支持向量机和图像识别"><a href="#二、支持向量机和图像识别" class="headerlink" title="二、支持向量机和图像识别"></a>二、支持向量机和图像识别</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_olivetti_faces</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score,KFold</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> sem</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">faces = fetch_olivetti_faces()</span><br><span class="line"><span class="built_in">print</span>(faces.DESCR)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(faces.keys())</span><br><span class="line"></span><br><span class="line">svc_1 = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(faces.data,faces.target,test_size=<span class="number">0.25</span>,random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evalute_cross_validation</span>(<span class="params">clf,X,y,K</span>)</span><br><span class="line">    cv = KFold(<span class="built_in">len</span>(y),K,shuffle=<span class="literal">True</span>,random_state=<span class="number">0</span>)</span><br><span class="line">    scores = cross_val_score(clf,X,y,cv=cv)</span><br><span class="line">    <span class="built_in">print</span>(scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Mean score:&#123;0:.3f&#125;(+/-&#123;1:.3f&#125;))&quot;</span>.<span class="built_in">format</span>(np.mean(scores),sem(scores))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">evalute_cross_validation(svc_1,X_train,y_train,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_and_evaluate</span>(<span class="params">clf,X_train,X_test,y_train,y_test</span>):</span><br><span class="line">    clf.fit(X_train,y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Accuracy on training set:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(clf.score(X_train,y_train))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Accuracy on testing set:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(clf.score(X_test,y_test))</span><br><span class="line">    y_pred = clf.predict(X_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Classification Report:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(metrics.classification_report(y_test,y_pred))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Confusion Matrix:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(metrics.confusion_matrix(y_test,y_pred))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_and_evaluate(svc_1,X_train,X_test,y_train,y_test)</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录5</title>
    <url>/2023/01/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</url>
    <content><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><h3 id="一、决策树模型："><a href="#一、决策树模型：" class="headerlink" title="一、决策树模型："></a>一、决策树模型：</h3><p>1.决策树基于“树”的结构进行决策</p>
<p>每个“内部”结点对应某个属性上的“测试”</p>
<p>每个分支对应于该测试的一种可能结果（即该属性的某个取值）</p>
<p>每个“叶结点”对应于一个“预测结果”</p>
<p>2.学习过程：</p>
<p>通过对训练样本的分析来确定“划分属性”（即内部结点所对应的属性）</p>
<p>3.预测过程：</p>
<p>将测试实例从根结点开始，沿着划分属性所构成的“判定测试序列”下行，直到叶结点	</p>
<p>4.三种停止的条件：</p>
<p>（1）当前结点包含的样本全属于同一类别，无需划分；</p>
<p>（2）当前属性集为空，或是所有样本在所有属性上的取值相同，无需划分</p>
<p>（3）当前结点所包含的样本集合为空，不能划分</p>
<h3 id="二、信息增益的划分："><a href="#二、信息增益的划分：" class="headerlink" title="二、信息增益的划分："></a>二、信息增益的划分：</h3><p>1.信息增益直接以信息熵为基础，计算当前划分对信息熵所造成的影响（ID3算法使用）</p>
<h3 id="三、其他属性的划分："><a href="#三、其他属性的划分：" class="headerlink" title="三、其他属性的划分："></a>三、其他属性的划分：</h3><p>1.增益率</p>
<p>2.启发式：先从候选划分属性中找到信息增益高于平均水平的，再从中选取增益率最高的（C4.5算法使用）</p>
<p>3.基尼系数</p>
<p>在候选属性集合中，选取那个使划分后基尼系数最小的属性（CART算法使用）</p>
<h3 id="四、决策树的剪枝："><a href="#四、决策树的剪枝：" class="headerlink" title="四、决策树的剪枝："></a>四、决策树的剪枝：</h3><p>1.剪枝是决策树用来防止过拟合的主要手段</p>
<p>2.基本策略：</p>
<p>预剪枝</p>
<p>后剪枝</p>
<p>3.在使用单个决策树的时候，一定要考虑剪枝</p>
<h3 id="五、缺失值的处理："><a href="#五、缺失值的处理：" class="headerlink" title="五、缺失值的处理："></a>五、缺失值的处理：</h3><p>1.样本赋权，权重划分</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习记录1</title>
    <url>/2023/01/28/java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="一、面向对象的概念："><a href="#一、面向对象的概念：" class="headerlink" title="一、面向对象的概念："></a>一、面向对象的概念：</h3><p>1.在面向对象（oop）中，程序被看做相互协作的对象集合，每个对象都是某个类的实例，所有类构成一个通过继承关系相联系的层次结构。</p>
<p>2.面向对象的特性：</p>
<p>封装、继承、多态</p>
<h3 id="二、类和对象："><a href="#二、类和对象：" class="headerlink" title="二、类和对象："></a>二、类和对象：</h3><p>1.在java中使用class关键字来定义类，使用new关键字可以实例化一个对象。</p>
<p>2.可以在类体中声明两种类的成员：成员变量和成员方法</p>
<p>成员变量是类的属性</p>
<p>3.一个方法最多只能有一个变长参数</p>
<p>4.this关键字指向的是当前对象的引用 </p>
<p>5.系统常用的类：</p>
<p>Date类、GregorianCalendar类</p>
<h3 id="三、访问控制符："><a href="#三、访问控制符：" class="headerlink" title="三、访问控制符："></a>三、访问控制符：</h3><p>1.java中有公共的（public）、私有的（private）、保护的（protected）和默认的（default）四种访问控制符</p>
<p>public：所定义的类中的成员变量或方法能够被其他包中的类所访问</p>
<p>default：什么访问控制符都不加，就是默认访问级别，表示一个类的资源仅允许在包内访问，同一子类不能访问</p>
<p>protected：定义为保护级别的成员除了可以在同一类中被访问外，还可以被同一包中的类和子类访问，同一子类可以访问</p>
<p>private：凡是private声明的成员变量或方法只能在类内访问</p>
<p>2.static关键字表示“全局”、“静态”的概念。被static修饰的成员变量和成员方法独立于该类的任何对象，不依赖类的特定实例，被类的所有实例共享。</p>
<p>static修饰的成员变量和成员方法习惯上被称为静态变量和静态方法，可以直接通过类名来访问</p>
<p>3.final关键字表示“不可变”</p>
<p>final成员变量在对象生成时只初始化一次</p>
<p>4.package的使用：</p>
<p>package是类（接口）的集合</p>
<p>包名一般为小写，而类名的第一个字母一般为大写</p>
<p>使用import关键字导入包</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录6</title>
    <url>/2023/01/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956/</url>
    <content><![CDATA[<h1 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h1><h3 id="一、支持向量机基本型："><a href="#一、支持向量机基本型：" class="headerlink" title="一、支持向量机基本型："></a>一、支持向量机基本型：</h3><p>1.线性分类器：正中间的鲁棒性好，泛化能力强</p>
<p>2.间隔与支持向量</p>
<p>3.寻找最大间隔（凸优化）</p>
<p>4.寻找一个线性可分的超平面</p>
<h3 id="二、对偶问题与解的特性："><a href="#二、对偶问题与解的特性：" class="headerlink" title="二、对偶问题与解的特性："></a>二、对偶问题与解的特性：</h3><p>1.使用拉格朗日乘子法</p>
<p>2.解必须满足KKT条件</p>
<p>3.解的稀疏性：训练完成后，最终模型仅与支持向量有关</p>
<h3 id="三、求解方法："><a href="#三、求解方法：" class="headerlink" title="三、求解方法："></a>三、求解方法：</h3><p>1.求解方法：SMO（求解凸优化问题）</p>
<p>2.通常使用所有支持向量求解的平均值</p>
<h3 id="四、特征空间的映射："><a href="#四、特征空间的映射：" class="headerlink" title="四、特征空间的映射："></a>四、特征空间的映射：</h3><p>1.如果原始空间是有限维（属性数有限），那么一定存在一个高维特征空间使样本线性可分</p>
<h3 id="五、核函数（kernel-function）："><a href="#五、核函数（kernel-function）：" class="headerlink" title="五、核函数（kernel function）："></a>五、核函数（kernel function）：</h3><p>1.绕过显式考虑特征映射，以及计算高维内积的困难</p>
<p>2.Mercer定理：若一个对称函数所对应的核矩阵半正定，则它就能作为核函数使用</p>
<p>3.任何一个核函数，都隐式地定义了一个RKHS（再生核希尔伯特空间）</p>
<p>4.核函数选择成为了决定支持向量机性能的关键</p>
<h3 id="六、如何使用SVM："><a href="#六、如何使用SVM：" class="headerlink" title="六、如何使用SVM："></a>六、如何使用SVM：</h3><p>1.以回归学习为例：</p>
<p>允许模型输出与实际输出之间存在2ε的差别</p>
<p>2.支持向量回归使用的ε-不敏感损失函数</p>
<p>3.支持向量回归（SVR）</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习记录2</title>
    <url>/2023/01/29/java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h3 id="一、什么是继承："><a href="#一、什么是继承：" class="headerlink" title="一、什么是继承："></a>一、什么是继承：</h3><p>1.面向对象类中存在以下常见的关系：</p>
<p>USES-A关系，类A用到了类B</p>
<p>HAS-A关系，类A中有类B的成员引用变量，则类A拥有类B</p>
<p>IS-A关系，继承关系，一个类是另一个类的一种</p>
<p>2.被继承的类一般称为“超类”或“父类”，继承的类被称为“子类”</p>
<p>3.使用extends关键字来描述继承</p>
<p>4.一个类可以同时被任意多个类继承</p>
<h3 id="二、继承与隐藏："><a href="#二、继承与隐藏：" class="headerlink" title="二、继承与隐藏："></a>二、继承与隐藏：</h3><p>1.当成员变量声明为private类型时，任何子类均不能继承该成员</p>
<p>2.当成员变量被修饰为protected类型时，若访问该变量的类位于包外，则只有通过继承才能访问该变量</p>
<h3 id="三、方法的重写："><a href="#三、方法的重写：" class="headerlink" title="三、方法的重写："></a>三、方法的重写：</h3><p>1.在子类自身的方法中，若与继承过来的方法具有相同的签名，便构成了方法的重写</p>
<p>2.如果子类重写了方法，则调用子类重写的方法，否则将调用从父类继承的方法</p>
<p>3.重写是基于继承的，如果不能继承一个方法，则不能构成重写，也就不必遵循重写规则</p>
<p>4.可以使用super调用父类被重写的方法</p>
<h3 id="四、方法的重载："><a href="#四、方法的重载：" class="headerlink" title="四、方法的重载："></a>四、方法的重载：</h3><p>1.方法重载是指在同一个类里面，有两个使用或两个以上具有相同名称、不同参数序列的方法</p>
<h3 id="五、final与继承："><a href="#五、final与继承：" class="headerlink" title="五、final与继承："></a>五、final与继承：</h3><p>1.任何其他类都不能继承用final修饰的类</p>
<p>2.什么时候使用final修饰类：需要确保类中的所有方法都不要被重写改进</p>
<h3 id="六、抽象类："><a href="#六、抽象类：" class="headerlink" title="六、抽象类："></a>六、抽象类：</h3><p>1.把很多类具有相同特征的事物归为一个抽象类</p>
<p>2.使用abstract关键字声明抽象类</p>
<p>3.抽象类不能实例化，即不能创建对象</p>
<p>4.当某类继承自抽象类时，如果其本身不是抽象类，则必须实现所继承抽象类中的抽象方法。</p>
<p>也就是说抽象类的第一个非抽象子类必须实现其父类所有的抽象方法，其中也包括父类继承的抽象方法</p>
<p>5.方法永远不可能同时标识为abstract和final，其之间存在着相反的含义</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习记录1</title>
    <url>/2023/01/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="Numpy基础"><a href="#Numpy基础" class="headerlink" title="Numpy基础"></a>Numpy基础</h1><h4 id="一、生成numpy数组："><a href="#一、生成numpy数组：" class="headerlink" title="一、生成numpy数组："></a>一、生成numpy数组：</h4><p>1.numpy封装了一个新的数据类型ndarray，它是一个多维数组对象</p>
<p>2.可以直接对列表、元组等进行转换来生成ndarray</p>
<p>3.使用random模块生成数组：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">np.random.random   <span class="comment"># 生成0到1之间的随机数</span></span><br><span class="line">np.random.uniform  <span class="comment"># 生成均匀分布的随机数</span></span><br><span class="line">np.random.randn    <span class="comment"># 生成标准正态的随机数</span></span><br><span class="line">np.random.randint  <span class="comment"># 生成随机的整数</span></span><br><span class="line">np.random.normal   <span class="comment"># 生成正态分布</span></span><br><span class="line">np.random.shuffle  <span class="comment"># 随机打乱顺序</span></span><br><span class="line">np.random.seed     <span class="comment"># 设置随机种子</span></span><br><span class="line">random_sample      <span class="comment"># 生成随机的浮点数</span></span><br></pre></td></tr></table></figure></div>

<p>4.创建特定形状的多维数组：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros((<span class="number">3</span>,<span class="number">4</span>))    <span class="comment"># 创建3*4的元素全为0的数组</span></span><br><span class="line">np.ones((<span class="number">3</span>,<span class="number">4</span>))     <span class="comment"># 创建3*4的元素全为1的数组</span></span><br><span class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>))    <span class="comment"># 创建2*3的空数组，数据的值并不为0，而是没有初始化的垃圾值</span></span><br><span class="line">np.zero_like(ndarr)<span class="comment"># 以ndarr相同维度创建元素全为0数组</span></span><br><span class="line">np.ones_like(ndarr)<span class="comment"># 以ndarr相同维度创建元素全为1数组</span></span><br><span class="line">np.empty_like(ndarr)<span class="comment"># 以ndarr相同维度创建空数组</span></span><br><span class="line">np.eye(<span class="number">5</span>)          <span class="comment"># 该函数用来创建一个5*5的矩阵，对角线元素为1，其余元素都为0</span></span><br><span class="line">np.full((<span class="number">3</span>,<span class="number">5</span>),<span class="number">666</span>) <span class="comment"># 创建3*5的元素全为666数组，666为指定值</span></span><br></pre></td></tr></table></figure></div>

<p>5.利用arange、linspace函数生成数组：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">arange([start,],[stop][,step,],dtype=<span class="literal">None</span>)</span><br><span class="line">linspace(start,stop,num=<span class="number">50</span>,endpoint=<span class="literal">True</span>,restep=<span class="literal">False</span>,dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></div>

<h4 id="二、获取元素："><a href="#二、获取元素：" class="headerlink" title="二、获取元素："></a>二、获取元素：</h4><p>1.使用切片的方式获取对应的数据</p>
<h4 id="三、numpy算术运算："><a href="#三、numpy算术运算：" class="headerlink" title="三、numpy算术运算："></a>三、numpy算术运算：</h4><p>1.np.multiply用于数组或函数对应元素相乘</p>
<p>2.numpy.dot用来计算矩阵的点积</p>
<h4 id="四、更改数组的形状："><a href="#四、更改数组的形状：" class="headerlink" title="四、更改数组的形状："></a>四、更改数组的形状：</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">arr.reshape    <span class="comment"># 重新将向量arr维度进行改变，不改变向量本身</span></span><br><span class="line">arr.resize     <span class="comment"># 重新将向量arr维度进行变换，修改向量本身</span></span><br><span class="line">arr.T          <span class="comment"># 对向量arr进行转置</span></span><br><span class="line">arr.ravel      <span class="comment"># 对向量arr进行展平，即将多维数组变为一维数组，不会产生原来数组的副本</span></span><br><span class="line">arr.flatten    <span class="comment"># 对向量arr进行展平，即将多维数组变成一维数组，返回原数组的副本</span></span><br><span class="line">arr.squeeze    <span class="comment"># 只能对维数为1的维度进行降维</span></span><br><span class="line">arr.transpose  <span class="comment"># 对高维矩阵进行轴对换</span></span><br></pre></td></tr></table></figure></div>

<h4 id="五、合并数组："><a href="#五、合并数组：" class="headerlink" title="五、合并数组："></a>五、合并数组：</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">np.append      <span class="comment"># 内存占用较大</span></span><br><span class="line">np.concatenate <span class="comment"># 没有内存问题</span></span><br><span class="line">np.stack       <span class="comment"># 沿着新的轴加入一系列数组</span></span><br><span class="line">np.hstack      <span class="comment"># 堆栈数组垂直顺序（行）</span></span><br><span class="line">np.vstack      <span class="comment"># 堆栈数组垂直顺序（列）</span></span><br><span class="line">np.dstack      <span class="comment"># 堆栈数组按顺序深入（沿第三维）</span></span><br><span class="line">np.vsplit      <span class="comment"># 将数组分解成垂直的多个子数组列表</span></span><br></pre></td></tr></table></figure></div>

<h4 id="六、广播机制："><a href="#六、广播机制：" class="headerlink" title="六、广播机制："></a>六、广播机制：</h4><p>1.numpy的Universal functions中要求输入的数组shape是一致的，当数组的shape不相等 时，则会使用广播机制 </p>
<p>2.广播机制满足的规则：</p>
<p>（1）让所有输入数组都向其中shape最长的数组看齐，不足的部分则通过在前面加1补齐</p>
<p>（2）输出数组的shape是输入数组shape的各个轴上的最大值 </p>
<p>（3）如果输入数组的某个轴和输出数组的对应轴的长度相同或者某个轴的长度为1时， 这个数组能被用来计算，否则出错 </p>
<p>（4）当输入数组的某个轴的长度为1时，沿着此轴运算时都用（或复制）此轴上的第一组值 </p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习记录2</title>
    <url>/2023/01/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="Pytorch基础"><a href="#Pytorch基础" class="headerlink" title="Pytorch基础"></a>Pytorch基础</h1><h3 id="一、什么是pytorch："><a href="#一、什么是pytorch：" class="headerlink" title="一、什么是pytorch："></a>一、什么是pytorch：</h3><p>1.Pytorch是一个建立在Torch库上的python包</p>
<p>2.pytorch主要的四个组成：</p>
<p>(1).torch：类似于numpy的通用数组库，可以将张量类型转换为torch.cuda.TensorFloat，在GPU上进行计算</p>
<p>(2).torch.autograd：用于构建计算图形并自动获取梯度的包</p>
<p>(3).torch.nn：具有共享层和损失函数的神经网络库</p>
<p>(4).torch.optim：具有通用优化算法的优化包</p>
<h3 id="二、创建Tensor"><a href="#二、创建Tensor" class="headerlink" title="二、创建Tensor:"></a>二、创建Tensor:</h3><ol>
<li></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">torch.Tensor(*size)     <span class="comment"># 直接从参数构建一个张量，支持list，numpy数组</span></span><br><span class="line">torch.eye(row,column)   <span class="comment"># 创建指定行数，列数的二维单位Tensor</span></span><br><span class="line">torch.linspace(srart,end,steps)   <span class="comment"># 从start到end，均匀切成steps份</span></span><br><span class="line">torch.logspace(start,end,steps)   <span class="comment"># 从10^start，到10^end，均匀切分成steps份</span></span><br><span class="line">torch.rand/randn(*size) <span class="comment"># 生成[0,1)均匀分布/标准正态分布的数据</span></span><br><span class="line">torch.ones(*size)       <span class="comment"># 返回指定shape的张量，元素初始化为1</span></span><br><span class="line">torch.zeros(*size)      <span class="comment"># 返回指定shape的张量，元素初始化为0</span></span><br><span class="line">torch.ones_like(t)      <span class="comment"># 返回与t的shape相同的张量，元素初始化为1</span></span><br><span class="line">torch.zeros_like(t)     <span class="comment"># 返回与他的shape相同的张量，元素初始化为0</span></span><br><span class="line">torch.arange(start,end,step)      <span class="comment"># 在区间[start,end)上以间隔step生成一个序列张量</span></span><br><span class="line">torch.from_Numpy(ndarray)         <span class="comment"># 从ndarray创建一个Tensor</span></span><br></pre></td></tr></table></figure></div>

<h3 id="三、修改tensor的形状："><a href="#三、修改tensor的形状：" class="headerlink" title="三、修改tensor的形状："></a>三、修改tensor的形状：</h3><ol>
<li></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">size()         <span class="comment"># 返回张量的shape属性值</span></span><br><span class="line">numel(<span class="built_in">input</span>)   <span class="comment"># 计算tensor的元素个数</span></span><br><span class="line">view(*shape)   <span class="comment"># 修改tensor的shape，返回原来的tensor</span></span><br><span class="line">resize         <span class="comment"># 类似于view，但是size超出时会重新分配内存空间</span></span><br><span class="line">item           <span class="comment"># 若tensor为单元素，则返回python的标量</span></span><br><span class="line">unsqueeze      <span class="comment"># 在指定的维度增加一个“1”</span></span><br><span class="line">squeeze        <span class="comment"># 在指定的维度压缩一个“1”</span></span><br></pre></td></tr></table></figure></div>

<h3 id="四、索引操作："><a href="#四、索引操作：" class="headerlink" title="四、索引操作："></a>四、索引操作：</h3><ol>
<li></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">index_select(<span class="built_in">input</span>,dim,index)   <span class="comment"># 在指定维度上选择一些行或列</span></span><br><span class="line">nonzero(<span class="built_in">input</span>)                  <span class="comment"># 获取非0元素的下标</span></span><br><span class="line">masked_select(<span class="built_in">input</span>,mask)       <span class="comment"># 使用二元值进行选择</span></span><br><span class="line">gather(<span class="built_in">input</span>,dim,index)         <span class="comment"># 在指定维度上选择数据，输出形状与index一致</span></span><br><span class="line">scatter_(<span class="built_in">input</span>,dim,index,src)   <span class="comment"># 为gather的反操作，根据指定索引补充数据</span></span><br></pre></td></tr></table></figure></div>

<h3 id="五、广播机制："><a href="#五、广播机制：" class="headerlink" title="五、广播机制："></a>五、广播机制：</h3><p>1.与numpy中的广播机制类似，pytorch也支持广播机制</p>
<h3 id="六、归并操作："><a href="#六、归并操作：" class="headerlink" title="六、归并操作："></a>六、归并操作：</h3><ol>
<li></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">cumprod(t,axis)     <span class="comment"># 在指定维度对t进行累积</span></span><br><span class="line">cumsum              <span class="comment"># 在指定维度对t进行累加</span></span><br><span class="line">dist(a,b,p=<span class="number">2</span>)       <span class="comment"># 返回a,b之间的p阶范数</span></span><br><span class="line">mean/median         <span class="comment"># 均值/中位数</span></span><br><span class="line">std/var             <span class="comment"># 标准差/方差</span></span><br><span class="line">norm(t,p=<span class="number">2</span>)         <span class="comment"># 返回t的p阶范数</span></span><br><span class="line">prod(t)/<span class="built_in">sum</span>(t)      <span class="comment"># 返回t的所有元素的积/和</span></span><br></pre></td></tr></table></figure></div>

<h3 id="七、比较操作："><a href="#七、比较操作：" class="headerlink" title="七、比较操作："></a>七、比较操作：</h3><ol>
<li></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">eq                  <span class="comment"># 比较tensor是否相等，支持broadcast</span></span><br><span class="line">equal               <span class="comment"># 比较tensor是否有相同的shape与值</span></span><br><span class="line">ge/le/gt/lt         <span class="comment"># 大于/小于比较/大于等于/小于等于比较</span></span><br><span class="line"><span class="built_in">max</span>/<span class="built_in">min</span>(t,axis)     <span class="comment"># 返回最值，若指定axis，则额外返回下标</span></span><br><span class="line">top(t,k,axis)       <span class="comment"># 在指定的axis维上取最高的K个值</span></span><br></pre></td></tr></table></figure></div>

<h3 id="八、矩阵操作："><a href="#八、矩阵操作：" class="headerlink" title="八、矩阵操作："></a>八、矩阵操作：</h3><ol>
<li></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">dot(t1,t2)         <span class="comment"># 计算张量（1D）的内积或点积</span></span><br><span class="line">mm(mat1,mat2)/bmm(batch1,batch2)   <span class="comment"># 计算矩阵乘法/含batch的3D矩阵乘法</span></span><br><span class="line">mv(t1,v1)          <span class="comment"># 计算矩阵与向量乘法</span></span><br><span class="line">t                  <span class="comment"># 计算转置</span></span><br><span class="line">svd(t)             <span class="comment"># 计算t的SVD分解</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录7</title>
    <url>/2023/01/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%957/</url>
    <content><![CDATA[<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><h4 id="一、神经网络模型："><a href="#一、神经网络模型：" class="headerlink" title="一、神经网络模型："></a>一、神经网络模型：</h4><p>1.神经网络是由具有适应性的简单单元组成的广泛并行互连的网络</p>
<p>2.神经网络是一个很大的学科领域，在机器学习中研究的是神经网络学习，亦称为连接主义学习</p>
<p>3.神经网络学到的知识蕴含在连接权重和阈值</p>
<p>4.神经网络需要激活函数，如sigmoid函数</p>
<p>5.前馈网络：神经元之间不存在同层连接也不存在跨层连接</p>
<h4 id="二、万有逼近能力："><a href="#二、万有逼近能力：" class="headerlink" title="二、万有逼近能力："></a>二、万有逼近能力：</h4><p>1.多层前馈神经网络有强大的表示能力</p>
<p>2.仅需一个包含足够多神经元的隐层，多层前馈神经网络就能以任意精度逼近任意复杂度的连续函数</p>
<h4 id="三、BP算法（误差反向传播算法）："><a href="#三、BP算法（误差反向传播算法）：" class="headerlink" title="三、BP算法（误差反向传播算法）："></a>三、BP算法（误差反向传播算法）：</h4><p>1.BP是一个迭代学习算法，在迭代的每一轮中采用广义感知机学习规则</p>
<p>2.BP算法基于梯度下降策略，以目标的负梯度方向对参数进行调整</p>
<p>3.学习率不能太大，也不能太小。取值在0-1之间</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录8</title>
    <url>/2023/02/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%958/</url>
    <content><![CDATA[<h1 id="贝叶斯分类器"><a href="#贝叶斯分类器" class="headerlink" title="贝叶斯分类器"></a>贝叶斯分类器</h1><h3 id="一、贝叶斯决策论："><a href="#一、贝叶斯决策论：" class="headerlink" title="一、贝叶斯决策论："></a>一、贝叶斯决策论：</h3><p>1.概率框架下实施决策的基本理论</p>
<p>2.h*称为贝叶斯最优分类器，其总体风险称为贝叶斯风险</p>
<p>反映了学习性能的理论上限</p>
<h3 id="二、生成式和判别式模型："><a href="#二、生成式和判别式模型：" class="headerlink" title="二、生成式和判别式模型："></a>二、生成式和判别式模型：</h3><p>1.判别式：直接对条件概率分布建模</p>
<p>2.生成式：先对联合概率分布建模，再由此得到条件概率</p>
<h3 id="三、贝叶斯分类器和贝叶斯学习："><a href="#三、贝叶斯分类器和贝叶斯学习：" class="headerlink" title="三、贝叶斯分类器和贝叶斯学习："></a>三、贝叶斯分类器和贝叶斯学习：</h3><p>1.频率主义：统计学习，点估计</p>
<p>2.贝叶斯主义：贝叶斯学习，分布估计</p>
<h3 id="四、极大似然估计："><a href="#四、极大似然估计：" class="headerlink" title="四、极大似然估计："></a>四、极大似然估计：</h3><p>1.先假设某种概率分布形式，再基于训练样例对参数进行估计</p>
<h3 id="五、朴素贝叶斯分类器："><a href="#五、朴素贝叶斯分类器：" class="headerlink" title="五、朴素贝叶斯分类器："></a>五、朴素贝叶斯分类器：</h3><p>1.主要的障碍：所有属性上的联合概率难以从有限的训练样本获得、组合爆炸、样本稀疏</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录9</title>
    <url>/2023/02/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%959/</url>
    <content><![CDATA[<h1 id="集成学习和聚类"><a href="#集成学习和聚类" class="headerlink" title="集成学习和聚类"></a>集成学习和聚类</h1><h3 id="一、集成学习："><a href="#一、集成学习：" class="headerlink" title="一、集成学习："></a>一、集成学习：</h3><p>1.使用多个模型来学习</p>
<p>分为同质集成学习和异质集成学习</p>
<h3 id="二、好而不同："><a href="#二、好而不同：" class="headerlink" title="二、好而不同："></a>二、好而不同：</h3><p>1.个体学习器“好而不同”</p>
<p>2.误差-分歧分解</p>
<p><a href="https://imgse.com/i/ppJWMMn"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJWMMn.png"
                      alt="ppJWMMn.png"
                ></a></p>
<h3 id="三、两类常用的集成学习方法："><a href="#三、两类常用的集成学习方法：" class="headerlink" title="三、两类常用的集成学习方法："></a>三、两类常用的集成学习方法：</h3><p>1.序列化方法：boosting</p>
<p>2.并行化方法：bagging</p>
<h3 id="四、Boosting："><a href="#四、Boosting：" class="headerlink" title="四、Boosting："></a>四、Boosting：</h3><p>1.残差最小化，残差逼近</p>
<p>2.序列化模型</p>
<h3 id="五、Bagging："><a href="#五、Bagging：" class="headerlink" title="五、Bagging："></a>五、Bagging：</h3><p>1.使用可重复采样</p>
<p>2.投票做分类，平均做回归</p>
<h3 id="六、多样性度量："><a href="#六、多样性度量：" class="headerlink" title="六、多样性度量："></a>六、多样性度量：</h3><p>1.多样性是集成学习的关键</p>
<p>2.多样性度量：一般通过两分类器的预测结果列联表定义</p>
<p>如不合度量、相关系数、Q-统计量、K-统计量</p>
<h3 id="七、聚类："><a href="#七、聚类：" class="headerlink" title="七、聚类："></a>七、聚类：</h3><p>1.聚类是“无监督学习”中研究最多、应用最广的任务</p>
<p>2.聚类的目标：将数据样本划分为若干个通常不相交的“簇”</p>
<p>既可以作为一个单独任务（用于寻找数据内在的分布结构），也可以作为分类等其他学习任务的前驱过程</p>
<h3 id="八、聚类方法概述："><a href="#八、聚类方法概述：" class="headerlink" title="八、聚类方法概述："></a>八、聚类方法概述：</h3><p>1.聚类的好坏不存在绝对标准</p>
<p>2.在聚类中，总能找到一个新的“标准”，使得以往的算法对它无能为力</p>
<p>3.常用的聚类方法：</p>
<p>（1）原型聚类：亦称为“基于原型的聚类”</p>
<p>​	 假设：聚类结构能通过一组原型刻画</p>
<p>​	 过程：先对原型初始化，然后对原型进行迭代更新求解</p>
<p>​	 代表：K均值聚类，学习向量量化（LVQ），高斯混合聚类</p>
<p>（2）密度聚类：亦称为“基于密度的聚类”</p>
<p>​	 假设：聚类结构能通过样本分布的紧密程度确定</p>
<p>​	 过程：从样本密度的角度来考察样本之间的可连接性，并基于可连接性样本不断扩展聚类簇</p>
<p>​	 代表：DBSCAN，OPTICS，DENCLUE</p>
<p>（3）层次聚类：</p>
<p>​	 假设：能够产生不同粒度的聚类结果</p>
<p>​	 过程：在不同层次对数据集进行划分，从而形成树形的聚类结构</p>
<p>​	 代表：AGNES（自底向上），DIANA（自顶向下）</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录1</title>
    <url>/2023/02/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h1><h4 id="一、计算机系统的组成"><a href="#一、计算机系统的组成" class="headerlink" title="一、计算机系统的组成"></a>一、计算机系统的组成</h4><p><a href="https://imgse.com/i/ppJosot"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJosot.png"
                      alt="ppJosot.png"
                ></a></p>
<h4 id="二、软件"><a href="#二、软件" class="headerlink" title="二、软件"></a>二、软件</h4><p>（1）系统软件：</p>
<p>​	语言处理系统</p>
<p>​	操作系统</p>
<p>​	服务性程序</p>
<p>​	数据库管理系统</p>
<p>​	网络软件</p>
<p>（2）应用软件：</p>
<p>​	按任务需要编制的各种软件</p>
<h4 id="三、层次结构"><a href="#三、层次结构" class="headerlink" title="三、层次结构"></a>三、层次结构</h4><p>   微指令系统—————-微程序的机器M1</p>
<p>   机器语言——————-实际的机器M1</p>
<p>   操作系统——————- 虚拟机器</p>
<p>   汇编语言——————-虚拟的机器M2</p>
<p>   高级语言——————-虚拟的机器M3</p>
<h4 id="四、计算机组成："><a href="#四、计算机组成：" class="headerlink" title="四、计算机组成："></a>四、计算机组成：</h4><p>1.实现计算机体系结构所体现出来的属性（集体指令的实现）</p>
<h4 id="五、计算机的基本组成："><a href="#五、计算机的基本组成：" class="headerlink" title="五、计算机的基本组成："></a>五、计算机的基本组成：</h4><p>1.（冯诺依曼计算机）计算机由五大部件组成</p>
<p><a href="https://imgse.com/i/ppJowsH"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJowsH.png"
                      alt="ppJowsH.png"
                ></a></p>
<p>2.指令和数据以同等的地位存储在存储器中，可以按照地址访问</p>
<p>3.指令和数据由二进制表示</p>
<p>4.指令由操作码和地址码组成 </p>
<p>5.程序存储在存储器中</p>
<p>6.以运算器（ALU）为中心</p>
<p>运算器的功能：算术运算和逻辑运算</p>
<p>控制器（CU）的功能：分析指令，发出控制信号</p>
<h4 id="六、冯诺依曼系统的改进"><a href="#六、冯诺依曼系统的改进" class="headerlink" title="六、冯诺依曼系统的改进"></a>六、冯诺依曼系统的改进</h4><p>1.以存储器为核心</p>
<p>2.将运算器（ALU）和控制器（CU）合起来组成CPU</p>
<p><a href="https://imgse.com/i/ppYSFpj"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYSFpj.png"
                      alt="ppYSFpj.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录2</title>
    <url>/2023/02/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h4 id="一、硬件结构："><a href="#一、硬件结构：" class="headerlink" title="一、硬件结构："></a>一、硬件结构：</h4><p><a href="https://imgse.com/i/ppJf0pQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJf0pQ.png"
                      alt="ppJf0pQ.png"
                ></a></p>
<h4 id="二、系统复杂性管理的方法："><a href="#二、系统复杂性管理的方法：" class="headerlink" title="二、系统复杂性管理的方法："></a>二、系统复杂性管理的方法：</h4><p>1.3Y方法：层次化、模块化、规则化</p>
<h4 id="三、存储器的基本组成："><a href="#三、存储器的基本组成：" class="headerlink" title="三、存储器的基本组成："></a>三、存储器的基本组成：</h4><p>1.指令的结构包括操作码和地址码</p>
<p>2.指令和数据都保存在存储器中</p>
<p>3.<a href="https://imgse.com/i/ppJfRtU"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfRtU.png"
                      alt="ppJfRtU.png"
                ></a></p>
<p>4.存储体—–存储单元——-存储元件</p>
<p>存储单元存放一串二进制代码</p>
<p>存储字：存储单元中二进制代码的组合</p>
<p>存储字长：存储单元中二进制代码的位数</p>
<p>每一个存储单元都有一个地址</p>
<p>5.MAR：存储器地址寄存器，反映了存储单元的个数</p>
<p>  MDR：存储器数据寄存器，反映了存储字长</p>
<h4 id="四、运算器的基本组成和功能："><a href="#四、运算器的基本组成和功能：" class="headerlink" title="四、运算器的基本组成和功能："></a>四、运算器的基本组成和功能：</h4><p>1.ACC、X和MQ（乘商寄存器）都是寄存器</p>
<p><a href="https://imgse.com/i/ppJfdfg"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfdfg.png"
                      alt="ppJfdfg.png"
                ></a></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th>ACC</th>
<th>MQ</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td align="left">加法</td>
<td>被加数    和</td>
<td></td>
<td>加数</td>
</tr>
<tr>
<td align="left">减法</td>
<td>被减数     差</td>
<td></td>
<td>减数</td>
</tr>
<tr>
<td align="left">乘法</td>
<td>乘积高位</td>
<td>乘数    乘积低位</td>
<td>被乘数</td>
</tr>
<tr>
<td align="left">除法</td>
<td>被除数     余数</td>
<td>商</td>
<td>除数</td>
</tr>
</tbody></table>
<h4 id="五、控制器的基本组成和功能："><a href="#五、控制器的基本组成和功能：" class="headerlink" title="五、控制器的基本组成和功能："></a>五、控制器的基本组成和功能：</h4><p>1.控制器的功能：</p>
<p>解释指令、保证指令的按序执行</p>
<p>2.完成一条指令的过程：取指令、分析指令、执行指令</p>
<p>3.取指令用到的寄存器：PC、分析指令用到的寄存器：IR、执行指令用到的寄存器：CU</p>
<p>4.取指令的过程：</p>
<p>PC→MAR→主存→MDR→IR， （PC）+ 1 →PC</p>
<p>5.分析指令的过程：</p>
<p>op(IR)→CU</p>
<p>6.执行指令的过程（以加法为例）：</p>
<p>Ad(IR)→MAR→主存→MDR→ACC</p>
<h4 id="六、硬件结构："><a href="#六、硬件结构：" class="headerlink" title="六、硬件结构："></a>六、硬件结构：</h4><p><a href="https://imgse.com/i/ppJfrXn"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfrXn.png"
                      alt="ppJfrXn.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习记录3</title>
    <url>/2023/02/02/java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="java中类的特性"><a href="#java中类的特性" class="headerlink" title="java中类的特性"></a>java中类的特性</h1><h3 id="一、构造函数："><a href="#一、构造函数：" class="headerlink" title="一、构造函数："></a>一、构造函数：</h3><p>1.构造方法是一种特殊的方法，它是在对象被创建时初始化对象成员的方法</p>
<p>2.构造方法的名称必须与它所在的类名完全相同</p>
<p>3.构造方法没有返回值，但在定义构造方法时，构造方法名前不能用修饰符void来修饰，这是因为一个类的构造方法的返回值类型就是该类本身</p>
<p>4.构造方法定义后，创建对象时就会自动调用它，因此构造方法不需要在程序中直接调用，而是在对象创建时自动调用并执行。这一点不同于一般的方法，一般的方法在用到时才调用</p>
<p>5.从某一构造方法内调用另一构造方法，必须通过this（）语句来调用。</p>
<h3 id="二、构造方法的重载："><a href="#二、构造方法的重载：" class="headerlink" title="二、构造方法的重载："></a>二、构造方法的重载：</h3><p>1.当一个类有多个构造方法时，则这多个构造方法可以重载</p>
<h3 id="三、java语言的垃圾回收："><a href="#三、java语言的垃圾回收：" class="headerlink" title="三、java语言的垃圾回收："></a>三、java语言的垃圾回收：</h3><p>1.在java程序的生命周期中，java运行环境提供了一个系统的垃圾回收线程，负责自动回收那些没有被引用的对象所占用的内存。</p>
<p>2.当一个对象被创建时，JVM会为该对象分配一定的内存、调用该对象的构造方法并开始跟踪该对象。当该对象停止使用时，JVM将通过垃圾回收器回收该对象所占用的内存</p>
<p>3.垃圾回收的优点：</p>
<p>（1）把程序员从复杂的内存追踪、检测、释放的工作中解放出来</p>
<p>（2）防止系统的内存被非法释放，从而使得系统更加稳定</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习记录1</title>
    <url>/2023/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念:"></a>一、基本概念:</h4><p>1.互联网：特指internet，起源于美国，已经发展成为世界上最大的、覆盖全球的计算机网络</p>
<p>2.网络：由若干结点和连接这些结点的链路组成</p>
<p>3.互连网：通过路由器把网络互连起来（网络的网络）</p>
<p>4.习惯上，与网络相连的计算机称为主机</p>
<h4 id="二、互联网发展的阶段："><a href="#二、互联网发展的阶段：" class="headerlink" title="二、互联网发展的阶段："></a>二、互联网发展的阶段：</h4><p>1.第一阶段：从单个网络ARPANET向互联网发展的过程</p>
<p>人们把1983年作为因特网的诞生时间</p>
<p>2.第二阶段：建成了三级结构的互联网</p>
<p>3.第三阶段：逐渐形成了多层次ISP结构的互联网</p>
<p>出现了互联网服务提供者ISP</p>
<h4 id="三、互联网的标准化："><a href="#三、互联网的标准化：" class="headerlink" title="三、互联网的标准化："></a>三、互联网的标准化：</h4><p>1.互联网协会ISOC</p>
<p>2.所有的互联网标准都以RFC（文档）的形式在互联网上发表</p>
<h4 id="四、互联网的组成："><a href="#四、互联网的组成：" class="headerlink" title="四、互联网的组成："></a>四、互联网的组成：</h4><p>1.互联网的边缘部分：由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来通信（传送数据、音频和视频）和资源共享</p>
<p>边缘部分也称为边缘子网</p>
<p>2.处在边缘部分的主机也称为端系统</p>
<p>3.端系统之间的通信方式可划分成两大类：</p>
<p>（1）客户-服务器方式（C&#x2F;S方式）</p>
<p>描述进程之间服务和被服务的关系</p>
<p>客户是服务的请求方，服务器是服务的提供方</p>
<p>（2）对等方式（P2P方式）</p>
<p>对等连接是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方</p>
<p>只要两个主句都运行了对等连接软件（P2P软件），它们就可以进行对等的、对等连接通信</p>
<p>4.互联网的核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务（提供连通性和变换）</p>
<p>核心部分也称为通信子网</p>
<p>5.路由器是实现分组交换的关键构件，器任务是转发收到的分组，这是网络核心部分的重要功能</p>
<h4 id="五、电路交换："><a href="#五、电路交换：" class="headerlink" title="五、电路交换："></a>五、电路交换：</h4><p>1.电路交换的特点：</p>
<p>电路交换必定是面向连接的</p>
<p>2.电路交换的三个阶段：</p>
<p>建立连接、通信、释放连接	</p>
<p>3.电路交换的缺点：</p>
<p>（1）计算机数据具有突发性</p>
<p>（2）传送计算机数据时，通信线路的利用率低</p>
<h4 id="六、分组交换："><a href="#六、分组交换：" class="headerlink" title="六、分组交换："></a>六、分组交换：</h4><p>1.分组交换采用存储转发技术</p>
<p>2.在发送端，先把较长的报文划分成较短的、固定长度的数据段</p>
<p>3.在每一个数据段前面添加上首部构成分组</p>
<p><a href="https://imgse.com/i/ppYpqsI"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYpqsI.png"
                      alt="ppYpqsI.png"
                ></a></p>
<p>4.分组交换网以“分组”作为数据传输单元，依次把各个分组发送到接收端</p>
<p>5.每一个分组的首部都含有地址和控制信息</p>
<p>6.每一个分组在互联网独立地选择传输路径</p>
<p>7.路由器处理分组的过程：</p>
<p>（1）把收到的分组先放入缓存（暂时存储）</p>
<p>（2）查找转发表，找到某个目的地址应该从哪个端口转发</p>
<p>（3）把分组送到适当的端口转发出去</p>
<p>8.分组交换的优点：</p>
<p>高效、灵活、迅速、可靠</p>
<p>9.分组交换的缺点：</p>
<p>会有一定的时延、分组必须携带的首部会造成一定的开销</p>
<p>10、存储转发在报文交换中也会出现</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习记录4</title>
    <url>/2023/02/03/java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h1 id="接口与枚举"><a href="#接口与枚举" class="headerlink" title="接口与枚举"></a>接口与枚举</h1><h4 id="一、接口"><a href="#一、接口" class="headerlink" title="一、接口"></a>一、接口</h4><p>1.接口的结构与抽象类非常类似。其本身也有数据成员、抽象方法、默认方法和静态方法</p>
<p>2.接口的数据成员都是静态的且必须初始化，即数据成员必须是静态常量	</p>
<p>3.接口中除了声明抽象方法外，还可以定义静态方法和默认方法</p>
<p>4.接口中的静态方法是用public static修饰的；而默认方法是用public default修饰的。接口中的抽象方法不能有方法的实现，即不能有方法体</p>
<p>5.接口与抽象类一样不能使用new运算符直接创建对象。</p>
<p>6.接口的事项类似于继承，在声明类的同时使用implements关键字来实现一个接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">class 类名 implements 接口名</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>7.接口可以实现多重继承</p>
<p>8.如果子接口中定义了与父接口同名的常量或者相同名称的方法，则父接口中的常量被隐藏，方法被覆盖。</p>
<h4 id="二、枚举"><a href="#二、枚举" class="headerlink" title="二、枚举"></a>二、枚举</h4><p>1.枚举是一种特殊的类，所以枚举也称为枚举类，它是一种引用类型</p>
<p>其语法格式如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符]<span class="keyword">enum</span> 枚举类型名</span><br><span class="line">&#123;</span><br><span class="line">	枚举成员</span><br><span class="line">        方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>2.枚举的所有枚举成员必须在枚举体的第一行显式列出，否则该枚举不能产生枚举成员</p>
<p>3.枚举可以实现一个或多个接口，使用enum关键字声明的枚举默认继承了java.lang.Enum类</p>
<p>4.使用enum定义非抽象的枚举类时默认使用final修饰，因此枚举类不能派生子类</p>
<p>5.创建枚举类型的对象时不能使用new运算符，而是直接将枚举成员赋值给枚举对象</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql学习记录1</title>
    <url>/2023/02/04/Mysql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h4 id="一、mysql的基本概念："><a href="#一、mysql的基本概念：" class="headerlink" title="一、mysql的基本概念："></a>一、mysql的基本概念：</h4><p>1.MySQL是一个小型关系数据库管理系统。</p>
<p>2.mysql的主要优势：</p>
<p>速度快、可移植性强、接口丰富</p>
<p>3.mysql8.0的新特性：</p>
<p>（1）数据字典</p>
<p>（2）原子数据定义</p>
<p>（3）安全和账户管理</p>
<p>（4）资源管理</p>
<p>（5）InnoDB的增强</p>
<p>（6）字符集的支持</p>
<p>（7）增强json功能</p>
<p>（8）数据类型支持</p>
<p>（9）查询优化</p>
<p>（10）共用表表达式</p>
<p>（11）窗口函数</p>
<p>（12）统计直方图</p>
<p>（13）备份锁</p>
<h4 id="二、数据库基本操作："><a href="#二、数据库基本操作：" class="headerlink" title="二、数据库基本操作："></a>二、数据库基本操作：</h4><p>1.创建数据库：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;   # 查看当前所有存在的数据库</span><br><span class="line">create database database_name; # 创建一个数据库</span><br></pre></td></tr></table></figure></div>

<p>2.删除数据库：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database database_name;   # 删除数据库 </span><br></pre></td></tr></table></figure></div>

<p>3.从MySQL 8.0开始，系统表全部换成事务型的InnoDB表，默认的MySQL实例将不包含任何MyISAM表，除非手动创建MyISAM表</p>
<h4 id="三、数据表的基本操作："><a href="#三、数据表的基本操作：" class="headerlink" title="三、数据表的基本操作："></a>三、数据表的基本操作：</h4><p>1.创建数据表：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建员工数据表</span><br><span class="line">CREATE TABLE tb_emp1</span><br><span class="line">(</span><br><span class="line">    id   INT(11),</span><br><span class="line">    NAME VARCHAR(25),</span><br><span class="line">    deptid INT(11),</span><br><span class="line">    salary FLOAT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>2.主键约束：</p>
<p>主键，又称主码，是表中一列或多列的组合。主键约束（Primary Key Constraint）要求主键列的数据唯一，并且不允许为空</p>
<p>3.主键分为单字段主键和多字段联合主键</p>
<p>4.外键约束：</p>
<p>外键用来在两个表的数据之间建立连接，可以是一列或者多列。一个表可以有一个或多个外键</p>
<p>外键：首先它是表中的一个字段，虽可以不是本表的主键，但要对应另外一个表的主键。</p>
<p>5.非空约束：</p>
<p>非空约束（Not Null Constraint）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统会报错唯一性约束</p>
<p>6.唯一性约束</p>
<p>唯一性约束（Unique Constraint）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值</p>
<p>7.查看数据表的结构：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">describe 表名;   # 查看表的基本结构</span><br><span class="line">show create table 表名; # 查看表的详细结构</span><br></pre></td></tr></table></figure></div>

<p>8.修改数据表：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table &lt;旧表名&gt; rename &lt;新表名&gt;; </span><br><span class="line"># 修改表名，修改表名并不修改表的结构，因此修改名称后的表和修改名称前的表的结构必然是相同的</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_emp6 MODIFY NAME VARBINARY(30);  # 修改表的字段类型</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_emp1 ADD managerId INT(10) PRIMARY KEY;  #在表的最后添加字段</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_emp1 ADD column3 INT(11) AFTER NAME;  #在表的指定列添加一个字段</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_emp1 DROP column3;  # 删除字段</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_emp1 MODIFY NAME VARCHAR(25) FIRST;  # 修改name字段为表的第一个字段</span><br><span class="line">DROP TABLE IF EXISTS tb_emp7; # 删除数据表tb_emp7</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql学习记录2</title>
    <url>/2023/02/05/Mysql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h3 id="一、数学函数："><a href="#一、数学函数：" class="headerlink" title="一、数学函数："></a>一、数学函数：</h3><p>1.绝对值函数ABS（）</p>
<p>2.返回圆周率的函数PI（）</p>
<p>3.平方根函数SQRT（）</p>
<p>4.求余数函数MOD（x，y）</p>
<p>5.获取整数的函数CEIL（x），CEILING（x）和FLOOR（x）</p>
<p>6.获取随机数的函数RAND（）和RAND（x）</p>
<p>7.四舍五入ROUND（x）</p>
<p>8.符号函数SIGN（x）</p>
<p>9.幂运算POW（x,y）</p>
<p>10.对数运算LOG（x），返回自然对数</p>
<p>11.角度与弧度转换：</p>
<p>RADIANS（x）将角度转换为弧度</p>
<p>DEGREES（x）将弧度转换为角度</p>
<p>12.正弦函数SIN（x）</p>
<p>13.反正弦函数ASIN（x）</p>
<p>14.余弦函数COS（x）</p>
<p>15.反余弦函数ACOS（x）</p>
<p>16.正切函数TAN（x）</p>
<p>17.反正切函数ATAN（x）</p>
<p>18.余切函数COT（x）</p>
<p>注：使用函数时要加select</p>
<h3 id="二、字符串函数："><a href="#二、字符串函数：" class="headerlink" title="二、字符串函数："></a>二、字符串函数：</h3><p>1.CHAR_LENGTH(str)返回值为字符串str所包含的字符个数。一个多字节字符算作一个单字符</p>
<p>2.LENGTH(str)返回值为字符串的字节长度，使用utf8编码字符集时，一个汉字是3字节，一个数字或字母算1字节</p>
<p>3.CONCAT(s1,s2……)返回结果为连接参数产生的字符串，或许有一个或多个参数</p>
<p>4.CONCAT_WS函数连接带分隔符的字符串</p>
<p>5.INSERT(s1,x,len,s2)返回字符串s1，其子字符串起始于x位置和被字符串s2取代的len字符</p>
<p>6.LOWER (str)或者LCASE (str)可以将字符串str中的字母字符全部转换成小写字母</p>
<p>7.LEFT(s,n)返回字符串s开始的最左边n个字符</p>
<p>8.RIGHT(s,n)返回字符串str最右边的n个字符</p>
<p>9.LPAD(s1,len,s2)返回字符串s1，其左边由字符串s2填补到len字符长度。假如s1的长度大于len，则返回值被缩短至len字符</p>
<p>10.PAD(s1,len,s2)返回字符串sl，其右边被字符串s2填补至len字符长度。假如字符串s1的长度大于len，则返回值被缩短到len字符长度</p>
<p>11.LTRIM(s)返回字符串s，字符串左侧空格字符被删除</p>
<p>12.RTRIM(s)返回字符串s，字符串右侧空格字符被删除。</p>
<p>13.TRIM(s)删除字符串s两侧的空格</p>
<p>14.TRIM(s1 FROM s)删除字符串s中两端所有的子字符串s1。s1为可选项，在未指定情况下，删除空格1</p>
<p>15.REPEAT(s,n)返回一个由重复的字符串s组成的字符串，字符串s的数目等于n。若n&lt;&#x3D;0，则返回一个空字符串。若s或n为NULL，则返回NULL</p>
<p>16.SPACE(n)返回一个由n个空格组成的字符串</p>
<p>17.REPLACE(s,s1,s2)使用字符串s2替代字符串s中所有的字符串s1</p>
<p>18.STRCMP(s1,s2)：若所有的字符串均相同，则返回0；若根据当前分类次序，第一个参数小于第二个，则返回-1；其他情况返回1</p>
<p>19.SUBSTRING(s,n,len)带有len参数的格式，从字符串s返回一个长度与len字符相同的子字符串，起始于位置n</p>
<p>20.MID()函数获取指定位置处的子字符串</p>
<p>21.LOCATE(str1,str)、POSITION(str1 IN str)和INSTR(str, str1)3个函数的作用相同，返回子字符串str1在字符串str中的开始位置</p>
<p>22.REVERSE(s)将字符串s反转，返回的字符串的顺序和s字符串顺序相反</p>
<p>23.ELT(N，字符串1，字符串2，字符串3，…，字符串N)：若N &#x3D; 1，则返回值为字符串1；若N&#x3D;2，则返回值为字符串2；以此类推；若N小于1或大于参数的数目，则返回值为NULL</p>
<p>24.FIELD(s,s1,s2,…,sn)返回字符串s在列表s1,s2,…,sn中第一次出现的位置，在找不到s的情况下，返回值为0。如果s为NULL，则返回值为0，原因是NULL不能同任何值进行同等比较</p>
<p>25.FIND_IN_SET(s1,s2)返回字符串s1在字符串列表s2中出现的位置，字符串列表是一个由多个逗号‘,’分开的字符串组成的列表</p>
<p>26.MAKE_SET(x,s1,s2,…,sn)函数按x的二进制数从s1，s2,…,sn中选取字符串</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习记录5</title>
    <url>/2023/02/06/java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h3 id="一、什么是JDBC："><a href="#一、什么是JDBC：" class="headerlink" title="一、什么是JDBC："></a>一、什么是JDBC：</h3><p>1.jdbc表示java数据库连接，是用java语言与数据库连接的API</p>
<p>2.jdbc是一个规范，提供了一整套接口。通过JDBC API，用Java语言编写的应用程序能够执行SQL语句、获取结果、显示数据等，并且可以将所做的修改传回数据库</p>
<p>3.通过jdbc与数据库建立连接，发送sql语句，处理sql语句执行的结果</p>
<p>4.访问MySQL数据库需要使用MySQL JDBC驱动程序</p>
<p>5.JDBC API主要位于Java的java.sql包与javax.sql包中</p>
<h3 id="二、建立jdbc连接："><a href="#二、建立jdbc连接：" class="headerlink" title="二、建立jdbc连接："></a>二、建立jdbc连接：</h3><p>1.建立jdbc连接的步骤：</p>
<p>（1）导入jdbc包</p>
<p>（2）注册jdbc驱动程序</p>
<p>（3）数据库url配置</p>
<p>（4）创建连接对象</p>
<p>2.使用java开发数据库应用需要用到的四个接口：</p>
<p>Driver、Connection、Statement和ResultSet</p>
<p>3.使用jdbc访问数据库的一般步骤：</p>
<p>加载驱动程序、建立数据库连接、创建执行方式语句、执行sql语句、处理返回结果和关闭创建的各种对象</p>
<p>4.jdbc中的三种sql查询方式：不含参数的静态查询、含有参数的动态查询和存储过程调用。分别对应Statement、PreparedStatement和CallableStatement接口</p>
<p>5.通过Statement接口实现静态sql查询、通过PreparedStatement接口实现动态SQL查询、通过CallableStatement接口实现存储过程的调用</p>
<p>6.通过DatebaseMentData接口获得关于数据库的信息，通过ResultSetMetaData接口获取结果集的结构</p>
<p>7.通过ResultSet返回查询结果集，并使用记录指针对其记录进行定位</p>
<p>8.可以使用setAutoCommit（）方法控制事物提交的方式，使用rollback（）方法实现事物回滚</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录3</title>
    <url>/2023/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h3 id="一、计算机硬件的主要技术指标："><a href="#一、计算机硬件的主要技术指标：" class="headerlink" title="一、计算机硬件的主要技术指标："></a>一、计算机硬件的主要技术指标：</h3><p>1.机器字长：CPU一次能够处理数据的位数，与CPU中的寄存器位数有关</p>
<p>2.运算速度：</p>
<p><a href="https://imgse.com/i/ppJfD6s"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfD6s.png"
                      alt="ppJfD6s.png"
                ></a></p>
<p>3.存储容量：存放二进制信息的总位数</p>
<p><a href="https://imgse.com/i/ppJf5c9"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJf5c9.png"
                      alt="ppJf5c9.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录4</title>
    <url>/2023/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h3 id="一、计算机的产生和发展："><a href="#一、计算机的产生和发展：" class="headerlink" title="一、计算机的产生和发展："></a>一、计算机的产生和发展：</h3><p>1.1946年，美国ENIAC</p>
<p><a href="https://imgse.com/i/ppJocJf"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJocJf.png"
                      alt="ppJocJf.png"
                ></a></p>
<p>2.现代计算机产生的驱动：需求、技术发展</p>
<p>3.微型计算机的出现和发展：</p>
<p>inter公司为代表</p>
<p>4.摩尔定律:集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍 </p>
<p>5.软件技术的兴起和发展:</p>
<p>机器语言——-面向机器</p>
<p>汇编语言——-面向机器</p>
<p>高级语言——-面向问题</p>
<p>6.软件发展的特点：</p>
<p>（1）开发周期长</p>
<p>（2）制作成本昂贵</p>
<p>（3）检测软甲产品质量的特殊性</p>
<h3 id="二、计算机的应用和展望"><a href="#二、计算机的应用和展望" class="headerlink" title="二、计算机的应用和展望"></a>二、计算机的应用和展望</h3><p>1.科学计算和数据处理</p>
<p>2.工业控制和实时控制</p>
<p>3.网络技术：</p>
<p>（1）电子商务</p>
<p>（2）网络教育</p>
<p>（3）敏捷制造</p>
<p>4.虚拟现实</p>
<p>5.办公自动化和管理信息系统</p>
<p>6.CAD、CAM、CIMS</p>
<p>7.多媒体技术</p>
<p>8.人工智能</p>
<p>9.未来计算机的发展：</p>
<p>（1）光计算机</p>
<p>（2）DNA生物计算机</p>
<p>（3）量子计算机</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录5</title>
    <url>/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</url>
    <content><![CDATA[<h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><h3 id="一、总线的基本概念"><a href="#一、总线的基本概念" class="headerlink" title="一、总线的基本概念"></a>一、总线的基本概念</h3><p>1.总线是连接各个部件的信息传输线，是各个部件共享的传输介质</p>
<p>2.总线上信息的传送：</p>
<p>串行、并行</p>
<p>3.单总线</p>
<p><a href="https://imgse.com/i/ppJoGIx"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJoGIx.png"
                      alt="ppJoGIx.png"
                ></a></p>
<p>4.面向CPU的双总线结构</p>
<p><a href="https://imgse.com/i/ppJordI"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJordI.png"
                      alt="ppJordI.png"
                ></a></p>
<p>5.以存储器为中心的双总线结构</p>
<p><a href="https://imgse.com/i/ppYSZn0"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYSZn0.png"
                      alt="ppYSZn0.png"
                ></a></p>
<h3 id="二、总线的分类"><a href="#二、总线的分类" class="headerlink" title="二、总线的分类"></a>二、总线的分类</h3><p>1.片内总线</p>
<p>2.系统总线：计算机各部件之间的信息传输线</p>
<p><a href="https://imgse.com/i/ppYSEXq"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYSEXq.png"
                      alt="ppYSEXq.png"
                ></a></p>
<p>3.通信总线：用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信等）之间的通信</p>
<p>传输方式：串行通信总线、并行通信总线</p>
<h3 id="三、总线的特性和性能指标"><a href="#三、总线的特性和性能指标" class="headerlink" title="三、总线的特性和性能指标"></a>三、总线的特性和性能指标</h3><p>1.机械特性：尺寸、形状、管脚数及排列顺序</p>
<p>2.电气特性：传输方向和有效的电平范围</p>
<p>3.功能特性：</p>
<p>每根传输线的功能：地址、数据、控制</p>
<p>4.时间特性：信号的时序关系</p>
<p>5.性能指标：</p>
<p>（1）总线宽度</p>
<p>（2）标准传输率：每秒传输的最大字节数（MBps）</p>
<p>（3）时钟同步&#x2F;异步</p>
<p>（4）总线复用</p>
<p>（5）信号线数</p>
<p>（6）总线控制方式</p>
<p>（7）其他的指标：负载能力</p>
<p>6.总线的标准：ISA、EISA、VESA、PCI、AGP、RS-232、USB</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录6</title>
    <url>/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956/</url>
    <content><![CDATA[<h1 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h1><h3 id="一、多总线结构"><a href="#一、多总线结构" class="headerlink" title="一、多总线结构"></a>一、多总线结构</h3><p>1.双总线结构</p>
<p>通道：具有特殊功能的处理器，由通道对I&#x2F;O统一管理</p>
<p>2.三总线结构：</p>
<p><a href="https://imgse.com/i/ppJoNRO"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJoNRO.png"
                      alt="ppJoNRO.png"
                ></a></p>
<p>3.三总线结构的另一种形式：</p>
<p><a href="https://imgse.com/i/ppJo0Ld"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJo0Ld.png"
                      alt="ppJo0Ld.png"
                ></a></p>
<p>4.四总线结构：</p>
<p><a href="https://imgse.com/i/ppYSm7T"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYSm7T.png"
                      alt="ppYSm7T.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习记录3</title>
    <url>/2023/02/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="自然语言处理学习记录"><a href="#自然语言处理学习记录" class="headerlink" title="自然语言处理学习记录"></a>自然语言处理学习记录</h1><h3 id="一、自然语言处理（NLP）概述"><a href="#一、自然语言处理（NLP）概述" class="headerlink" title="一、自然语言处理（NLP）概述"></a>一、自然语言处理（NLP）概述</h3><p>1.自然语言处理是计算机科学和人工智能的一个研究领域，它关注自然语言的处理。这种处理通常包括将自然语言转换成计算机能够用于理解这个世界的数据（数字）。同时，这种对世界的理解有时被用于生成能够体现这种理解的自然语言文本（自然语言生成）</p>
<p>2.正则表达式使用了一类特殊的称为正则语法的形式语言语法</p>
<p>3.有限状态机：FSM</p>
<p>4.自然语言处理的应用：</p>
<p>自动文摘、情感分析、信心提取、关系提取、聊天机器人、社交媒体分析、个人语音助理、语法检查5.语料库：语料库是存储在计算机上，用于研究语言是如何使用的书面或口头的自然语言材料集合。更准确地说，语料库是用于语言分析和语料分析的系统化和计算机化的真实语言集合。</p>
<p>6.语料分析可以被定义为一种以真实上下文和交际语境为基础的，深入研究语言概念的方法</p>
<p>7.为nlp应用准备数据集的基本步骤：</p>
<p>（1）挑选数据</p>
<p>（2）预处理数据</p>
<p>（3）转换数据</p>
<p>8.自然语言处理中最常见的文本预处理技术：</p>
<p>（1）大小写转换</p>
<p>（2）去噪</p>
<p>（3）文本规范化：常用的方法是字典映射</p>
<p>（4）词干提取：在语料库上执行词干提取以将词语减少到词干或词根形式</p>
<p>（5）词形还原：在语料库上执行词干提取以将词语减少到词干或词根形式</p>
<p>（6）标记化：在语料库上执行词干提取以将词语减少到词干或词根形式</p>
<p>（7）删除停止词</p>
<p>9.词嵌入：是文本实值向量形式的数值表示。具有相似含义的词映射到相似的向量，因此具有相似的表示</p>
<p>10.自然语言处理的关键作用是将预处理的文本数据转换为数值数据，数值数据是文本数据的数字表示</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习记录4</title>
    <url>/2023/02/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h1 id="自然语言处理学习记录"><a href="#自然语言处理学习记录" class="headerlink" title="自然语言处理学习记录"></a>自然语言处理学习记录</h1><h3 id="一、nlp的组成："><a href="#一、nlp的组成：" class="headerlink" title="一、nlp的组成："></a>一、nlp的组成：</h3><p>1.自然语言理解（NLU）：nlp的第一个任务</p>
<p>2.nlu需要利用下列的分析把自然语言转换成合理的表示：</p>
<p>形态分析、词法分析、句法分析、语义分析、消歧、篇章整合、语用分析</p>
<p>3.自然语言生成（NLG）：nlp的第二个任务</p>
<p>使用计算机来生成自然语言的过程</p>
<h3 id="二、上下文无关文法："><a href="#二、上下文无关文法：" class="headerlink" title="二、上下文无关文法："></a>二、上下文无关文法：</h3><p>1.在nlu中，上下文无关文法的定义主要包括四个主要的组成部分：</p>
<p>（1）一个非终结符集合N</p>
<p>（2）一个终结符集合T</p>
<p>（3）一个开始符S，S也是一个非终结符</p>
<p>（4）一个产生规则集合P，用来生成句子</p>
<h3 id="三、形态分析："><a href="#三、形态分析：" class="headerlink" title="三、形态分析："></a>三、形态分析：</h3><p>1.形态学是语言学的一个分支，主要研究词语是怎样被构造和生成的</p>
<p>2.词素：语言学中，词素是给定语言的最小意义单元，词素是形态学的基本单元</p>
<p>3.词干：词干是词的一部分，可以允许一个词缀附在上面</p>
<p>4.形态分析被定义为语法层面上的分析任务，它分析词是怎么由词素构成的，以及哪些是语义构成的最小单元</p>
<p>5.形态分析被用来分词、词性标注</p>
<p>6.自由词素：自由词素可以独立存在并充当一个词。它也被称为无边界词素或独立词素</p>
<p>7、边界词素：边界词素通常带有词缀，它们被进一步分为两类—-屈折词素</p>
<h3 id="四、词法分析："><a href="#四、词法分析：" class="headerlink" title="四、词法分析："></a>四、词法分析：</h3><p>1词法分析：把一段文本分割成词、短语和其他意义单元的过程</p>
<p>2.词条：词条被定义为词法分析过程中得到的有意义元素</p>
<p>3.词性：指一类词或是词法项具有相似的语法属性。具有相同词性的词在句子的语法结构中具有相似的行为</p>
<p>4.词条化：指一类词或是词法项具有相似的语法属性。具有相同词性的词在句子的语法结构中具有相似的行为</p>
<h3 id="五、句法分析："><a href="#五、句法分析：" class="headerlink" title="五、句法分析："></a>五、句法分析：</h3><p>1.句法分析是指给定句子或句子片段来做逻辑意义分析的过程。也要考虑语法规则来定义句子的逻辑意义和句子的正确程度	</p>
<h3 id="六、语义分析："><a href="#六、语义分析：" class="headerlink" title="六、语义分析："></a>六、语义分析：</h3><p>1.语义分析：生成自然语言语义的表示</p>
<p>2.词汇语义：包括词、字词、子单元、复合词、短语</p>
<p>3.上下位关系：描述一个泛化的项和其具体的实例之间的关系，这个泛化的项被称为上位词。泛化项的具体实例被称为下位词</p>
<p>4.同形异义词：指具有相同结构、拼写或形式，但具有不同语义且彼此相互无关的一些词</p>
<p>5.多义性：指一个词或是短语具有不同但相关的意义</p>
<h3 id="七、消歧："><a href="#七、消歧：" class="headerlink" title="七、消歧："></a>七、消歧：</h3><p>1.歧义的类型有：词法歧义、句法歧义、语义歧义、语用歧义</p>
<h3 id="八、篇章整合："><a href="#八、篇章整合：" class="headerlink" title="八、篇章整合："></a>八、篇章整合：</h3><p>1.篇章整合：小部分的自然语言结构所处的大环境</p>
<h3 id="九、语用分析："><a href="#九、语用分析：" class="headerlink" title="九、语用分析："></a>九、语用分析：</h3><p>1.语用分析处理外部的词汇知识</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习记录6</title>
    <url>/2023/02/13/java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956/</url>
    <content><![CDATA[<h1 id="java中的异常机制"><a href="#java中的异常机制" class="headerlink" title="java中的异常机制"></a>java中的异常机制</h1><h3 id="一、异常的定义："><a href="#一、异常的定义：" class="headerlink" title="一、异常的定义："></a>一、异常的定义：</h3><p>1.操作的过程中可能有很多出错的情况，出错的原因可能是多方面的。非正常的情况在java中统一被认为是异常，java使用异常机制来统一处理</p>
<p>2.异常是相对于return的一种退出机制，可以由系统触发，也可以由程序通过throw语句触发，异常可以通过try&#x2F;catch语句进行捕获并处理，如果没有捕获，则会导致程序退出并输出异常栈信息</p>
<h3 id="二、异常类的体系："><a href="#二、异常类的体系：" class="headerlink" title="二、异常类的体系："></a>二、异常类的体系：</h3><p>1.以Throwable为根，Java定义了非常多的异常类，表示各种类型的异常</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://mystorage9.oss-cn-hangzhou.aliyuncs.com/img/%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84%E4%BD%93%E7%B3%BB.png"
                     
                ></p>
<p>2.除了Java API中定义的异常类，也可以自己定义异常类，一般是继承Exception或者它的某个子类</p>
<h3 id="三、异常的处理："><a href="#三、异常的处理：" class="headerlink" title="三、异常的处理："></a>三、异常的处理：</h3><p>1.java中对异常的处理有：catch、throw、finally、try-with-resources和throws</p>
<p>2.catch可以有很多个，每一个对应一种异常类型。异常处理机制将根据抛出的异常类型找第一个匹配的catch块，找到后，执行catch块内的代码，不再执行其他catch块，如果没有找到，会继续到上层方法中查找</p>
<p>3.在catch块内处理完后，可以重新抛出异常，异常可以是原来的，也可以是新建的</p>
<p>4.异常机制中还有一个重要的部分，就是finally。catch后面可以跟finally语句。finally内的代码不管有无异常发生，都会执行</p>
<p>5.异常机制中，还有一个和throw很像的关键字throws，用于声明一个方法可能抛出的异常。throws跟在方法的括号后面，可以声明多个异常，以逗号分隔。这个声明的含义是，这个方法内可能抛出这些异常，且没有对这些异常进行处理，至少没有处理完，调用者必须进行处理</p>
<p>6.无论是受检异常还是未受检异常，无论是否出现在throws声明中，都应该在合适的地方以适当的方式进行处理</p>
<p>7.真正出现异常的时候，应该抛出异常，而不是返回特殊值</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录7</title>
    <url>/2023/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%957/</url>
    <content><![CDATA[<h1 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h1><h3 id="一、总线的判优控制："><a href="#一、总线的判优控制：" class="headerlink" title="一、总线的判优控制："></a>一、总线的判优控制：</h3><p>1.主设备：对总线有控制权</p>
<p>2.从设备：响应从主设备发来的总线命令</p>
<p>3.<a href="https://imgse.com/i/ppJf600"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJf600.png"
                      alt="ppJf600.png"
                ></a></p>
<p>4.链式查询：</p>
<p><a href="https://imgse.com/i/ppJotJK"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJotJK.png"
                      alt="ppJotJK.png"
                ></a></p>
<p>5.计数器定时查询：</p>
<p><a href="https://imgse.com/i/ppJo6FP"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJo6FP.png"
                      alt="ppJo6FP.png"
                ></a></p>
<p>6.独立请求：</p>
<p><a href="https://imgse.com/i/ppJo3ZR"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJo3ZR.png"
                      alt="ppJo3ZR.png"
                ></a></p>
<h3 id="二、总线通信控制："><a href="#二、总线通信控制：" class="headerlink" title="二、总线通信控制："></a>二、总线通信控制：</h3><p>1.目的：解决通信双方协调配合的问题</p>
<p>2.总线传输周期：</p>
<p><a href="https://imgse.com/i/ppJf2kT"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJf2kT.png"
                      alt="ppJf2kT.png"
                ></a></p>
<p>3.总线通信的四种方式：</p>
<p>（1）同步通信：由统一时标控制数据穿送</p>
<p>（2）异步通信：采用应答方式，没有公共时钟标准</p>
<p>（3）半同步通信：同步、异步结合</p>
<p>（4）分离式通信：充分挖掘系统总线每个瞬间的潜力</p>
<p>4.同步：发送方用时钟前沿发信号、接收方用系统时钟后沿判断、识别</p>
<p>5.异步：允许不同速度的模块和谐工作，增加一条等待响应信号（wait信号）</p>
<p>6.一个总线传输周期（以输入数据为例）：</p>
<p>（1）主模块发地址、命令  （占用总线）</p>
<p>（2）从模块准备数据    （不占用总线，总线空闲）</p>
<p>（3）从模块向主模块发送数据    （占用总线）</p>
<p>7.分离式通信：</p>
<p><a href="https://imgse.com/i/ppJo8d1"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJo8d1.png"
                      alt="ppJo8d1.png"
                ></a></p>
<p>8.分离通信的特点：</p>
<p>（1）各模块有权申请占用总线</p>
<p>（2）采用同步方式通信，不等对方回答</p>
<p>（3）各模块准备数据时，不占用总线</p>
<p>（4）总线被占用时，无空闲</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录8</title>
    <url>/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%958/</url>
    <content><![CDATA[<h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><h3 id="一、存储器的概述"><a href="#一、存储器的概述" class="headerlink" title="一、存储器的概述"></a>一、存储器的概述</h3><p>1.存储器的分类：</p>
<p>（1）按存储介质分类：</p>
<p>半导体存储器、TTL、MOS</p>
<p>磁表面存储器、磁头、磁载体</p>
<p>磁芯存储器、硬磁材料、环状元件</p>
<p>光盘存储器、激光、磁光材料</p>
<p>后面三种的数据不易失</p>
<p>（2）按存取方式分类：</p>
<p>随机存储器    在程序执行的过程中可读可写</p>
<p>只读存储器    在程序执行的过程中只读</p>
<p>上面两种的存取时间与物理地址无关（随机访问）</p>
<p>顺序存取存储器   磁带</p>
<p>直接存取存储器   磁盘</p>
<p>上面两种的存取时间与区里地址有关（串行访问）</p>
<p>（3）按在计算机中的作用分类：</p>
<p><a href="https://imgse.com/i/ppJfWhF"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfWhF.png"
                      alt="ppJfWhF.png"
                ></a></p>
<h3 id="二、存储器的层次结构"><a href="#二、存储器的层次结构" class="headerlink" title="二、存储器的层次结构"></a>二、存储器的层次结构</h3><p>1.<a href="https://imgse.com/i/ppJfhp4"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfhp4.png"
                      alt="ppJfhp4.png"
                ></a></p>
<p>2.缓存-主存层次和主存-辅存层次：</p>
<p><a href="https://imgse.com/i/ppJoDeA"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJoDeA.png"
                      alt="ppJoDeA.png"
                ></a></p>
<p>3.缓存-主存（速度）：主存储器、实地址、物理地址</p>
<p>4.主存-辅存（容量）：虚拟存储器、虚地址、逻辑地址</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录9</title>
    <url>/2023/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%959/</url>
    <content><![CDATA[<h1 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h1><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>1.主存储器的基本组成：</p>
<p><a href="https://imgse.com/i/ppJfBlj"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfBlj.png"
                      alt="ppJfBlj.png"
                ></a></p>
<p>2.主存和CPU的联系：</p>
<p><a href="https://imgse.com/i/ppJfymq"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfymq.png"
                      alt="ppJfymq.png"
                ></a></p>
<p>3.主存储器中存储单元地址的分配：</p>
<p>12345678H在存储器中的存储</p>
<p>（1）高位字节地址为字地址 、大端大尾方式</p>
<p><a href="https://imgse.com/i/ppJf41J"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJf41J.png"
                      alt="ppJf41J.png"
                ></a></p>
<p>（2）低位字节地址为字地址、小端、小尾方式</p>
<p><a href="https://imgse.com/i/ppYSeBV"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYSeBV.png"
                      alt="ppYSeBV.png"
                ></a></p>
<p>（3）一个字四个字节</p>
<p>假设地址线有24根，按字节寻址 2的24次方&#x3D;16MB</p>
<p>若字长为16位，按字寻址，得到8MW</p>
<p>若字长为32位，按字寻址，得到4MW</p>
<p>4.主存的技术指标：</p>
<p>（1）存储容量：主存存放二进制代码的总位数</p>
<p>（2）存储速度：</p>
<p>存取时间：存储器的访问时间、读出时间、访问时间</p>
<p>存取周期：连续两次独立的存储器操作（读或写）所需要的最小间隔时间</p>
<p>（3）存储器的带宽  位&#x2F;秒</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习记录5</title>
    <url>/2023/02/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</url>
    <content><![CDATA[<h1 id="Tensorflow2学习记录1"><a href="#Tensorflow2学习记录1" class="headerlink" title="Tensorflow2学习记录1"></a>Tensorflow2学习记录1</h1><h3 id="一、Tensorflow的建模流程"><a href="#一、Tensorflow的建模流程" class="headerlink" title="一、Tensorflow的建模流程"></a>一、Tensorflow的建模流程</h3><p>1.准备数据</p>
<p>数据的类型一般有结构化数据、图片数据、文本数据、时间序列数据</p>
<p>2.定义模型</p>
<p>3.训练模型</p>
<p>4.评估模型</p>
<p>5.使用模型</p>
<p>6.保存模型 </p>
<p>将模型打包导出为统一的格式，方便迁移和部署</p>
<p>后续的模型部署也是我们应该关心的，比如在服务器上进行部署、在移动端和嵌入式设备上进行部署、在网页端部署等等</p>
<h3 id="二、Tensorflow的核心概念"><a href="#二、Tensorflow的核心概念" class="headerlink" title="二、Tensorflow的核心概念"></a>二、Tensorflow的核心概念</h3><p>1.tensorflow是一个采用数据流图，用于数值计算的开源软件库</p>
<p>2.tensorflow底层的核心概念是张量，计算图和自动微分</p>
<p>3.张量</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tf.constant()    <span class="comment"># 定义一个常量</span></span><br><span class="line">tf.tensor()      <span class="comment"># 定义一个张量</span></span><br><span class="line">tf.Variable()    <span class="comment"># 定义一个变量</span></span><br></pre></td></tr></table></figure></div>

<p>4.在tensorflow2中使用动态计算图和自动微分</p>
<p>5.可以说，tensorflow2是新的架构、新的开始</p>
<h3 id="三、Tensorflow2的层次结构"><a href="#三、Tensorflow2的层次结构" class="headerlink" title="三、Tensorflow2的层次结构"></a>三、Tensorflow2的层次结构</h3><p>1.这里将tensorflow2分为5个层次结构：硬件层、内核层、低阶API、中阶API、高阶API</p>
<p>2.在之后的学习中将会重点学习低阶API、中阶API、高阶API</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习记录1</title>
    <url>/2023/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="一、监听模式"><a href="#一、监听模式" class="headerlink" title="一、监听模式"></a>一、监听模式</h3><p>1.监听模式是一种一对多的关系，可以有任意个（一个或多个）观察者对象同时监听某一个对象</p>
<p>2.监听模式中可以分为观察者和被观察者</p>
<p>3.监听模式的核心思想就是在被观察者与观察者之间建立一种自动触发的关系</p>
<p>4.设计方案：Observable是被观察者的抽象类，Observer是观察者的抽象类</p>
<p>5.监听模式根据侧重的功能可以分为推模型和拉模型：</p>
<p>（1）推模型：被观察者对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据</p>
<p>（2）拉模型：被观察者在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到被观察者对象中获取，相当于观察者从被观察者对象中拉数据</p>
<h3 id="二、状态模式"><a href="#二、状态模式" class="headerlink" title="二、状态模式"></a>二、状态模式</h3><p>1.状态模式是说一个对象在其内部状态发生改变时，其外表的行为和外在属性不一样，看上去就像改变了它的类型一样</p>
<p>2.状态模式的优缺点：</p>
<p>（1）优点：封装了状态的转换规则，在状态模式中可以将状态的转换代码封装到环境类中；</p>
<p>允许状态转换逻辑与状态对象合为一体</p>
<p>（2）缺点：会增加系统类和对象的个数；结构较为复杂，使用不当会导致程序的混乱</p>
<p>最近在看人人都懂设计模式这本书，就对学习的内容做一个记录吧</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习记录6</title>
    <url>/2023/02/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956/</url>
    <content><![CDATA[<h1 id="自然语言处理学习记录"><a href="#自然语言处理学习记录" class="headerlink" title="自然语言处理学习记录"></a>自然语言处理学习记录</h1><h3 id="一、预处理"><a href="#一、预处理" class="headerlink" title="一、预处理"></a>一、预处理</h3><p>1.处理原始的语料数据：</p>
<p>可以从三种资源获取原始的文本数据：原始文本文件、用脚本定义局部变量定义原始的语料文本、从nltk获取语料库</p>
<p>2.词形还原是识别正确的词性和句子中出现的单词的含义的过程</p>
<p>3.处理原始语料库的句子：</p>
<p>词条化是将一段文字切成单词、句子和有意义的短语的过程。它的输出是单词，也叫作词条</p>
<h3 id="二、特征工程与NLP算法"><a href="#二、特征工程与NLP算法" class="headerlink" title="二、特征工程与NLP算法"></a>二、特征工程与NLP算法</h3><p>1.特征是机器学习算法的输入参数，算法基于这些输入生成输出</p>
<p>2.在nlp中，特征工程是从原始数据或语料中生成用于开发nlp应用或解决nlp相关问题的特征的过程</p>
<p>3.特征工程的重点是特征的选择</p>
<p>4.通过进行句法，可以得到几乎所有重要的nlp特征</p>
<p>5.句法分析器的结果通常表示为一个句法分析树或抽象语法树，它们通过文法规则生成。句法分析器工具按照文法规则执行句法分析过程并生成句法树</p>
<p>6.词性标注：</p>
<p>词性标注被定义为对语料库中的单词标注其在参与部分中的词性的过程</p>
<p>词性标注也被称为语法标注或词类消歧。单词的词性也依赖于它和所处短语、句子和段落中相邻的单词的关系</p>
<p>7.命名实体识别（NER）：</p>
<p>命名实体识别，又称作专名识别、命名实体，是指识别文本中具有特定意义的实体，主要包括人名、地名、机构名、专有名词等，以及时间、数量、货币、比例数值等文字 </p>
<p>8.TF-IDF：指词频-逆文档频率，它属于数值统计的范畴。使用TF-IDF，我们能够学习一个词对于数据集中的一个文档的重要性</p>
<p>9.向量化：是nlp领域提取的一个重要的方法，主要是将文本转换为向量形式。主要表现为是将每个词映射为一个整数</p>
<p>10.编码：使用one-hot编码</p>
<p>11.word2vec算法接收向量化的one-hot编码单词作为输入</p>
<p>12.规范化：文本规范化是将给定文本转换成单一规范形式的过程</p>
<p>13.概率模型：重要的一个概率模型是语言模型（LM）</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录10</title>
    <url>/2023/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9510/</url>
    <content><![CDATA[<h1 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h1><h3 id="一、半导体存储芯片的基本结构："><a href="#一、半导体存储芯片的基本结构：" class="headerlink" title="一、半导体存储芯片的基本结构："></a>一、半导体存储芯片的基本结构：</h3><p>1.<a href="https://imgse.com/i/ppJfc7V"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfc7V.png"
                      alt="ppJfc7V.png"
                ></a></p>
<p>2.半导体片选线</p>
<p><a href="https://imgse.com/i/ppJoYi6"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJoYi6.png"
                      alt="ppJoYi6.png"
                ></a></p>
<p>3.片选线的作用：使某一个或某些芯片同时工作</p>
<h3 id="二、半导体存储芯片的译码驱动方式："><a href="#二、半导体存储芯片的译码驱动方式：" class="headerlink" title="二、半导体存储芯片的译码驱动方式："></a>二、半导体存储芯片的译码驱动方式：</h3><p>1.线选法：对容量大的数据不适用</p>
<p>2.重合法：行、列地址分别进行译码，只能有一组是有效的</p>
<h3 id="三、随机存取存储器："><a href="#三、随机存取存储器：" class="headerlink" title="三、随机存取存储器："></a>三、随机存取存储器：</h3><p>1.静态RAM：</p>
<p>基本电路由触发器、开关等元件组成</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习记录2</title>
    <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>1.物理层—–数据链路层——–网络层——–传输层——-应用层</p>
<p>2.分层的优点：</p>
<p>（1）各层之间相互独立</p>
<p>（2）灵活性好</p>
<p>（3）结构上可以分开</p>
<p>（4）易于维护和实现</p>
<p>（5）能够促进标准化工作</p>
<p>3.协议：为网络中的数据交换建立的规则、标准或约定称之为协议</p>
<p>4.协议的组成：语法、语义、同步</p>
<p>5.常见的计算机网络协议：</p>
<p><a href="https://imgse.com/i/ppYpLLt"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYpLLt.png"
                      alt="ppYpLLt.png"
                ></a></p>
<p>6.协议是水平的、服务是垂直的</p>
<p>7.实体：任何可以发送或接收信息的硬件或软件进程</p>
<p>8.ICMP（互联网控制消息协议 ）：网络设备用来诊断网络通信问题的网络层协议 </p>
<p>9.数据通信：计算机网络最基本的功能，包括连接控制、传输控制、差错控制、流量控制、路由选择、多路复用等子功能</p>
<p>10.<a href="https://imgse.com/i/ppYpbQA"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYpbQA.png"
                      alt="ppYpbQA.png"
                ></a></p>
<p>11.<a href="https://imgse.com/i/ppYpXeP"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYpXeP.png"
                      alt="ppYpXeP.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录11</title>
    <url>/2023/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9511/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h3 id="查漏补缺1"><a href="#查漏补缺1" class="headerlink" title="查漏补缺1"></a>查漏补缺1</h3><p>1.冯诺依曼机器最根本的特征是采用“存储程序”的原理。基本工作方式是控制流驱动方式</p>
<p>2.冯诺依曼机工作方式的基本特点：按地址访问并顺序执行指令</p>
<p>3.软件和硬件具有逻辑上的等效性，硬件实现具有更高的执行速度，软件实现具有更好的灵活性，软件的功能可以由硬件实现</p>
<p>4.IR存放当前欲指行的指令，PC存放下一条指令的地址（跟踪下一条要执行的指令在主存储器的地址）</p>
<p>MAR用来存放欲访问的存储单元的地址，MDR存放从存储单元取来的数据</p>
<p>5.运算器的核心部件是ALU（算术逻辑运算单元），地址寄存器位于CPU，并没有集成到运算器和控制器中。内存和CPU之间存在操作速度上的差别</p>
<p>6.计算机只能从主存中取指令和操作数，不能直接与外存交换数据</p>
<p>7.编译程序是先完整编译后运行的程序，解释程序是一句一句翻译且边翻译边执行的程序</p>
<p>解释程序的速度比编译程序慢</p>
<p>8.由高级语言转换为汇编语言的过程称为编译，把汇编语言源代码翻译成机器语言程序的过程称为汇编</p>
<p>9.CPU有控制器和运算器两个部件组成，运算器和控制器中都含有寄存器。</p>
<p>存储器是一个独立部件</p>
<p>10.数据库系统是指在计算机系统引入数据库后的系统，一般由数据库、数据库管理系统、应用程序、数据库管理员构成，其中数据库管理系统是系统程序</p>
<p>11.相联存储器既可以按地址寻址又可以按内容（通常是某些字段）寻址，为与传统的存储器相区别，又称按内容寻址的寄存器</p>
<p>12.翻译程序把高级语言源程序转换为机器语言程序</p>
<p>13.汇编语言也是一种翻译程序</p>
<p>14.除了立即寻址以外，数据均存放在存储器中</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录12</title>
    <url>/2023/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9512/</url>
    <content><![CDATA[<h3 id="半导体存储芯片的译码驱动方式"><a href="#半导体存储芯片的译码驱动方式" class="headerlink" title="半导体存储芯片的译码驱动方式"></a>半导体存储芯片的译码驱动方式</h3><h3 id="一、线选法"><a href="#一、线选法" class="headerlink" title="一、线选法"></a>一、线选法</h3><p><a href="https://imgse.com/i/ppYSAcn"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYSAcn.png"
                      alt="ppYSAcn.png"
                ></a></p>
<h3 id="二、重合法"><a href="#二、重合法" class="headerlink" title="二、重合法"></a>二、重合法</h3><p>1.行译码</p>
<p>2.列译码</p>
<h3 id="随机存取存储器（RAM）"><a href="#随机存取存储器（RAM）" class="headerlink" title="随机存取存储器（RAM）"></a>随机存取存储器（RAM）</h3><p>一、静态RAM（SARM）</p>
<p><a href="https://imgse.com/i/ppJodQe"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJodQe.png"
                      alt="ppJodQe.png"
                ></a></p>
<p>T1~4是触发器；T5、T6是行开关；T7、T8是列开关；T7、T8一列共用；A是触发器的原端</p>
<p>二、动态RAM（DRAM）</p>
<p>读数据线、写数据线</p>
<p>1.读出与原信息相反，写入与输入信息相同</p>
<p>2.三管动态RAM芯片</p>
<p>3.单管动态RAM（4116）</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录13</title>
    <url>/2023/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9513/</url>
    <content><![CDATA[<h3 id="一、动态RAM的刷新"><a href="#一、动态RAM的刷新" class="headerlink" title="一、动态RAM的刷新"></a>一、动态RAM的刷新</h3><p>1.刷新与行地址有关</p>
<p>2.刷新的方法：</p>
<p>（1）集中式刷新（存取周期为0.5微秒）</p>
<p>（2）分散式刷新（存取周期为1微秒）</p>
<p>（3）异步刷新：分散式刷新和集中式刷新相结合、</p>
<p>将刷新安排在指令译码阶段</p>
<h3 id="二、动态RAM和静态RAM的比较"><a href="#二、动态RAM和静态RAM的比较" class="headerlink" title="二、动态RAM和静态RAM的比较"></a>二、动态RAM和静态RAM的比较</h3><p><a href="https://imgse.com/i/ppJoUzD"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJoUzD.png"
                      alt="ppJoUzD.png"
                ></a></p>
<h3 id="三、只读存储器（ROM）"><a href="#三、只读存储器（ROM）" class="headerlink" title="三、只读存储器（ROM）"></a>三、只读存储器（ROM）</h3><p>1.掩模ROM（MROM）</p>
<p>行列选择线交叉处有MOS管为“1“</p>
<p>行列选择线交叉处无MOS管为“0”</p>
<p>2.PROM（一次性编程）</p>
<p>熔丝断开为0</p>
<p>熔丝连接为1</p>
<p>3.EPROM（多次编程）</p>
<p>N型沟道浮动栅MOS电路</p>
<p>4.EEPROM（多次编程）</p>
<p>电可擦写</p>
<p>局部擦写</p>
<p>全部擦写</p>
<p>5.FLash Memory（闪速型存储器）</p>
<h3 id="四、存储器与CPU的连接"><a href="#四、存储器与CPU的连接" class="headerlink" title="四、存储器与CPU的连接"></a>四、存储器与CPU的连接</h3><p>1.存储器容量的扩展</p>
<p>（1）位扩展（增加存储字长）</p>
<p>（2）字扩展（增加存储字的数量）</p>
<p>（3）字、位扩展</p>
<p>2.连接方式：</p>
<p>（1）地址线的连接</p>
<p>（2）数据线的连接</p>
<p>（3）读&#x2F;写命令线的连接</p>
<p>（4）片选线的连接</p>
<p>（5）合理选择存储芯片</p>
<p>（6）其他、时序、负载</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习记录3</title>
    <url>/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><p>1.计算机网络已经由一种通信基础设施发展成为一种重要的信息服务基础设施</p>
<h1 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h1><h3 id="一、网络、互联网和因特网"><a href="#一、网络、互联网和因特网" class="headerlink" title="一、网络、互联网和因特网"></a>一、网络、互联网和因特网</h3><p>1.网络由若干结点和连接这些结点的链路组成。</p>
<p>2.多个网络通过互联网互连起来，即互联网</p>
<p>3.因特网是世界上最大的互连网络</p>
<h3 id="二、因特网发展的三个阶段"><a href="#二、因特网发展的三个阶段" class="headerlink" title="二、因特网发展的三个阶段"></a>二、因特网发展的三个阶段</h3><p>1.<a href="https://imgse.com/i/ppdh7ZQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/22/ppdh7ZQ.png"
                      alt="ppdh7ZQ.png"
                ></a></p>
<p>2.因特网服务提供者ISP</p>
<p>3.第一层ISP：因特网主干网</p>
<p>3.因特网制定标准的特点：面向公众</p>
<p>4.指定标准的四个阶段：</p>
<p>（1）因特网草案（还不是RFC文档）</p>
<p>（2）建议标准（这个阶段称为RFC文档）</p>
<p>（3）草案标准</p>
<p>（4）因特网标准</p>
<p>并非所有的RFC文档都是因特网标准</p>
<h3 id="三、因特网的组成："><a href="#三、因特网的组成：" class="headerlink" title="三、因特网的组成："></a>三、因特网的组成：</h3><p>边缘部分：由所有连接在因特网的主机组成，用户直接使用，用来进行通信</p>
<p>核心部分：由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录14</title>
    <url>/2023/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9514/</url>
    <content><![CDATA[<h3 id="一、存储器与CPU的连接"><a href="#一、存储器与CPU的连接" class="headerlink" title="一、存储器与CPU的连接"></a>一、存储器与CPU的连接</h3><p>（1）写出对应的二进制地址码</p>
<p>（2）确定芯片数量及类型</p>
<p>（3）分配地址线</p>
<p>（4）确定片选信号</p>
<p>（5）确定片选逻辑</p>
<h3 id="二、存储器的校验"><a href="#二、存储器的校验" class="headerlink" title="二、存储器的校验"></a>二、存储器的校验</h3><p>1.三倍冗余的代码可以检1位错，纠1位错</p>
<p>四倍冗余的代码可以检2位错，纠1位错</p>
<p>五倍冗余的代码可以检2位错，纠2位错</p>
<p>（集合中有两个合法代码）</p>
<p>2.编码的检测能力和纠错能力与任意两组合法代码之间二进制的最小差异数有关</p>
<p>3.编码的最小距离：任意两组合法代码之间二进制位数的最小差异</p>
<p>4.编码的检错能力、纠错能力与编码的最小距离有关</p>
<p><a href="https://imgse.com/i/ppaPQit"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/21/ppaPQit.png"
                      alt="ppaPQit.png"
                ></a></p>
<p>5.汉明码的组成：</p>
<p>汉明码采用奇偶校验，分组校验</p>
<p>6.汉明码是一种非划分的方式</p>
<p>7.<a href="https://imgse.com/i/ppaiMm4"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/21/ppaiMm4.png"
                      alt="ppaiMm4.png"
                ></a></p>
<p>8.汉明码检测位的取值：</p>
<p>检测位的取值与该位所在的检测“小组”承担的奇偶校验任务有关</p>
<p>9.各检测位Ci所承担的检测小组为</p>
<p><a href="https://imgse.com/i/ppaiQ0J"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/21/ppaiQ0J.png"
                      alt="ppaiQ0J.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录15</title>
    <url>/2023/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9515/</url>
    <content><![CDATA[<h1 id="调高主存的访问速度"><a href="#调高主存的访问速度" class="headerlink" title="调高主存的访问速度"></a>调高主存的访问速度</h1><p>1.采用高速的器件</p>
<p>2.采用层次结构：Cache-主存</p>
<p>3.调整主存结构</p>
<h3 id="一、单体多字系统"><a href="#一、单体多字系统" class="headerlink" title="一、单体多字系统"></a>一、单体多字系统</h3><p>1.<a href="https://imgse.com/i/ppBdBex"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/24/ppBdBex.png"
                      alt="ppBdBex.png"
                ></a></p>
<h3 id="二、多体并行系统"><a href="#二、多体并行系统" class="headerlink" title="二、多体并行系统"></a>二、多体并行系统</h3><p>1.高位交叉 顺序编址</p>
<p>2.多体并行系统是采用多体模块组成的存储器，各模块有独立的地址寄存器（MAR），数据寄存器（MDR）、地址译码、驱动电路和读&#x2F;写电路，它们可以并行工作，又能交叉工作</p>
<p>3.高位交叉编址的多体存储器：</p>
<p><a href="https://imgse.com/i/ppBdcfe"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/24/ppBdcfe.png"
                      alt="ppBdcfe.png"
                ></a></p>
<p>4.低位交叉，各个体轮流编址</p>
<p>低位交叉在不改变存取周期的前提下，增加存储器的带宽</p>
<p>5.<a href="https://imgse.com/i/ppBw9tU"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/24/ppBw9tU.png"
                      alt="ppBw9tU.png"
                ></a></p>
<p>6.高位交叉用于存储器容量的扩展，低位交叉用于存储器带宽和访问速度的提高</p>
<p>7.高性能存储芯片：</p>
<p>（1）SDRAM（同步DRAM）：在系统时钟控制下进行读出和写入，CPU无需等待</p>
<p>（2）RDRAM：主要解决存储器的带宽问题</p>
<p>（3）带cache的DRAM：在DRAM中集成了一个由SRAM组成的Cache，有利于猝发式读取</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录16</title>
    <url>/2023/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9516/</url>
    <content><![CDATA[<h1 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h1><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>1.使用cache的原因：</p>
<p><a href="https://imgse.com/i/pphcb5t"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/03/pphcb5t.png"
                      alt="pphcb5t.png"
                ></a></p>
<p>2.cache的工作原理：</p>
<p><a href="https://imgse.com/i/pphcLPP"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/03/pphcLPP.png"
                      alt="pphcLPP.png"
                ></a></p>
<p>主存和缓存按块存储，块的大小相同、</p>
<p>3.主存数量远远大于缓存</p>
<p>命中：主存块调入缓存，主存块和缓存块建立了对应关系</p>
<p>未命中：主存块未调入缓存，主存块和缓存块未建立对应关系</p>
<p>用标记记录与某缓存块建立了对应关系的主存块号</p>
<p>4.cache的命中率：</p>
<p>CPU欲访问的信息在cache中的比率</p>
<p>5.命中率和cache的容量与块长有关</p>
<p>6.一般的cache块的大小取4~8个字</p>
<p>7.块长取一个存取周期从主存调出的信息长度</p>
<p>8.块的大小和多体交叉有关</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录17</title>
    <url>/2023/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9517/</url>
    <content><![CDATA[<h1 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h1><h3 id="一、主存系统的效率："><a href="#一、主存系统的效率：" class="headerlink" title="一、主存系统的效率："></a>一、主存系统的效率：</h3><p>1.效率e与命中率有关</p>
<p><a href="https://imgse.com/i/ppjEqYQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/12/ppjEqYQ.png"
                      alt="ppjEqYQ.png"
                ></a></p>
<p><a href="https://imgse.com/i/ppjELWj"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/12/ppjELWj.png"
                      alt="ppjELWj.png"
                ></a></p>
<p>2.访问cache和访问内存是同时进行的</p>
<h3 id="二、cache的基本结构："><a href="#二、cache的基本结构：" class="headerlink" title="二、cache的基本结构："></a>二、cache的基本结构：</h3><p>1.<a href="https://imgse.com/i/ppjEXSs"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/12/ppjEXSs.png"
                      alt="ppjEXSs.png"
                ></a></p>
<h3 id="三、cache的读写操作："><a href="#三、cache的读写操作：" class="headerlink" title="三、cache的读写操作："></a>三、cache的读写操作：</h3><p>1.读操作：当CPU发出主存的地址后，首先判断该存储字是否在cache中，若命中，直接访问cache，将该字送至CPU中，若未命中，一方面要访问主存，将该字传送给CPU，与此同时，要将该字所在的主存块装入cache中，如果此时cache已经装满，就要执行替换算法，腾出空位	才将新的主存块调入</p>
<p>2.写操作：</p>
<p>写直达法</p>
<p>写回法</p>
<h3 id="四、cache的改进："><a href="#四、cache的改进：" class="headerlink" title="四、cache的改进："></a>四、cache的改进：</h3><p>1.增加cache的级数：</p>
<p>片载cache</p>
<p>片外cache</p>
<p>2.统一缓存和分立缓存</p>
<p>统一缓存是指指令和数据都存放在同一缓存内的cache中，分立缓存是指指令和数据分别存放在两个缓存中，一个称为指令cache，一个称为数据cache</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录18</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9518/</url>
    <content><![CDATA[<h1 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h1><h3 id="一、cache-主存的地址映射："><a href="#一、cache-主存的地址映射：" class="headerlink" title="一、cache-主存的地址映射："></a>一、cache-主存的地址映射：</h3><p>1.直接映射：</p>
<p><a href="https://imgse.com/i/ppxafe0"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppxafe0.png"
                      alt="ppxafe0.png"
                ></a></p>
<p>每个缓存块i可以和若干个主存块对应</p>
<p>每个主存块j只能和一个缓存块对应</p>
<p>2.全相联映射：</p>
<p><a href="https://imgse.com/i/ppxa2yn"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppxa2yn.png"
                      alt="ppxa2yn.png"
                ></a></p>
<p>3.组相联映射：</p>
<p><a href="https://imgse.com/i/ppxaRLq"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppxaRLq.png"
                      alt="ppxaRLq.png"
                ></a></p>
<p>某一主存块j按模Q映射到缓存的第i组中的任一块</p>
<h3 id="二、替换算法："><a href="#二、替换算法：" class="headerlink" title="二、替换算法："></a>二、替换算法：</h3><p>1.先进先出（FIFO算法）</p>
<p>2.近期最少使用（LRU）算法</p>
<h3 id="三、总结："><a href="#三、总结：" class="headerlink" title="三、总结："></a>三、总结：</h3><p>1.直接：某一主存块只能固定映射到某一缓存块（不灵活）</p>
<p>2.全相联：某一主存块能映射到任一缓存块（成本高）</p>
<p>3.组相联：某一主存块只能映射到某一缓存组中的任一缓存块（直接映射和全相联映射的折中）</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录19</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9519/</url>
    <content><![CDATA[<h1 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h1><h3 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h3><p>1.特点：不直接与cpu交换信息</p>
<p>2.磁表面存储器的技术指标：</p>
<p>（1）记录密度、  道密度 、位密度</p>
<p>（2）存储容量</p>
<p>（3）平均寻址时间  寻道时间 + 等待时间</p>
<p>辅存的速度：</p>
<p>寻址时间</p>
<p>磁头读写时间</p>
<p>（4）数据传输率</p>
<p>（5）误码率</p>
<h3 id="二、磁记录的原理和方式："><a href="#二、磁记录的原理和方式：" class="headerlink" title="二、磁记录的原理和方式："></a>二、磁记录的原理和方式：</h3><p>1.写</p>
<p><a href="https://imgse.com/i/ppx0cSe"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppx0cSe.png"
                      alt="ppx0cSe.png"
                ></a></p>
<p>2.读</p>
<p><a href="https://imgse.com/i/ppx0ROA"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppx0ROA.png"
                      alt="ppx0ROA.png"
                ></a></p>
<h3 id="三、硬磁盘存储器："><a href="#三、硬磁盘存储器：" class="headerlink" title="三、硬磁盘存储器："></a>三、硬磁盘存储器：</h3><p>1.硬磁盘存储器的类型：</p>
<p>（1）固定磁头和移动磁头</p>
<p>（2）可换盘和固定盘</p>
<p>2.硬磁盘存储器的结构：</p>
<p><a href="https://imgse.com/i/ppx0gQH"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppx0gQH.png"
                      alt="ppx0gQH.png"
                ></a></p>
<p>3.磁盘控制器：</p>
<p>（1）接受主机发来的命令，转换成磁盘驱动器的控制命令</p>
<p>（2）实现主机和驱动器之间的数据格式转换</p>
<p>（3）控制磁盘驱动器读写</p>
<p>（4）磁盘控制器是主机和磁盘驱动器之间的接口，对主机来说，通过总线连接，对硬盘直接进行控制</p>
<p>4.盘片：一般采用硬质铝合金材料制作</p>
<h3 id="四、软磁盘存储器："><a href="#四、软磁盘存储器：" class="headerlink" title="四、软磁盘存储器："></a>四、软磁盘存储器：</h3><p>1.软磁盘存储器和硬磁盘存储器的对比：</p>
<p><a href="https://imgse.com/i/ppx0feI"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppx0feI.png"
                      alt="ppx0feI.png"
                ></a></p>
<h3 id="五、光盘存储器："><a href="#五、光盘存储器：" class="headerlink" title="五、光盘存储器："></a>五、光盘存储器：</h3><p>1.采用光存储技术、利用激光写入和读出</p>
<p>2.<a href="https://imgse.com/i/ppx02yd"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppx02yd.png"
                      alt="ppx02yd.png"
                ></a></p>
<p>3.光盘的存储原理：</p>
<p>（1）只读型和只写一次型：热作用</p>
<p>（2）可擦写光盘：热磁效应</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录20</title>
    <url>/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9520/</url>
    <content><![CDATA[<h1 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h1><h3 id="一、输入输出系统的发展概述："><a href="#一、输入输出系统的发展概述：" class="headerlink" title="一、输入输出系统的发展概述："></a>一、输入输出系统的发展概述：</h3><p>1.早期：</p>
<p>分散连接、CPU和I&#x2F;O设备<strong>串行</strong>工作，采用程序查询方式</p>
<p>2.接口模块和DMA阶段：</p>
<p>总线连接</p>
<p>CPU和I&#x2F;O设备<strong>并行</strong>工作：中断方式</p>
<p>​					    DMA方式</p>
<p>3.具有通道结构的阶段：</p>
<p>通道可以看做一个处理器</p>
<p>4.具有I&#x2F;O处理机的阶段：</p>
<p>数据的输入输出系统逐渐的从CPU中独立出来</p>
<h3 id="二、输入输出系统的组成："><a href="#二、输入输出系统的组成：" class="headerlink" title="二、输入输出系统的组成："></a>二、输入输出系统的组成：</h3><p>1.I&#x2F;O软件：</p>
<p>（1）I&#x2F;O指令：CPU指令的一部分</p>
<p>（2）通道指令：通道自身的指令</p>
<p>通道指令要指出数组的首地址、传送字数、操作命令</p>
<p>通道可以执行通道指令</p>
<p>通道执行组成通道程序</p>
<p>2.I&#x2F;O硬件：</p>
<p>设备、I&#x2F;O接口</p>
<p>设备、设备控制器、通道</p>
<h3 id="三、I-x2F-O设备和主机的联系方式："><a href="#三、I-x2F-O设备和主机的联系方式：" class="headerlink" title="三、I&#x2F;O设备和主机的联系方式："></a>三、I&#x2F;O设备和主机的联系方式：</h3><p>1.I&#x2F;O设备编址方式：</p>
<p>（1）统一编址  用取数、存树指令</p>
<p>（2）不统一编址（单独编址）  有专门的I&#x2F;O指令</p>
<p>2.设备选址：用设备选择电路识别是否被选中</p>
<p>3.传送方式：</p>
<p>（1）串行</p>
<p>（2）并行</p>
<p>4.联络方式：</p>
<p>（1）立即响应</p>
<p>（2）异步工作采用应答信号</p>
<p><a href="https://imgse.com/i/p9pbMZ9"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/15/p9pbMZ9.png"
                      alt="p9pbMZ9.png"
                ></a></p>
<p>（3）同步工作采用同步时标</p>
<p>5.I&#x2F;O设备和主机的连接方式：</p>
<p>（1）辐射式连接：不便于增删设备	</p>
<p><a href="https://imgse.com/i/p9pbuqJ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/15/p9pbuqJ.png"
                      alt="p9pbuqJ.png"
                ></a></p>
<p>（2）总线连接：便于增删设备</p>
<h3 id="四、I-x2F-O设备和主机信息传送的控制方式："><a href="#四、I-x2F-O设备和主机信息传送的控制方式：" class="headerlink" title="四、I&#x2F;O设备和主机信息传送的控制方式："></a>四、I&#x2F;O设备和主机信息传送的控制方式：</h3><p>1.程序查询方式：</p>
<p>CPU和I&#x2F;O串行工作</p>
<p><a href="https://imgse.com/i/p9pbnr4"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/15/p9pbnr4.png"
                      alt="p9pbnr4.png"
                ></a></p>
<p>2.程序中断方式：</p>
<p>I&#x2F;O工作：自身的准备（CPU不查询）、与主机交换信息（CPU暂停现行程序）</p>
<p>CPU没有踏步等待现象</p>
<p>3.DMA方式：内存和I&#x2F;O通过DMA控制器进行交换</p>
<p>周期挪用（周期窃取）</p>
<p><a href="https://imgse.com/i/p9pbQaR"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/15/p9pbQaR.png"
                      alt="p9pbQaR.png"
                ></a></p>
<p>指令需要预取</p>
<p>CPU和I&#x2F;O并行工作</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录21</title>
    <url>/2023/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9521/</url>
    <content><![CDATA[<h1 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h1><h3 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h3><p>1.<a href="https://imgse.com/i/p99qdKO"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/16/p99qdKO.png"
                      alt="p99qdKO.png"
                ></a></p>
<h3 id="二、外部设备的分类："><a href="#二、外部设备的分类：" class="headerlink" title="二、外部设备的分类："></a>二、外部设备的分类：</h3><p>1.（1）人机交互设备   键盘、鼠标、打印机</p>
<p>  （2）计算机信息存储设备   磁盘、光盘</p>
<p>  （3）通信设备   调制解调器</p>
<p>2.输入设备：</p>
<p>（1）键盘：编码键盘法</p>
<p>（2）鼠标：机械式、光电式</p>
<p>（3）触摸屏</p>
<p>3.输出设备：</p>
<p>（1）显示器：字符显示（字符发生器）、图形显示（主观图像）、图像显示（客观图像）</p>
<p>（2）打印机：击打式（点阵式）、非击打式（激光打印机）</p>
<p>（3）其他：A&#x2F;D，D&#x2F;A 模数转换器、终端、汉字处理</p>
<p>4.多媒体技术</p>
<h1 id="I-x2F-O接口"><a href="#I-x2F-O接口" class="headerlink" title="I&#x2F;O接口"></a>I&#x2F;O接口</h1><h3 id="一、概述：-1"><a href="#一、概述：-1" class="headerlink" title="一、概述："></a>一、概述：</h3><p>1.为什么要设置接口：</p>
<p>（1）实现设备的选择</p>
<p>（2）实现数据缓冲达到速度匹配</p>
<p>（3）实现数据串—并格式转换</p>
<p>（4）实现电平转换</p>
<p>（5）传送控制命令</p>
<p>（6）反映设备的状态（”忙“、”就绪“、”中断请求“）</p>
<h3 id="二、接口的功能和组成："><a href="#二、接口的功能和组成：" class="headerlink" title="二、接口的功能和组成："></a>二、接口的功能和组成：</h3><p>1.总线：</p>
<p>（1）设备选择线</p>
<p>（2）数据线：双向</p>
<p>（3）命令线</p>
<p>（4）状态线：单向</p>
<p>2.功能：</p>
<p>（1）选址功能：设备选择电路</p>
<p>（2）传送命令的功能：命令寄存器、命令译码器</p>
<p>（3）传送数据的功能：数据缓冲寄存器</p>
<p>（4）反映设备状态的功能：设备状态标记</p>
<p><a href="https://imgse.com/i/p99qwrD"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/16/p99qwrD.png"
                      alt="p99qwrD.png"
                ></a></p>
<p>3.I&#x2F;O接口的基本组成：</p>
<p><a href="https://imgse.com/i/p99q0qe"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/16/p99q0qe.png"
                      alt="p99q0qe.png"
                ></a></p>
<h3 id="三、接口的类型："><a href="#三、接口的类型：" class="headerlink" title="三、接口的类型："></a>三、接口的类型：</h3><p>1.按照数据传送方式分类：</p>
<p>并行接口：Inter8255</p>
<p>串行接口：Inter8251</p>
<p>2.按照功能选择的灵活性分类：</p>
<p>可编程接口：Inter8255、Inter8251</p>
<p>不可编程接口：Inter8212</p>
<p>3.按照通用性分类：</p>
<p>通用接口：Inter8255、Inter8251</p>
<p>专用接口：Inter8279、Inter8275</p>
<p>4.按照数据传送的控制方式分类：</p>
<p>中断接口：Inter8259</p>
<p>DMA接口：Inter8257</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录22</title>
    <url>/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9522/</url>
    <content><![CDATA[<h1 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h1><h3 id="一、程序查询的流程："><a href="#一、程序查询的流程：" class="headerlink" title="一、程序查询的流程："></a>一、程序查询的流程：</h3><p>1.单个设备查询：</p>
<p><a href="https://imgse.com/i/p9kOizd"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/20/p9kOizd.png"
                      alt="p9kOizd.png"
                ></a></p>
<p>2.需要使用测试指令、传送指令、转移指令</p>
<p>3.多个设备查询时，需要根据优先级来逐步查询</p>
<h3 id="二、程序流程："><a href="#二、程序流程：" class="headerlink" title="二、程序流程："></a>二、程序流程：</h3><p>1.保存、寄存器保存</p>
<p>2.<a href="https://imgse.com/i/p9kOkQA"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/20/p9kOkQA.png"
                      alt="p9kOkQA.png"
                ></a></p>
<h3 id="三、程序查询的接口电路："><a href="#三、程序查询的接口电路：" class="headerlink" title="三、程序查询的接口电路："></a>三、程序查询的接口电路：</h3><p>1.<a href="https://imgse.com/i/p9kOPRH"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/20/p9kOPRH.png"
                      alt="p9kOPRH.png"
                ></a></p>
<p>2.DBR是数据缓存器</p>
<p>3.D是准备信号，查询D信号是否为1</p>
<p>4.SEL是设备选择电路</p>
<h1 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h1><h3 id="一、中断的概念："><a href="#一、中断的概念：" class="headerlink" title="一、中断的概念："></a>一、中断的概念：</h3><p>1.计算机在执行程序的过程中，当遇到异常情况和特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处，继续执行原程序，这就是中断。</p>
<h3 id="二、I-x2F-O中断的产生："><a href="#二、I-x2F-O中断的产生：" class="headerlink" title="二、I&#x2F;O中断的产生："></a>二、I&#x2F;O中断的产生：</h3><p>1.以打印机为例：</p>
<p>cpu与打印机并行工作</p>
<p><a href="https://imgse.com/i/p9kOELt"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/20/p9kOELt.png"
                      alt="p9kOELt.png"
                ></a></p>
<h3 id="三、程序中断的方式的接口电路："><a href="#三、程序中断的方式的接口电路：" class="headerlink" title="三、程序中断的方式的接口电路："></a>三、程序中断的方式的接口电路：</h3><p>1.配置中断请求触发器和中断屏蔽触发器：</p>
<p>INTR  中断请求触发器：INTR&#x3D;1  表示有请求</p>
<p>MASK  中断屏蔽触发器   MASK&#x3D;1表示被屏蔽</p>
<p>D  完成触发器</p>
<p>2.排队器：</p>
<p>硬件实现：在CPU内或在接口电路中（链式排队器）</p>
<p><a href="https://imgse.com/i/p9kOAsI"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/20/p9kOAsI.png"
                      alt="p9kOAsI.png"
                ></a></p>
<p>INTR&#x3D;1有请求，即INTR非&#x3D;0</p>
<p>3.中断向量地址形成部件：</p>
<p>硬件实现：由硬件产生向量地址，再由向量地址找到入口地址</p>
<p>中断向量地址形成部件只有一个输入为1，输出是一个向量地址（设备编码器：产生中断服务程序的入口地址）</p>
<p>编码器中只有一组三态门是有效的</p>
<p>4.程序中断方式接口电路的基本组成</p>
<h3 id="四、I-x2F-O中断的处理过程："><a href="#四、I-x2F-O中断的处理过程：" class="headerlink" title="四、I&#x2F;O中断的处理过程："></a>四、I&#x2F;O中断的处理过程：</h3><p>1.CPU响应中断的条件和时间：</p>
<p>（1）条件：允许中断触发器EINT&#x3D;1，用开中断指令将EINT置1，用关中断指令将EINT置0</p>
<p>（2）时间：当D&#x3D;1，且MASK&#x3D;0时</p>
<p>在每条指令执行阶段的结束前，CPU发出中断查询信号（INTR置1）</p>
<p>2.中断处理过程：</p>
<p><a href="https://imgse.com/i/p9Ap14P"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/20/p9Ap14P.png"
                      alt="p9Ap14P.png"
                ></a></p>
<h3 id="五、中断服务程序流程："><a href="#五、中断服务程序流程：" class="headerlink" title="五、中断服务程序流程："></a>五、中断服务程序流程：</h3><p>1.中断服务程序的流程：</p>
<p>（1）保护现场：</p>
<p><a href="https://imgse.com/i/p9ApQAI"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/20/p9ApQAI.png"
                      alt="p9ApQAI.png"
                ></a></p>
<p>（2）中断服务：对不同的I&#x2F;O设备具有不同内容的服务设备</p>
<p>（3）恢复现场：出栈指令	</p>
<p>（4）中断返回：中断返回指令</p>
<p>2.单重中断和多重中断：</p>
<p>（1）单重中断：不允许中断现行的中断服务程序</p>
<p>（2）多重中断：允许级别更高的中断源 中断现行的中断服务程序</p>
<p>3.主程序和服务程序抢占CPU的示意图：</p>
<p><a href="https://imgse.com/i/p9AplNt"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/20/p9AplNt.png"
                      alt="p9AplNt.png"
                ></a></p>
<p>宏观上CPU和I&#x2F;O并行工作</p>
<p>微观上CPU中断现行程序为I&#x2F;O服务</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录23</title>
    <url>/2023/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9523/</url>
    <content><![CDATA[<h1 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h1><h3 id="一、DMA方式的特点："><a href="#一、DMA方式的特点：" class="headerlink" title="一、DMA方式的特点："></a>一、DMA方式的特点：</h3><p>1.DMA和程序中断两种方式的数据通路：</p>
<p>中断方式数据传送通路要用到ACC寄存器</p>
<p>外部设备可以和内存通过DMA接口进行数据交换</p>
<p>2.DMA与内存交换数据的三种方式：</p>
<p>（1）停止CPU访问主存：</p>
<p>控制简单、CPU处于不工作状态或保持状态、没有充分发挥CPU对主存的利用率</p>
<p>（2）周期挪用：</p>
<p>这里的周期是访问存储周期</p>
<p>DMA访问主存有三种可能：</p>
<p>CPU此时不访问主存</p>
<p>CPU正在访问主存</p>
<p>CPU与DMA同时请求访问主存，此时CPU将总线控制权让给DMA</p>
<p><a href="https://imgse.com/i/p9nBodA"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/24/p9nBodA.png"
                      alt="p9nBodA.png"
                ></a></p>
<p>（3）DMA与CPU交替访问：</p>
<p>CPU工作周期：C1专供DMA访存</p>
<p>​			  C2专供CPU仿存</p>
<h3 id="二、DMA接口的功能和组成："><a href="#二、DMA接口的功能和组成：" class="headerlink" title="二、DMA接口的功能和组成："></a>二、DMA接口的功能和组成：</h3><p>1.DMA接口功能：</p>
<p>（1）向CPU申请DMA传送</p>
<p>（2）处理总线控制权的转交</p>
<p>（3）管理系统总线、控制和数据总线</p>
<p>（4）确定数据传送的首地址和长度</p>
<p>​	修正传送过程中的数据地址和长度</p>
<p>（5）DMA传送结束时，给出操作完成信号</p>
<p>2.DMA接口的组成：</p>
<p><a href="https://imgse.com/i/p9nBTII"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/24/p9nBTII.png"
                      alt="p9nBTII.png"
                ></a></p>
<p>AR是地址寄存器，WC是计数器，BR是数据缓冲器，DAR是目标地址寄存器</p>
<h3 id="三、DMA的工作过程："><a href="#三、DMA的工作过程：" class="headerlink" title="三、DMA的工作过程："></a>三、DMA的工作过程：</h3><p>1.DMA传送过程：</p>
<p>预处理、数据传送、后处理</p>
<p>（1）预处理：</p>
<p>通过几条输入输出指令预置如下信息：</p>
<p>通知DMA控制逻辑传送方向（入\出）</p>
<p>设备地址——DMA的DAR</p>
<p>主存地址——DMA的AR</p>
<p>传送字数——DMA的WC</p>
<p><a href="https://imgse.com/i/p9nBhse"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/24/p9nBhse.png"
                      alt="p9nBhse.png"
                ></a></p>
<p>2.后处理：</p>
<p>校验送入主存的数是否正确</p>
<p>是否继续用DMA</p>
<p>测试传送过程是否正确，错则转诊错程序</p>
<p>由中断服务程序完成</p>
<p>3.DMA接口与系统的连接方式：</p>
<p>（1）具有公共请求线的DMA请求：</p>
<p><a href="https://imgse.com/i/p9nBfMD"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/24/p9nBfMD.png"
                      alt="p9nBfMD.png"
                ></a></p>
<p>（2）独立的DMA请求：</p>
<p><a href="https://imgse.com/i/p9nB4qH"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/24/p9nB4qH.png"
                      alt="p9nB4qH.png"
                ></a></p>
<p>4.DMA方式和程序中断方式的比较：</p>
<p><a href="https://imgse.com/i/p9nBIZd"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/24/p9nBIZd.png"
                      alt="p9nBIZd.png"
                ></a></p>
<h3 id="四、DMA接口的类型："><a href="#四、DMA接口的类型：" class="headerlink" title="四、DMA接口的类型："></a>四、DMA接口的类型：</h3><p>1.选择型：在物理上连接多个设备</p>
<p>​		  在逻辑上只允许连接一个设备</p>
<p>2.多路型：在物理上连接多个设备</p>
<p>​		  在逻辑上允许连接多个设备同时工作</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录24</title>
    <url>/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9524/</url>
    <content><![CDATA[<h1 id="数据在计算机中的表示"><a href="#数据在计算机中的表示" class="headerlink" title="数据在计算机中的表示"></a>数据在计算机中的表示</h1><h3 id="一、数的表示："><a href="#一、数的表示：" class="headerlink" title="一、数的表示："></a>一、数的表示：</h3><p>1.无符号数：</p>
<p><a href="https://imgse.com/i/p9Q4i6g"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/27/p9Q4i6g.png"
                      alt="p9Q4i6g.png"
                ></a></p>
<p>寄存器的位数反映了无符号的表示范围</p>
<p>2.有符号数：</p>
<p>（1）机器数和真值：</p>
<p>真值：带符号的数</p>
<p>机器数：符号数字化的数 </p>
<p><a href="https://imgse.com/i/p9Q4Amj"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/27/p9Q4Amj.png"
                      alt="p9Q4Amj.png"
                ></a></p>
<p>3.原码表示法：</p>
<p><a href="https://imgse.com/i/p9Q4E0s"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/27/p9Q4E0s.png"
                      alt="p9Q4E0s.png"
                ></a></p>
<p>例：x &#x3D; +1110，则[x]的原码&#x3D;0,1110 用逗号把符号位和数值位隔开</p>
<p><a href="https://imgse.com/i/p9Q4FXQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/27/p9Q4FXQ.png"
                      alt="p9Q4FXQ.png"
                ></a></p>
<p>用小数点将符号位和数值位隔开</p>
<p>注：原码是保存在计算机中的数</p>
<p><a href="https://imgse.com/i/p9Q4V7n"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/27/p9Q4V7n.png"
                      alt="p9Q4V7n.png"
                ></a></p>
<p>4.原码的特点：简单、直观</p>
<p>但是使用原码做加法时，会出现问题</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录25</title>
    <url>/2023/04/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9525/</url>
    <content><![CDATA[<h1 id="补码表示"><a href="#补码表示" class="headerlink" title="补码表示"></a>补码表示</h1><h3 id="一、补码的概念："><a href="#一、补码的概念：" class="headerlink" title="一、补码的概念："></a>一、补码的概念：</h3><p>1.用时钟引出补码的概念，时钟计时以12为模，可以用正数替代负数（-3和9）</p>
<p>2.一个负数加上“模”，即得到该负数的补数</p>
<p>3.一个正数和一个负数互为补数时，它们绝对值之和即为模数</p>
<p>4.四位的二进制的补码的模是16，超出的位数会被丢掉</p>
<p>5.正数的补数是它本身，负数的补码符号位不变，其余位取反，末位加一</p>
<p>6.<a href="https://imgse.com/i/p91CvPP"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/28/p91CvPP.png"
                      alt="p91CvPP.png"
                ></a></p>
<p><a href="https://imgse.com/i/p91CX5t"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/28/p91CX5t.png"
                      alt="p91CX5t.png"
                ></a></p>
<p>小数的补码模2时，小数点之前是两位</p>
<p>注：第一位是符号位</p>
<p>7.负数补码求原码：符号位不变，其余各位取反，末位加一</p>
<p>8.正0和负0的补码是相同的</p>
<p><a href="https://imgse.com/i/p91Cx8f"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/28/p91Cx8f.png"
                      alt="p91Cx8f.png"
                ></a></p>
<p><strong>注：在定点小数中，原码是不能表示出-1这个值的</strong> </p>
<p><strong>因为负小数的原码是1.xxxxxxx的形式，所以只能表示十进制-0.x，而不能表示-1.0</strong> </p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(课本)学习记录1</title>
    <url>/2023/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%AF%BE%E6%9C%AC-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h3 id="一、基本概念和术语："><a href="#一、基本概念和术语：" class="headerlink" title="一、基本概念和术语："></a>一、基本概念和术语：</h3><p>1.数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中，并被计算机程序处理的符号的总称</p>
<p>2.<strong>数据元素</strong>是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理</p>
<p>3.通常，一个数据元素可以由若干个数据项组成</p>
<p>数据项是数据的不可分割的最小单元</p>
<p>4.<strong>数据对象</strong>是性质相同的数据元素的集合，是数据的一个子集。</p>
<p>5.<strong>数据结构</strong>是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<p>6.根据元素之间关系的不同特性，通常有以下四种基本机构：</p>
<p>（1）集合</p>
<p>（2）线性结构</p>
<p>（3）树形结构</p>
<p>（4）图状结构和网状结构</p>
<p><a href="https://imgse.com/i/p91fzQS"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/29/p91fzQS.png"
                      alt="p91fzQS.png"
                ></a></p>
<p>7.数据结构在计算机中的表示（映像）称为数据的物理结构，又称为存储结构，包括数据元素的表示和关系的表示</p>
<p>8.高级语言中的数据类型可以分为两类：</p>
<p>（1）非结构的原子类型</p>
<p>（2）结构类型</p>
<p>9.抽象数据类型（ADT）是指一个数学模型以及定义在该模型上的一组操作</p>
<p>10.抽象数据类型的定义由一个值域和定义在该值域上的一组操作组成，可以细分为下列三种类型：</p>
<p>（1）原子类型</p>
<p>（2）固定聚合类型</p>
<p>（3）可变聚合类型</p>
<p>11.和数据结构的形式定义类似，抽象数据类型可以用三元组表示：</p>
<p>（D，S，P）</p>
<p>D是数据对象，S是D上的关系集，P是D的基本操作集</p>
<p>12.多行数据类型是指其值的成分不确定的数据类型。从抽象数据类型的角度看，具有相同的数学抽象特性，故称之为多行数据类型。需要借助面向对象的程序设计语言实现。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录2</title>
    <url>/2023/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h1><h3 id="树的定义："><a href="#树的定义：" class="headerlink" title="树的定义："></a>树的定义：</h3><p>1.树是n（n&gt;&#x3D;0）个有限数据元素的集合。</p>
<p>2.树满足的条件：</p>
<p>（1）有且仅有一个根节点</p>
<p>（2）其余的节点分为m（m&gt;&#x3D;0）个互不相交的非空集合，其中每个集合本身就是一棵树，称为根的子树</p>
<h3 id="树的表示方法："><a href="#树的表示方法：" class="headerlink" title="树的表示方法："></a>树的表示方法：</h3><p>1.树形表示法</p>
<p>2.嵌套集合表示法</p>
<p>3.凹入表示法</p>
<p>4.广义表示法</p>
<h3 id="树的基本术语："><a href="#树的基本术语：" class="headerlink" title="树的基本术语："></a>树的基本术语：</h3><p>1.结点：树的结点包含一个数据元素及若干指向其子树的分支</p>
<p>2.结点的度：结点所拥有的分支数目或后继结点个数</p>
<p>3.树的度：树中各结点度的最大值</p>
<p>4.叶子（终端结点）：度为零的结点称为叶子结点</p>
<p>5.分支（非终端结点）：度不为零的结点</p>
<p>6.孩子结点：一个结点的后继称为该结点的孩子结点</p>
<p>7.双亲结点：一个结点是其后继结点的双亲节点</p>
<p>8.兄弟结点：同一个双亲结点下的孩子节点互称为兄弟结点</p>
<p>9.堂兄弟：双亲互为兄弟的两个结点互称为堂兄弟</p>
<p>10.子孙结点：一个结点的所有子树的结点</p>
<p>11.祖先结点：从树根结点到达一个结点路径上的所有结点称为该结点的祖先结点</p>
<p>12.结点的层次：根结点的层次为1，其余结点的层次等于它双亲结点的层次加一</p>
<p>13.树的深度：树中结点的最大层次称为树的深度（或高度）</p>
<p>14.有序树、无序树：交换某结点各子树的相对位置，会构成不同的树，这样的树称为有序树，反之则是无序树</p>
<p>15.森林：m（m&gt;&#x3D;0）棵互不相交的树的集合</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>1.二叉树是有n（n&gt;&#x3D;0）个结点的有限集合，该集合或者为空，或者由一个根结点及两个不相交的子树组成（左子树和右子树）</p>
<p>2.左子树和右子树同样都是二叉树</p>
<p>3.二叉树是特殊的有序树</p>
<p>4.二叉树的性质：</p>
<p>（1）在二叉树的第i层至多有2^(i-1)个结点</p>
<p>（2）深度为h的二叉树中至多有(2^h) - 1结点</p>
<p>（3）对任意一棵二叉树T，如果其叶子结点数为n0，度为2的结点数为n2，则有n0 &#x3D; n2 + 1</p>
<p>（4）具有n个结点的完全二叉树的深度为log2n（以2为底的对数） + 1</p>
<p>（5）如果一棵n个结点的完全二叉树的结点按层次有：</p>
<p>如果i&#x3D;1，结点i是根结点，无双亲；如果i&gt;1。则其双亲结点是结点i&#x2F;2</p>
<p>如果2i&gt;n，则结点i无左孩子，该结点为叶子结点；否则其左孩子是结点2i</p>
<p>如果2i+1&gt;n，则结点i无右孩子，该结点为叶子结点；否则其右孩子是结点2i+1</p>
<p>5.二叉树的存储结构：</p>
<p>（1）顺序存储</p>
<p>（2）链式存储</p>
<p>6.二叉树的遍历方式：</p>
<p>（1）先序遍历：根—-左—–右</p>
<p>（2）中序遍历：左—-根—-右</p>
<p>（3）后序遍历：左—-右—-根</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录26</title>
    <url>/2023/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9526/</url>
    <content><![CDATA[<h1 id="数的表示"><a href="#数的表示" class="headerlink" title="数的表示"></a>数的表示</h1><h3 id="一、反码定义："><a href="#一、反码定义：" class="headerlink" title="一、反码定义："></a>一、反码定义：</h3><p>1.整数的反码：</p>
<p><a href="https://imgse.com/i/p917SyV"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/29/p917SyV.png"
                      alt="p917SyV.png"
                ></a></p>
<p>小数的反码：</p>
<p><a href="https://imgse.com/i/p91TXJs"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/29/p91TXJs.png"
                      alt="p91TXJs.png"
                ></a></p>
<p>用逗号将符号位和数值位隔开</p>
<p>2.正数的反码就是它本身，负数的反码是符号位不变，其余位数取反</p>
<p>3.正0和负0的反码不相同</p>
<h3 id="二、三种机器数的小结："><a href="#二、三种机器数的小结：" class="headerlink" title="二、三种机器数的小结："></a>二、三种机器数的小结：</h3><p>1.最高位为<strong>符号位</strong>，书写上用“，”（整数）或“.”（小数）将数值位和符号位隔开</p>
<p>2.对于正数，原码&#x3D;补码&#x3D;反码</p>
<p>对于负数，符号位为1，其数值部分</p>
<p>原码除符号位外每位取反末位加一得到补码</p>
<p>原码除符号位外每位取反得到反码</p>
<p>3.<a href="https://imgse.com/i/p91TzQ0"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/29/p91TzQ0.png"
                      alt="p91TzQ0.png"
                ></a></p>
<h3 id="三、移码表示："><a href="#三、移码表示：" class="headerlink" title="三、移码表示："></a>三、移码表示：</h3><p>1.补码很难直接判断其真值的大小</p>
<p>2.<a href="https://imgse.com/i/p91Tvzq"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/29/p91Tvzq.png"
                      alt="p91Tvzq.png"
                ></a></p>
<p>移码中符号位为1表示正数，符号位为0表示负数</p>
<p>3.移码没有小数形式的定义</p>
<p>4.正数的补码和移码符号位不同，数值位相同</p>
<p>   负数的补码和移码符号位不同，数值位相同</p>
<p>5.补码与移码只差一个符号位</p>
<p>6.正0和负0的移码是相同</p>
<p>7.最小的真值的移码全为0</p>
<p>8.用移码表示浮点数的阶码</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录27</title>
    <url>/2023/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9527/</url>
    <content><![CDATA[<h1 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h1><h3 id="一、定点表示："><a href="#一、定点表示：" class="headerlink" title="一、定点表示："></a>一、定点表示：</h3><p>1.小数点按照约定的方式标出</p>
<p>2.<a href="https://imgse.com/i/p98pTzT"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/30/p98pTzT.png"
                      alt="p98pTzT.png"
                ></a></p>
<p>3.可以分为小数定点机和整数定点机</p>
<p>4.定点表示的范围：<a href="https://imgse.com/i/p98pHQU"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/30/p98pHQU.png"
                      alt="p98pHQU.png"
                ></a></p>
<h3 id="二、浮点表示："><a href="#二、浮点表示：" class="headerlink" title="二、浮点表示："></a>二、浮点表示：</h3><p><strong>1.为什么要引入浮点数表示</strong>：</p>
<p>（1）编程困难，程序员要调节小数点的位置</p>
<p>（2）数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长</p>
<p>（3）数据存储单元的利用率很低</p>
<p>2.浮点数的表示：</p>
<p><a href="https://imgse.com/i/p98pbyF"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/30/p98pbyF.png"
                      alt="p98pbyF.png"
                ></a></p>
<p>S是小数、可正可负</p>
<p>j是整数、可正可负</p>
<p>3.浮点数的表示形式：</p>
<p><a href="https://imgse.com/i/p98pqL4"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/30/p98pqL4.png"
                      alt="p98pqL4.png"
                ></a></p>
<p>Sf     代表浮点数的符号</p>
<p>n      其位数反映浮点数的精度</p>
<p>m     其位数反映浮点数的表示范围</p>
<p>jf 和 m 共同表示小数点的实际位置</p>
<p>4.浮点数的表示范围：</p>
<p><a href="https://imgse.com/i/p98pOeJ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/30/p98pOeJ.png"
                      alt="p98pOeJ.png"
                ></a></p>
<p>上溢：阶码  &gt;  最大阶码</p>
<p>下溢：阶码  &lt;  最小阶码   按机器零处理</p>
<p>注：尾数的位数影响数的精度</p>
<p>5.浮点数的规格化形式：</p>
<p>尾数的基数不同，浮点数的规格化形式不同</p>
<p>6.浮点数的规格化：</p>
<p><strong>基数r越大，可以表示的浮点数的范围越大</strong></p>
<p><strong>基数r越大，浮点数的精度降低</strong></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录28</title>
    <url>/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9528/</url>
    <content><![CDATA[<h1 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h1><h3 id="一、加减法运算："><a href="#一、加减法运算：" class="headerlink" title="一、加减法运算："></a>一、加减法运算：</h3><p>1.<a href="https://imgse.com/i/p9t7VmR"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/04/p9t7VmR.png"
                      alt="p9t7VmR.png"
                ></a></p>
<p>2.符号位产生的进位自动舍去</p>
<p>3.机器数要考虑内存的长度</p>
<h3 id="二、移位运算："><a href="#二、移位运算：" class="headerlink" title="二、移位运算："></a>二、移位运算：</h3><p>1.左移：绝对值扩大</p>
<p>  右移：绝对值缩小</p>
<p>2.在计算机中，移位操作和加减法相结合，可以实现乘除法</p>
<p>3.算术移位的规则：</p>
<p>符号位不变，符号位不参与移位</p>
<p><a href="https://imgse.com/i/p9t7AX9"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/04/p9t7AX9.png"
                      alt="p9t7AX9.png"
                ></a></p>
<p>4.原码左移时空位添0，右移时空位添0</p>
<p>   补码左移时空位添0，右移时空位添1</p>
<p>   反码左移时空位添1，右移时空位添1</p>
<p>5.算术移位的硬件实现：</p>
<p><a href="https://imgse.com/i/p9t7Fl4"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/04/p9t7Fl4.png"
                      alt="p9t7Fl4.png"
                ></a></p>
<p>6.丢掉1的影响：</p>
<p><a href="https://imgse.com/i/p9t7k6J"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/04/p9t7k6J.png"
                      alt="p9t7k6J.png"
                ></a></p>
<p>7.算术移位：有符号的移位</p>
<p>   逻辑移位：无符号数的移位</p>
<p>8.逻辑左移：低位添0，高位丢失</p>
<p>   逻辑右移：高位添0，低位丢失</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录4</title>
    <url>/2023/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="一、计算："><a href="#一、计算：" class="headerlink" title="一、计算："></a>一、计算：</h3><p>1.计算&#x3D;信息处理</p>
<p>借助某种工具，遵照一定的规则，以明确而机械的形式进行</p>
<p>2.计算模型&#x3D;计算机&#x3D;信息处理的工具</p>
<p>3.算法：</p>
<p>输入（待处理的信息）</p>
<p>输出（经过处理的信息）</p>
<p>正确性</p>
<p>确定性（任一算法都可以描述为一个由基本操作组成的序列）</p>
<p>可行性</p>
<p>有穷性（经过有穷次的计算之后，得出结果）</p>
<p>4.程序未必是算法</p>
<p>5.好的算法：正确、健壮、可读、效率（速度尽可能快，存储空间尽可能少）</p>
<h3 id="二、计算模型："><a href="#二、计算模型：" class="headerlink" title="二、计算模型："></a>二、计算模型：</h3><p>1.算法分析：正确性、成本（时间和空间）</p>
<p>2.问题实例的规模，往往是决定计算成本的主要因素</p>
<p>3.算法最坏的情况：在规模同为n的所有实例中，只关注最坏（成本最高）者</p>
<p>4.同一个问题具有多个算法，如何评价优劣：</p>
<p>为了给出客观的评判，需要抽象出一个理想的平台或模型，不在依赖其他的次要因素，从而直接而准确地描述、测量并评价算法</p>
<p>5.图灵机：计算能力最强的自动机，由一个有限控制器和一条可以无限延伸的读写带组成。在当前状态下读到一个带符号（分为输入符号、输出符号、空白符号和边界符号四类）时，实现状态转换，在当前格写上新的符号，读写头向左或向右移动一格，或不动，图灵机所接受的语言是0型语言。 </p>
<p>6.作为一个理想计算模型，图灵机的纸带是两端无线延伸的无限长纸带</p>
<p>7.RAM模型：一般计算工具的简化和抽象</p>
<p>8.RAM模型只支持加减运算</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录29</title>
    <url>/2023/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9529/</url>
    <content><![CDATA[<h1 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h1><h3 id="一、溢出判断："><a href="#一、溢出判断：" class="headerlink" title="一、溢出判断："></a>一、溢出判断：</h3><p>1.一位符号位的判断：参加操作的两个数（减法时即为被减数和“求补”以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出</p>
<p>2.硬件实现：最高有效位的进位与符号位的近位相异或，如果结果为1则溢出</p>
<p>3.两位符号位判断溢出：</p>
<p><a href="https://imgse.com/i/p96hRUg"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/13/p96hRUg.png"
                      alt="p96hRUg.png"
                ></a></p>
<p>结果的双符号位相同，未溢出</p>
<p>结果的双符号位不同，发生溢出</p>
<p>4.最高符号位代表其真正的符号</p>
<p>A、X均为n+1位，用减法标记GS控制求补逻辑</p>
<p><a href="https://imgse.com/i/p96hW5Q"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/13/p96hW5Q.png"
                      alt="p96hW5Q.png"
                ></a></p>
<h3 id="二、乘法运算："><a href="#二、乘法运算：" class="headerlink" title="二、乘法运算："></a>二、乘法运算：</h3><p>1.符号位单独处理</p>
<p>2.原码的乘法运算：</p>
<p><a href="https://imgse.com/i/p965zB6"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/13/p965zB6.png"
                      alt="p965zB6.png"
                ></a></p>
<p>3.原码乘法的特点：</p>
<p>（1）绝对值运算</p>
<p>（2）用移位的次数判断乘法是否结束</p>
<p>（3）移位是逻辑移位</p>
<p>4.原码一位乘的硬件配置：</p>
<p><a href="https://imgse.com/i/p96IKUS"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/13/p96IKUS.png"
                      alt="p96IKUS.png"
                ></a></p>
<p>A、X、Q均为n+1位</p>
<p>移位和加受末位乘数的控制</p>
<h3 id="三、除法运算："><a href="#三、除法运算：" class="headerlink" title="三、除法运算："></a>三、除法运算：</h3><p>1.商符单独处理（符号位异或形成）</p>
<p>2.余数不动低位补0，减右移移位的除数</p>
<p>3.在机器中，采用一位字长加法器</p>
<p>4.原码除法：</p>
<p><a href="https://imgse.com/i/p96oFaT"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/13/p96oFaT.png"
                      alt="p96oFaT.png"
                ></a></p>
<p>约定：（1）小数定点除法X* &lt;  Y<em>，整数定点除法X * &gt;  Y</em></p>
<p>​	   （2）被除数不等于0</p>
<p>​	   （3）除数不能为0</p>
<p>5.恢复余数法：</p>
<p>移位操作是逻辑左移</p>
<p>6.不恢复余数法（加减交替法）：</p>
<p>（1）加减交替，移位是逻辑左移</p>
<p>（2）上商n+1次，第一次上商判断溢出，移n次，加n+1次</p>
<p>（3）用移位的次数判断除法是否结束</p>
<p>7.原码加减交替除法硬件配置：</p>
<p><a href="https://imgse.com/i/p96oaLt"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/13/p96oaLt.png"
                      alt="p96oaLt.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习记录2</title>
    <url>/2023/05/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="操作系统的概念和功能"><a href="#操作系统的概念和功能" class="headerlink" title="操作系统的概念和功能"></a>操作系统的概念和功能</h1><h3 id="一、操作系统的概念："><a href="#一、操作系统的概念：" class="headerlink" title="一、操作系统的概念："></a>一、操作系统的概念：</h3><p>1.<a href="https://imgse.com/i/p96Ohjg"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/13/p96Ohjg.png"
                      alt="p96Ohjg.png"
                ></a></p>
<p>2.操作系统（OS）是指控制和管理计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供用户和其他软件方便的接口和环境，是计算机系统中最基本的系统软件</p>
<p>3.操作系统是系统资源的管理者，为上层提供方便的服务，是最接近硬件的软件</p>
<p>4.执行一个程序前需要将该程序放到内存中，才能被CPU处理</p>
<p>5.<a href="https://imgse.com/i/p96O5uQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/13/p96O5uQ.png"
                      alt="p96O5uQ.png"
                ></a></p>
<p>6.操作系统提供的服务：</p>
<p>（1）图形化命令界面（GUI）</p>
<p>（2）联机命令接口（交互式命令接口）</p>
<p>（3）脱机命令接口（批处理命令接口）</p>
<p>（4）程序接口：普通用户不能直接使用，只能通过系统调用来间接使用</p>
<p>系统调用（广义指令）类似于函数调用，是应用程序请求操作系统服务的唯一方式</p>
<p>7.没有安装软件的计算机是裸机</p>
<p>8.操作系统实现对硬件机器的拓展</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习记录3</title>
    <url>/2023/05/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="操作系统的四个特征"><a href="#操作系统的四个特征" class="headerlink" title="操作系统的四个特征"></a>操作系统的四个特征</h1><h3 id="一、并发"><a href="#一、并发" class="headerlink" title="一、并发"></a>一、并发</h3><p>1.<strong>并发</strong>：是指两个或多个事件在同一时间间隔内发生。事件在宏观上是同时发生的，在微观上是交替发生的</p>
<p>2.<strong>并行</strong>：指两个或多个事件在同一时刻同时发生</p>
<p>3.操作系统的并发是指计算机系统中 “同时” 运行多个程序，这些程序宏观上看是同时运行的，微观上看是交替运行的</p>
<p>4.单核CPU同一时刻只能执行一个程序，各个程序只能<strong>并发</strong>地执行</p>
<p>多核CPU同一时刻可以同时执行多个程序，多个程序可以<strong>并行</strong>地执行</p>
<h3 id="二、共享"><a href="#二、共享" class="headerlink" title="二、共享"></a>二、共享</h3><p>1.共享：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同执行</p>
<p>2.<a href="https://imgse.com/i/p96xDRP"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/13/p96xDRP.png"
                      alt="p96xDRP.png"
                ></a></p>
<p>在微观上，进程可能是交替地对资源进行访问</p>
<p>3.并发性指计算机系统中同时存在着多个运行的程序</p>
<p>  共享性是指系统中的资源可以供内存中多个并发执行的进程共同使用</p>
<h3 id="三、虚拟"><a href="#三、虚拟" class="headerlink" title="三、虚拟"></a>三、虚拟</h3><p>1.<strong>虚拟</strong>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，逻辑对应物是用户感受到的</p>
<p>2.虚拟技术中的空分复用技术（虚拟存储器技术）</p>
<p>3.虚拟技术中的“时分复用”技术，微观上处理机在各个微小的时间段内交替为各个进程服务</p>
<p>4.没有并发性，就谈不上虚拟性</p>
<h3 id="四、异步"><a href="#四、异步" class="headerlink" title="四、异步"></a>四、异步</h3><p>1.<strong>异步</strong>是指，在多道程序环境中，允许多个程序并发执行，但由于资源有限，进程的执行是走走停停的，以不可预知的速度推进，这就是程序的异步性</p>
<p>2.只有系统拥有并发性，才有可能导致异步性</p>
<p>注：<strong>并发和共享互为存在条件，并发和共享是操作系统的两个最基本的特性</strong></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录30</title>
    <url>/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9530/</url>
    <content><![CDATA[<h1 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h1><h3 id="一、浮点加减运算："><a href="#一、浮点加减运算：" class="headerlink" title="一、浮点加减运算："></a>一、浮点加减运算：</h3><p>1.<a href="https://imgse.com/i/p9ID6FU"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/22/p9ID6FU.png"
                      alt="p9ID6FU.png"
                ></a></p>
<p>2.对阶原则：小阶向大阶看齐</p>
<p>3.规格化：提高浮点数的精度</p>
<p>4.尾数规格化数的定义：</p>
<p><a href="https://imgse.com/i/p9IDsoT"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/22/p9IDsoT.png"
                      alt="p9IDsoT.png"
                ></a></p>
<p>5.规格化数的判断：</p>
<p><a href="https://imgse.com/i/p9IDcYF"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/22/p9IDcYF.png"
                      alt="p9IDcYF.png"
                ></a></p>
<p>原码不论正数、负数，第一数位为1</p>
<p>补码符号位和第一数位不同</p>
<p>6.特例：[-0.5]补不是规格化的数</p>
<p>[-1]补是规格化的数</p>
<p>7.左规：尾数左移一位，阶码减一，直到数符和第一数位不同为止</p>
<p>8.当尾数溢出（&gt;1）的时候，需要右规</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录5</title>
    <url>/2023/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</url>
    <content><![CDATA[<h1 id="数据结构的三要素"><a href="#数据结构的三要素" class="headerlink" title="数据结构的三要素"></a>数据结构的三要素</h1><h3 id="一、数据的逻辑结构："><a href="#一、数据的逻辑结构：" class="headerlink" title="一、数据的逻辑结构："></a>一、数据的逻辑结构：</h3><p>1.集合：各个元素同属一个集合，别无其他关系</p>
<p>2.线性结构：数据元素是一对一的关系，除了第一个元素，所有的元素都有唯一的前驱，除了最后一个元素，所有的元素都有唯一的后继</p>
<p>3.树形结构：数据元素之间是一对多的关系</p>
<p>4.图结构：数据元素之间是多对多的关系</p>
<h3 id="二、数据运算："><a href="#二、数据运算：" class="headerlink" title="二、数据运算："></a>二、数据运算：</h3><p>1.针对与某种特定的逻辑结构，结合实际需求，定义基本运算</p>
<h3 id="三、数据的物理结构："><a href="#三、数据的物理结构：" class="headerlink" title="三、数据的物理结构："></a>三、数据的物理结构：</h3><p>1.顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系体现</p>
<p>2.链式存储：逻辑上相邻的元素在物理位置上不相邻，借助指针来表示元素之间的逻辑关系</p>
<p>3.索引存储：在存储元素信息的同时，还建立附加的索引表</p>
<p>4.散列存储：根据元素的关键字直接计算出该元素的存储地址，又称为哈希存储</p>
<p>5.数据的存储结构会影响数据运算的速度</p>
<p>数据类型：是一个值的集合和定义在该集合上的一组操作的总称</p>
<p>6.数据类型分为原子类型和结构类型</p>
<p>（1）原子类型：其值不可以再分解</p>
<p>（2）结构类型：其值可以再分为若干成分的数据类型</p>
<p>7.抽象数据类型（ADT）：抽象数据组织及与之相关的操作</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录6</title>
    <url>/2023/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956/</url>
    <content><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h3 id="一、算法的基本概念："><a href="#一、算法的基本概念：" class="headerlink" title="一、算法的基本概念："></a>一、算法的基本概念：</h3><p>1.算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作</p>
<p>2.算法的特性：</p>
<p>（1）有穷性</p>
<p>（2）确定性：每条指令有确定的含义</p>
<p>（3）可行性：算法描述的操作可以通过已经实现的基本运算执行有限次来实现</p>
<p>（4）输入</p>
<p>（5）输出</p>
<p>3.好的算法的特性：正确性，可读性，鲁棒性，高效，低存储</p>
<h3 id="二、算法的时间复杂度："><a href="#二、算法的时间复杂度：" class="headerlink" title="二、算法的时间复杂度："></a>二、算法的时间复杂度：</h3><p>1.事前预估算法的时间开销T(n)与问题规模n的关系（T表示时间）</p>
<p>2.时间复杂度中大O表示只考虑最高阶的部分</p>
<p>3.顺序执行的代码只会影响常数阶，可以忽略</p>
<p>4.时间复杂度分析时，只需要挑循环中的一个基本操作分析它的执行次数与n的关系即可</p>
<p>5.如果有多层嵌套循环，只需要关注最深层的循环循环了几次</p>
<p>6.一般只考虑最坏的时间复杂度和平均的时间复杂度</p>
<p><a href="https://imgse.com/i/p9I6l9S"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/22/p9I6l9S.png"
                      alt="p9I6l9S.png"
                ></a></p>
<h3 id="三、算法的空间复杂度"><a href="#三、算法的空间复杂度" class="headerlink" title="三、算法的空间复杂度:"></a>三、算法的空间复杂度:</h3><p>1.分析方法：</p>
<p><a href="https://imgse.com/i/p9I6qEt"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/22/p9I6qEt.png"
                      alt="p9I6qEt.png"
                ></a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录31</title>
    <url>/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9531/</url>
    <content><![CDATA[<h1 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h1><h3 id="一、ALU电路："><a href="#一、ALU电路：" class="headerlink" title="一、ALU电路："></a>一、ALU电路：</h3><p>1.<a href="https://imgse.com/i/p9L9A4e"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/27/p9L9A4e.png"
                      alt="p9L9A4e.png"
                ></a></p>
<p>2.ALU电路是一个组合逻辑电路，Ki不同取值，Fi不同</p>
<h3 id="二、快速进位链："><a href="#二、快速进位链：" class="headerlink" title="二、快速进位链："></a>二、快速进位链：</h3><p>1.并行加法器</p>
<p><a href="https://imgse.com/i/p9L9V9H"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/27/p9L9V9H.png"
                      alt="p9L9V9H.png"
                ></a></p>
<p>2.Ci-1是低位产生的进位</p>
<p>3.Ai与Bi相乘是本地进位，Ai和Bi相加是传送条件</p>
<p>4.进位链：传送进位的电路</p>
<p>5.串行进位链：进行串行传送</p>
<p>6.设与非门的级延迟时间为Ty，则n位全加器产生进位的全部时间为2nTy</p>
<p>7.并行进位链：n位加法器的进位同时产生（先行进位，跳跃进位）</p>
<p>8.改进的方法：</p>
<p>（1）单重分组跳跃进位链：</p>
<p>n位全加器分为若干个小组，小组中的进位同时产生，小组与小组之间采用串行进位</p>
<p>（2）双重分组跳跃进位链：</p>
<p>n位全加器分为若干大组，大组之间又包含若干小组，每个大组中小组的最高位进位同时产生。大组与大组之间采用串行进位</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录32</title>
    <url>/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9532/</url>
    <content><![CDATA[<h1 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h1><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>1.机器指令是指计算机系统的CPU能够直接识别指向的操作命令</p>
<p>2.指令集是软件和硬件的交界</p>
<h3 id="二、指令的一般形式："><a href="#二、指令的一般形式：" class="headerlink" title="二、指令的一般形式："></a>二、指令的一般形式：</h3><p>1.<a href="https://imgse.com/i/p9LiCBq"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/27/p9LiCBq.png"
                      alt="p9LiCBq.png"
                ></a></p>
<p>2.操作码：反映机器做什么操作</p>
<p>3.操作码的分类：</p>
<p>（1）长度固定</p>
<p>（2）长度可变，采用扩展操作码技术</p>
<p>操作码的位数随地址数的减少而增加</p>
<p>4.三地址指令操作码每减少一种最多可以构成2的4次方种二地址指令</p>
<p>二地址指令操作码每减少一种最多可以构成2的4种一地址指令</p>
<p>5.在指令执行的过程中，经常出现的高频指令用短操作码表示，不经常出现的指令用长操作码表示</p>
<p>6.地址码：</p>
<p>以四地址为例：</p>
<p><a href="https://imgse.com/i/p9LiPH0"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/27/p9LiPH0.png"
                      alt="p9LiPH0.png"
                ></a></p>
<h3 id="三、指令字长："><a href="#三、指令字长：" class="headerlink" title="三、指令字长："></a>三、指令字长：</h3><p>1.<a href="https://imgse.com/i/p9LiFEV"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/27/p9LiFEV.png"
                      alt="p9LiFEV.png"
                ></a></p>
<p>2.指令字长固定：</p>
<p>指令字长&#x3D;存储字长</p>
<p>3.指令字长可变：按字节的倍数变化</p>
<p>4.当用一些硬件资源代替指令字中的地址码字段后可以：</p>
<p>（1）扩大指令的寻址范围</p>
<p>（2）缩短指令字长</p>
<p>（3）减少访存次数</p>
<p>5.当指令的地址字段为寄存器时：</p>
<p>（1）三地址 OP R1，R2，R3</p>
<p>（2）二地址 OP R1，R2</p>
<p>（3）一地址 OP R1</p>
<p>可以缩短指令字长</p>
<p>指令执行阶段不访存</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录33</title>
    <url>/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9533/</url>
    <content><![CDATA[<h1 id="操作数的类型和操作类型"><a href="#操作数的类型和操作类型" class="headerlink" title="操作数的类型和操作类型"></a>操作数的类型和操作类型</h1><h3 id="一、操作数的类型："><a href="#一、操作数的类型：" class="headerlink" title="一、操作数的类型："></a>一、操作数的类型：</h3><p>1.地址：无符号整数</p>
<p>2.数字：定点数、浮点数、十进制数</p>
<p>3.字符：ASCII</p>
<p>4.逻辑数：逻辑运算</p>
<h3 id="二、数据在存储器中的存放方式："><a href="#二、数据在存储器中的存放方式：" class="headerlink" title="二、数据在存储器中的存放方式："></a>二、数据在存储器中的存放方式：</h3><p>1.字地址为高字节地址</p>
<p>2.字地址为低字节地址</p>
<p>3.字节编码：</p>
<p>（1）从任意位置开始存储</p>
<p>  优点：不浪费存储资源</p>
<p>  缺点：除了访问一个字节之外，访问其他类型的数据都可能花费两个存储周期的时间。读写控制比较复杂</p>
<p>（2）从一个存储字的起始位置开始访问</p>
<p>  优点：无论何种类型的数据，在一个周期内均可以完成，读写控制简单</p>
<p>  缺点：浪费了宝贵的存储资源</p>
<p>（3）边界对准方式：从地址的整数倍位置开始访问</p>
<p>数据存放的起始地址是数据长度的整数倍</p>
<h3 id="三、操作类型："><a href="#三、操作类型：" class="headerlink" title="三、操作类型："></a>三、操作类型：</h3><p>1.数据传送：</p>
<p>源寄存器、目的寄存器</p>
<p>2.算术逻辑操作</p>
<p>3.移位操作</p>
<p>4.转移指令：如 JMP等</p>
<p>5.陷阱（Trap）指令</p>
<p>6.输入输出指令：</p>
<p>输入：把端口中的内容传入CPU的寄存器</p>
<p>输出：CPU寄存器的内容输出到端口</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录34</title>
    <url>/2023/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9534/</url>
    <content><![CDATA[<h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><h3 id="一、寻址的定义"><a href="#一、寻址的定义" class="headerlink" title="一、寻址的定义"></a>一、寻址的定义</h3><p>1.寻址方式是指确定本条指令的数据地址以及下一条将要执行的指令的地址的方法，它与硬件结构紧密相关，而且直接影响指令格式和指令的功能</p>
<p>2.寻址方式分为指令寻址和数据寻址</p>
<h3 id="二、指令寻址"><a href="#二、指令寻址" class="headerlink" title="二、指令寻址"></a>二、指令寻址</h3><p>1.指令寻址分为顺序寻址和跳跃寻址</p>
<p>2.顺序寻址可以通过程序计数器PC加1，自动形成下一条指令的地址，跳跃寻址通过转移类指令实现</p>
<h3 id="三、数据寻址"><a href="#三、数据寻址" class="headerlink" title="三、数据寻址"></a>三、数据寻址</h3><p>1.数据寻址方式种类较多，在指令字中必须设一字段来指明属于哪一种寻址方式</p>
<p>2.指令的地址码字段通常都不代表指令的真实地址，我们称之为形式地址，记为A。操作数的真实地址称为有效地址，记为EA。它由寻址方式和形式地址共同确定。</p>
<p>3.指令的格式：</p>
<p><a href="https://imgse.com/i/pCDaY40"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/02/pCDaY40.png"
                      alt="pCDaY40.png"
                ></a></p>
<p>4.数据寻址的类型：</p>
<p>（1）立即寻址</p>
<p>（2）直接寻址</p>
<p>（3）隐含寻址</p>
<p>（4）间接寻址</p>
<p>（5）寄存器寻址</p>
<p>（6）寄存器间接寻址</p>
<p>（7）基址寻址</p>
<p>（8）变址寻址</p>
<p>（9）相对寻址</p>
<p>（10）堆栈寻址</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习记录4</title>
    <url>/2023/07/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h3 id="一、什么是操作系统？"><a href="#一、什么是操作系统？" class="headerlink" title="一、什么是操作系统？"></a>一、什么是操作系统？</h3><p>1.操作系统是管理计算机硬件与软件资源的计算机程序</p>
<p>2.计算机系统的功能从上到下：用户、应用程序、操作系统、硬件</p>
<p>3.OS是一种系统软件：</p>
<p>（1）与硬件进行交互</p>
<p>（2）对资源共享进行调度管理</p>
<p>（3）解决并发操作处理中的协调问题</p>
<p>（4）外部的接口多样化</p>
<p>4.操作系统的功能：</p>
<p>（1）管理和配置内存</p>
<p>（2）决定系统资源的优先次序</p>
<p>（3）控制输入设备和输出设备</p>
<p>（4）操作网络和管理文件系统的基本事务</p>
<p>（5）提供用户和系统交互的界面</p>
<h3 id="二、操作系统的目标："><a href="#二、操作系统的目标：" class="headerlink" title="二、操作系统的目标："></a>二、操作系统的目标：</h3><p>1.有效性</p>
<p>2.方便性</p>
<p>3.可扩充性</p>
<p>4.开放性</p>
<h3 id="三、操作系统的功能详解："><a href="#三、操作系统的功能详解：" class="headerlink" title="三、操作系统的功能详解："></a>三、操作系统的功能详解：</h3><p>1.作为计算机系统资源的管理者：</p>
<p>（1）处理机管理</p>
<p>（2）存储器管理</p>
<p>（3）I&#x2F;O设备管理</p>
<p>（4）文件管理</p>
<p>2.作为用户与计算机硬件系统之间的接口：</p>
<p>（1）程序接口</p>
<p>（2）命令接口</p>
<p>（3）GUI（图形用户接口）</p>
<p>3.实现了对计算机资源的抽象：</p>
<p>（1）将硬件资源抽象成软件资源</p>
<p>（2）应用程序通过系统调用访问硬件资源</p>
<p>（3）将实现细节隐藏</p>
<h3 id="四、操作系统的特征："><a href="#四、操作系统的特征：" class="headerlink" title="四、操作系统的特征："></a>四、操作系统的特征：</h3><p>1.<strong>并发</strong>：同一时间间隔内执行和调度多个程序的能力</p>
<p>宏观上，处理机同时执行多道程序</p>
<p>围观上，处理机在多道程序之间高速切换（分别交替执行）</p>
<p>并发关注单个处理机同一时间段内处理任务数量的能力</p>
<p><strong>并行</strong>：同一时刻（时间点）发生的事件数量（一个程序）</p>
<p>2.<strong>共享</strong>：资源共享，系统中的资源供多个并发执行的应用程序共同使用</p>
<p>同时访问方式：同一时间段允许多个程序同时访问共享资源</p>
<p>互斥共享方式：也叫独占式，允许多个程序在给同一个共享资源上独立而互不干扰的工作</p>
<p><font color=blue>并发和共享互为存在条件</font></p>
<p>共享性要求OS中同时运行多道程序</p>
<p>并发性难以避免的导致多道程序同时访问一个资源，多道程序共享部分资源</p>
<p>3.<strong>虚拟</strong>：使用某种技术把一个物理实体变为多个逻辑上的对应物。</p>
<p>时分复用技术（TDM），虚拟处理机技术</p>
<p>空分复用技术（SDM），虚拟磁盘技术</p>
<p>虚拟的前提是并发</p>
<p>4.<strong>异步</strong>：多道程序环境下，允许多个程序并发执行；单道程序环境下，多个程序分时交替执行</p>
<p>程序执行的异步性是由于程序执行的不可预知性</p>
<p>宏观上一气呵成，微观上走走停停</p>
<p>操作系统通过调度算法在各个程序之间进行高速切换</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习记录5</title>
    <url>/2023/07/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</url>
    <content><![CDATA[<h1 id="操作系统的发展："><a href="#操作系统的发展：" class="headerlink" title="操作系统的发展："></a>操作系统的发展：</h1><h3 id="一、手工和批处理阶段："><a href="#一、手工和批处理阶段：" class="headerlink" title="一、手工和批处理阶段："></a>一、手工和批处理阶段：</h3><p>1.1942年2月14日，世界上第一台电子计算机研制成功</p>
<p>2.人工操作方式：用户独占全机；CPU等待人工操作</p>
<p>3.脱机输入&#x2F;输出方式：</p>
<p>减少了CPU的空闲时间</p>
<p>调高了I&#x2F;O速度</p>
<p>但是一次只能执行一个程序</p>
<p>4.批处理阶段：同时处理多道程序</p>
<p>4.1单道批处理系统（OS的前身）：有监督程序</p>
<p>（1）自动性</p>
<p>（2）顺序性</p>
<p>（3）单到性</p>
<p>内存中只有一道程序</p>
<p>CPU需要等待I&#x2F;O完成</p>
<p>4.2多道批处理程序：有调度程序</p>
<p>（1）提高CPU的利用率</p>
<p>（2）可以提高内存和I&#x2F;O设备利用率</p>
<p>（3）提高系统的吞吐量</p>
<p>平均周期运转时间长</p>
<p>无人机交互</p>
<p>单道批处理系统：主要解决CPU、内存和I&#x2F;O设备利用率不足的问题</p>
<p>多道批处理系统：只要解决I&#x2F;O操作时CPU闲置的问题</p>
<h3 id="二、分时操作系统："><a href="#二、分时操作系统：" class="headerlink" title="二、分时操作系统："></a>二、分时操作系统：</h3><p>1.一台主机连接多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源</p>
<p>2.为什么使用分时系统：</p>
<p>人机交互、共享主机、便于用户上机</p>
<p>3.及时接收、及时处理</p>
<p>4.分时系统的特征：</p>
<p>多路性：时间片轮转机制</p>
<p>独立性：用户彼此独立</p>
<p>及时性：用户可以在短时间内获得响应</p>
<p>交互性：用户可以请求多种服务</p>
<p>5.作业&#x2F;用户优先级相同，不能够处理紧急任务</p>
<h3 id="三、实时操作系统："><a href="#三、实时操作系统：" class="headerlink" title="三、实时操作系统："></a>三、实时操作系统：</h3><p>1.系统能够及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行</p>
<p>2.应用需求：</p>
<p>实时控制</p>
<p>实时信息处理</p>
<p>3.特点：</p>
<p>（1）多路性</p>
<p>（2）独立性</p>
<p>（3）及时性：以用户能够接受的等待时间为准</p>
<p>（4）交互性</p>
<p>（5）可靠性：多级容错</p>
<h3 id="四、微机、网络、分布式"><a href="#四、微机、网络、分布式" class="headerlink" title="四、微机、网络、分布式"></a>四、微机、网络、分布式</h3><p>1.单用户，单任务→多用户，多任务</p>
<p>2.网络系统：资源共享、远程通信</p>
<p>3.分布式操作系统：分布性、并行性</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录35</title>
    <url>/2023/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9535/</url>
    <content><![CDATA[<h1 id="RISC技术"><a href="#RISC技术" class="headerlink" title="RISC技术"></a>RISC技术</h1><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>1.RISC：精简指令集计算机</p>
<p>CISC：复杂指令集计算机</p>
<p>2.典型程序中80%的语句仅仅使用处理机中20%的指令</p>
<p>3.执行频率高的简单指令，因为复杂指令的存在，执行速度无法提高</p>
<h3 id="二、RISC的主要特征："><a href="#二、RISC的主要特征：" class="headerlink" title="二、RISC的主要特征："></a>二、RISC的主要特征：</h3><p>1.选用使用频度较高的一些简单指令，复杂指令的功能由简单指令来组合</p>
<p>2.指令长度固定，指令格式种类少，寻址的方式少</p>
<p>3.只用LOAD&#x2F;STORE指令访存</p>
<p>4.CPU中有多个通用寄存器</p>
<p>5.采用流水技术一个时钟周期内完成一条指令</p>
<p>6.采用组合逻辑实现控制器</p>
<h3 id="三、CISC的主要特征："><a href="#三、CISC的主要特征：" class="headerlink" title="三、CISC的主要特征："></a>三、CISC的主要特征：</h3><p>1.系统指令复杂庞大，各种指令使用频度相差大</p>
<p>2.指令长度不固定，指令格式种类多、寻址方式多</p>
<p>3.访存指令不受限制</p>
<p>4.CPU中设有专用寄存器</p>
<p>5.大多数指令需要多个时钟周期</p>
<p>6.采用微程序控制器</p>
<h3 id="四、RISC和CISC的对比："><a href="#四、RISC和CISC的对比：" class="headerlink" title="四、RISC和CISC的对比："></a>四、RISC和CISC的对比：</h3><p>1.RISC更能够充分利用VLSI芯片的面积</p>
<p>2.RISC更能提高计算机的运算速度，便于实现指令流水</p>
<p>3.RISC便于设计，可以降低成本，提高可靠性</p>
<p>4.RISC不易实现指令系统的兼容性</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录36</title>
    <url>/2023/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9536/</url>
    <content><![CDATA[<h1 id="CPU的结构和功能"><a href="#CPU的结构和功能" class="headerlink" title="CPU的结构和功能"></a>CPU的结构和功能</h1><h3 id="一、CPU的结构"><a href="#一、CPU的结构" class="headerlink" title="一、CPU的结构"></a>一、CPU的结构</h3><p>1.CPU的功能：</p>
<p>（1）控制器的功能：取指令；分析指令；执行指令、发出各种操作命令；控制程序输入及结果的输出；总线管理；处理异常情况和特殊请求</p>
<p>（2）运算器的功能：实现算术运算和逻辑运算</p>
<p>指令控制、操作控制、时间控制、处理中断、数据加工</p>
<p>2.CPU的结构框图：</p>
<p><a href="https://imgse.com/i/pCRrFPK"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/10/pCRrFPK.png"
                      alt="pCRrFPK.png"
                ></a></p>
<p>3.CPU的寄存器：</p>
<p>（1）用户可见的寄存器：</p>
<p>1&gt;通用寄存器：存放操作数，可以作为某种寻址方式所需的专用寄存器</p>
<p>2&gt;数据寄存器：存放操作数（满足各种数据类型）两个寄存器拼接存放双倍字节数据</p>
<p>3&gt;地址寄存器：存放地址，其位数应该满足最大的地址范围；用于特殊的寻址方式</p>
<p>4&gt;条件码寄存器：存放条件码，可作为程序分支的依据</p>
<p>（2）控制和状态寄存器</p>
<p>1&gt;控制寄存器：PC→MAR→M→MDR→IR</p>
<p>控制CPU操作</p>
<p>其中MAR、MDR、IR用户不可见；PC用户可见</p>
<p>2&gt;状态寄存器：</p>
<p>状态寄存器：存放条件码</p>
<p>PSW寄存器：存放程序状态字</p>
<p>4.控制单元CU和中断系统：</p>
<p>CU产生全部指令的微操作命令序列</p>
<p>CU有组合逻辑设计（硬连线逻辑）和微程序设计（存储逻辑）</p>
<p>5.ALU（算术逻辑单元）：一种可对二进制整数执行算术运算或位运算的组合逻辑数字电路 </p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录37</title>
    <url>/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9537/</url>
    <content><![CDATA[<h1 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h1><h3 id="一、指令周期的基本概念："><a href="#一、指令周期的基本概念：" class="headerlink" title="一、指令周期的基本概念："></a>一、指令周期的基本概念：</h3><p>1.指令周期：取出一条指令所需要的全部时间</p>
<p>2.完成一条指令：取指令、分析（取指令周期）；执行周期（执行周期）</p>
<p>3.<a href="https://imgse.com/i/pCWQhEd"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/11/pCWQhEd.png"
                      alt="pCWQhEd.png"
                ></a></p>
<p>4.每一条指令的指令周期不同：</p>
<p>5.具有间接寻址的指令周期：</p>
<p><a href="https://imgse.com/i/pCWQ54I"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/11/pCWQ54I.png"
                      alt="pCWQ54I.png"
                ></a></p>
<p>6.具有中断周期的指令周期：</p>
<p><a href="https://imgse.com/i/pCWQT8P"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/11/pCWQT8P.png"
                      alt="pCWQT8P.png"
                ></a></p>
<p>7.指令周期的流程：</p>
<p><a href="https://imgse.com/i/pCWQHv8"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/11/pCWQHv8.png"
                      alt="pCWQHv8.png"
                ></a></p>
<p>8.CPU工作周期的标志：</p>
<p>（1）CPU访存有四种性质：</p>
<p>取指令 （取址周期）</p>
<p>取地址 （间址周期）</p>
<p>存取 操作数或结果 （执行周期）</p>
<p>存 程序断点 （间断周期）</p>
<p><a href="https://imgse.com/i/pCWQqKS"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/11/pCWQqKS.png"
                      alt="pCWQqKS.png"
                ></a></p>
<h3 id="二、指令周期的数据流："><a href="#二、指令周期的数据流：" class="headerlink" title="二、指令周期的数据流："></a>二、指令周期的数据流：</h3><p>1.取址周期数据流：</p>
<p><a href="https://imgse.com/i/pCWlyIs"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/11/pCWlyIs.png"
                      alt="pCWlyIs.png"
                ></a></p>
<p>2.间址周期数据流：</p>
<p><a href="https://imgse.com/i/pCWlcin"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/11/pCWlcin.png"
                      alt="pCWlcin.png"
                ></a></p>
<p>3.执行周期数据流：</p>
<p>不同指令的执行周期数据流不同</p>
<p>4.中断周期数据流：</p>
<p><a href="https://imgse.com/i/pCWlfMT"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/11/pCWlfMT.png"
                      alt="pCWlfMT.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习记录6</title>
    <url>/2023/07/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956/</url>
    <content><![CDATA[<h1 id="操作系统运行机制"><a href="#操作系统运行机制" class="headerlink" title="操作系统运行机制"></a>操作系统运行机制</h1><h3 id="一、时钟管理："><a href="#一、时钟管理：" class="headerlink" title="一、时钟管理："></a>一、时钟管理：</h3><p>1.内核程序———–应用程序</p>
<p>2.核心态———–用户态</p>
<p>3.特权指令———–非特权指令</p>
<p>4.时钟的功能：</p>
<p>（1）计时：提供系统时间</p>
<p>（2）时钟中断：进程切换</p>
<h3 id="二、中断："><a href="#二、中断：" class="headerlink" title="二、中断："></a>二、中断：</h3><p>1.中断机制：提高多道程序环境下CPU利用率</p>
<p>2.外中断：中断信号来源于外部设备</p>
<p>3.内中断：中断信号来源于当前指令，内中断也叫作异常&#x2F;陷入&#x2F;例外</p>
<p>内中断的三种情况：</p>
<p>陷阱（Trap）：由应用程序主动引发</p>
<p>故障（fault）：由错误条件引发</p>
<p>终止（abort）：由致命错误引发</p>
<p>4.中断处理的过程：</p>
<p>产生中断后：</p>
<p>（1）关中断：CPU不再响应更高级的中断请求 </p>
<p>（2）保存断点</p>
<p>（3）引出中断服务程序</p>
<p>（4）保存现场和屏蔽字</p>
<p>（5）开中断</p>
<p>（6）执行中断服务程序</p>
<p>（7）关中断</p>
<p>（8）恢复现场和屏蔽字</p>
<p>（9）开中断</p>
<h3 id="三、原语："><a href="#三、原语：" class="headerlink" title="三、原语："></a>三、原语：</h3><p>1.原语是一个程序段，由若干条指令组成，用来完成某个特定功能，执行过程不会被中断</p>
<p>2.原语具有原子性</p>
<p>3.原语运行在内核空间</p>
<h3 id="四、系统数据结构："><a href="#四、系统数据结构：" class="headerlink" title="四、系统数据结构："></a>四、系统数据结构：</h3><p>1.进程管理：作业控制块，进程控制块</p>
<p>2.存储器管理：存储器分配与回收</p>
<p>3.设备管理：缓冲区、设备控制块</p>
<p>一般只涉及对数据结构的操作，不涉及硬件</p>
<h3 id="五、系统调用："><a href="#五、系统调用：" class="headerlink" title="五、系统调用："></a>五、系统调用：</h3><p>1.系统调用是应用程序访问系统内核功能调用系统内核功能的过程</p>
<p>2.由操作系统实现，给应用程序调用</p>
<p>3.是应用程序访问内核服务的方式</p>
<p>4.系统调用通过陷入指令来访问系统内核</p>
<p>5.系统调用的处理运行在核心态</p>
<p>6.<strong>陷入指令是特殊指令，但不是特权指令</strong></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录38</title>
    <url>/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9538/</url>
    <content><![CDATA[<h1 id="指令流水"><a href="#指令流水" class="headerlink" title="指令流水"></a>指令流水</h1><h3 id="一、如何提高机器速度："><a href="#一、如何提高机器速度：" class="headerlink" title="一、如何提高机器速度："></a>一、如何提高机器速度：</h3><p>1.提高访存速度：高速芯片、Cache、多体并行</p>
<p>2.提高I&#x2F;O和主机之间的传送速度：中断、DMA、通道、I&#x2F;O处理机、多总线</p>
<p>3.提高运算器速度：高速芯片、改进算法、快速进位链</p>
<p>4.为了调高整机的处理能力，除了采用高速部件，还可以改进系统结构，开发系统的并行性</p>
<h3 id="二、系统的并行性："><a href="#二、系统的并行性：" class="headerlink" title="二、系统的并行性："></a>二、系统的并行性：</h3><p>1.并行：</p>
<p>并发：两个或两个以上的事件在同一时间段发生</p>
<p>同时：两个或两个以上的事件在同一时刻发生</p>
<p>2.并行性的等级：</p>
<p>过程级（程序、进程）是粗粒度的，可以用软件实现</p>
<p>指令级（指令之间、指令内部）是细粒度的，用硬件实现</p>
<h3 id="三、指令流水原理："><a href="#三、指令流水原理：" class="headerlink" title="三、指令流水原理："></a>三、指令流水原理：</h3><p>1.指令的串行执行：</p>
<p>在取指令时只会用到取指令部件，在执行指令时只会用到执行指令部件，总有一个部件空闲</p>
<p>2.指令的二级流水：</p>
<p><a href="https://imgse.com/i/pChdcKH"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/13/pChdcKH.png"
                      alt="pChdcKH.png"
                ></a></p>
<p>若取指和执行阶段时间上完全重叠，指令周期减半，速度提高一倍（理性情况下）</p>
<p>3.影响指令流水效率加倍的因素：</p>
<p>（1）执行时间  &gt;  取址时间</p>
<p>解决方案：</p>
<p><a href="https://imgse.com/i/pChdgrd"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/13/pChdgrd.png"
                      alt="pChdgrd.png"
                ></a></p>
<p>（2）条件转移指令对指令流水的影响：</p>
<p>必须等上条指令执行结束，才能确定下条指令的地址</p>
<p>造成时间的损失</p>
<p>解决方案：猜测法</p>
<h3 id="四、影响指令流水线性能的因素："><a href="#四、影响指令流水线性能的因素：" class="headerlink" title="四、影响指令流水线性能的因素："></a>四、影响指令流水线性能的因素：</h3><p>1.结构相关：不同的指令争用同一功能部件造成资源冲突</p>
<p>解决方案：</p>
<p>（1）停顿</p>
<p>（2）指令存储器和数据存储器分开</p>
<p>（3）指令预取技术（适用于访存周期短的情况）</p>
<p>2.数据相关：不同指令因为重叠操作，可能改变操作数的读&#x2F;写访问顺序</p>
<p>（1）写后读相关（RAW）</p>
<p>（2）读后写相关（WAR）</p>
<p>（3）写后写相关（WAW）</p>
<p>3.控制相关：由转移指令引起</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录39</title>
    <url>/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9539/</url>
    <content><![CDATA[<h1 id="指令流水"><a href="#指令流水" class="headerlink" title="指令流水"></a>指令流水</h1><h3 id="一、流水线的性能指标："><a href="#一、流水线的性能指标：" class="headerlink" title="一、流水线的性能指标："></a>一、流水线的性能指标：</h3><p>1.吞吐率：单位时间内流水线完成指令或输出结果的数量</p>
<p>最大吞吐率</p>
<p>实际吞吐率</p>
<p><a href="https://imgse.com/i/pChU2Se"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/13/pChU2Se.png"
                      alt="pChU2Se.png"
                ></a></p>
<p>2.加速比Sp：m段流水线的速度与等功能的非流水线的速度之比</p>
<p><a href="https://imgse.com/i/pChUfOA"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/13/pChUfOA.png"
                      alt="pChUfOA.png"
                ></a></p>
<p>3.效率：流水线各功能段的利用率</p>
<p>由于流水线有建立时间和排空时间，因此各功能段的设备不可能一直处于工作状态</p>
<p><a href="https://imgse.com/i/pChUTFf"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/13/pChUTFf.png"
                      alt="pChUTFf.png"
                ></a></p>
<p>效率的计算：</p>
<p><a href="https://imgse.com/i/pChULlQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/13/pChULlQ.png"
                      alt="pChULlQ.png"
                ></a></p>
<h3 id="二、流水线的多发技术："><a href="#二、流水线的多发技术：" class="headerlink" title="二、流水线的多发技术："></a>二、流水线的多发技术：</h3><p>1.超标量技术：</p>
<p>每个时钟周期内可以并发多条独立指令，配置多个功能部件</p>
<p>不能调整指令的执行顺序，通过编译优化技术，把	可并行执行的指令搭配起来</p>
<p>2.超流水线技术：</p>
<p>在一个时钟周期内再分段（3段）</p>
<p>在一个时钟周期内一个功能部件使用多次（3次）</p>
<p>不同的指令处在同一个流水段中，相互之间的信号不能叠加</p>
<p>不能调整指令的执行顺序，靠编译程序解决优化问题</p>
<p>3.超长指令字技术：</p>
<p>由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作字码的超长指令字（可达几百位）</p>
<p>采用多个处理部件</p>
<h3 id="三、流水线结构："><a href="#三、流水线结构：" class="headerlink" title="三、流水线结构："></a>三、流水线结构：</h3><p>1.指令流水线结构：完成一条指令分6段，每段需要一个时钟周期</p>
<p><a href="https://imgse.com/i/pChapkV"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/13/pChapkV.png"
                      alt="pChapkV.png"
                ></a></p>
<p>若流水线不出现断流 则 1 个时钟周期出 1 个结果</p>
<p>不采用流水线的话 则 6 个时钟周期出 1 个结果</p>
<p>理想情况下，6级流水的速度是不采用流水技术的6倍</p>
<p>2.运算流水线：完成浮点数加减运算可以分为对阶、尾数求和、规格化三段</p>
<p>分段原则：每段操作时间尽量一致</p>
<p><a href="https://imgse.com/i/pChUzT0"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/13/pChUzT0.png"
                      alt="pChUzT0.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录40</title>
    <url>/2023/07/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9540/</url>
    <content><![CDATA[<h1 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h1><h3 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h3><p>1.引起中断的各种因素：</p>
<p>（1）人为设置的中断：如转管指令</p>
<p><a href="https://imgse.com/i/pC4TAyQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/14/pC4TAyQ.png"
                      alt="pC4TAyQ.png"
                ></a></p>
<p>（2）程序性事故：溢出、操作码不能识别、除法非法</p>
<p>（3）硬件故障</p>
<p>（4）I&#x2F;O设备</p>
<p>（5）外部事件：如用键盘中断现行的程序</p>
<h3 id="二、中断请求标记和中断判优逻辑"><a href="#二、中断请求标记和中断判优逻辑" class="headerlink" title="二、中断请求标记和中断判优逻辑"></a>二、中断请求标记和中断判优逻辑</h3><p>1.中断请求标记 INTR</p>
<p>一个请求源：一个INTR中断请求标记触发器</p>
<p>多个INTR组成中断请求标记寄存器</p>
<p>2.INTR分散在各个中断源的接口电路中</p>
<p>3.INTR集中在	CPU的中断系统内</p>
<p>4.<strong>中断判优逻辑</strong>：</p>
<p>（1）硬件实现（排队器）：</p>
<p>将排队器分散在各个中断源的接口电路中（链式排队器）</p>
<p>也可以集中在CPU中</p>
<p>排队器的输出中只有一位是1</p>
<p>（2）软件实现（程序查询）</p>
<p><a href="https://imgse.com/i/pC4TuF0"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/14/pC4TuF0.png"
                      alt="pC4TuF0.png"
                ></a></p>
<h3 id="三、中断服务程序入口地址的寻找："><a href="#三、中断服务程序入口地址的寻找：" class="headerlink" title="三、中断服务程序入口地址的寻找："></a>三、中断服务程序入口地址的寻找：</h3><p>1.硬件向量法：中断向量地址</p>
<p>2.软件查询法：执行中断识别程序</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录41</title>
    <url>/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9541/</url>
    <content><![CDATA[<h1 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h1><h3 id="一、中断响应："><a href="#一、中断响应：" class="headerlink" title="一、中断响应："></a>一、中断响应：</h3><p>1.响应中断的条件：允许中断触发器 EINT&#x3D;1</p>
<p>2.响应中断的时间：指令执行周期结束以后由CPU发查询信号</p>
<p><a href="https://imgse.com/i/pCougUg"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/17/pCougUg.png"
                      alt="pCougUg.png"
                ></a></p>
<p>3.中断隐指令：</p>
<p>（1）保护程序断点：断点存于特定的地址中（0号地址），断点进栈</p>
<p>（2）寻找服务程序入口程序：向量地址——&gt;PC（硬件向量法）</p>
<p>中断识别程序入口地址M—–&gt; PC（软件查询法）</p>
<p>（3）硬件关中断</p>
<p>中断隐指令不是计算机指令集中的一条指令</p>
<h3 id="二、保护现场和恢复现场："><a href="#二、保护现场和恢复现场：" class="headerlink" title="二、保护现场和恢复现场："></a>二、保护现场和恢复现场：</h3><p>1.保护现场：断点（中断隐指令完成）</p>
<p>​                      寄存器内容（中断服务程序完成）</p>
<p>2.恢复现场：中断服务程序完成</p>
<p><a href="https://imgse.com/i/pCouWCj"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/17/pCouWCj.png"
                      alt="pCouWCj.png"
                ></a></p>
<h3 id="三、多重中断："><a href="#三、多重中断：" class="headerlink" title="三、多重中断："></a>三、多重中断：</h3><p>1.<a href="https://imgse.com/i/pCou25Q"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/17/pCou25Q.png"
                      alt="pCou25Q.png"
                ></a></p>
<p>2.实现多重中断的条件：</p>
<p>（1）提前设置开中断指令</p>
<p>（2）优先级别高的中断源有权中断优先级别低的中断源</p>
<p>3.中断屏蔽技术：</p>
<p>（1）屏蔽触发器的作用：保存中断屏蔽字</p>
<p>MASK&#x3D;0（未屏蔽）</p>
<p>MASK&#x3D;1（屏蔽）</p>
<p>（2）屏蔽技术可改变处理优先等级</p>
<p>响应优先级：不可改变</p>
<p>处理优先级：可以改变（通过重新设置屏蔽字）</p>
<p>设置中断屏蔽字：</p>
<p><a href="https://imgse.com/i/pCoucVS"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/17/pCoucVS.png"
                      alt="pCoucVS.png"
                ></a></p>
<p>4.多重中断的断点保护：</p>
<p>（1）断点进栈：中断隐指令完成</p>
<p>（2）断点存入“0”地址：中断隐指令完成</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录42</title>
    <url>/2023/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9542/</url>
    <content><![CDATA[<h1 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a>控制单元</h1><h3 id="一、微操作命令的分析："><a href="#一、微操作命令的分析：" class="headerlink" title="一、微操作命令的分析："></a>一、微操作命令的分析：</h3><p>1.微操作命令：指令解释的过程中由控制单元发出的一些指令</p>
<p>2.完成一条指令分为四个周期：</p>
<p>（1）取址周期</p>
<p>（2）间址周期</p>
<p>（3）执行周期</p>
<p>（4）中断周期</p>
<p>3.取址周期的微操作：</p>
<p>PC—–&gt;MAR—–&gt;地址线</p>
<p>1—–&gt;R</p>
<p>M(MAR)—–&gt;MDR</p>
<p>OP(IR)—–&gt;CU</p>
<p>PC+1—–&gt;PC</p>
<p>4.间址周期的微操作：</p>
<p>指令形式地址—–&gt;MAR</p>
<p>Ad(IR)—–&gt;MAR</p>
<p>1—–&gt;R  (读操作命令)</p>
<p>M(MAR)—–&gt;MDR</p>
<p>MDR—–&gt;Ad(IR)</p>
<p>5.执行周期的微操作：</p>
<p> 5.1非访存类的指令</p>
<p>（1）CLA 清A     0—–&gt;ACC</p>
<p>（2）COM 取反   ACC的反—–&gt;ACC</p>
<p>（3）SHR 算术右移   L(ACC)—–&gt;R(ACC),     ACCo—–&gt;ACCo</p>
<p>（4）CSL  循环左移   R(ACC)—–&gt;L(ACC),     ACCo—–&gt;ACCo</p>
<p>（5）STP  停机指令    0—–&gt;G</p>
<p> 5.2访存指令</p>
<p>（1）加法指令</p>
<p>ADD X：</p>
<p>Ad(IR)—–&gt;MAR</p>
<p>1—–&gt;R</p>
<p>M(MAR)—–&gt;MDR</p>
<p>(ACC)+(MDR)—–&gt;ACC</p>
<p>（2）存数指令</p>
<p>STA X：</p>
<p>Ad(IR)—–&gt;MAR</p>
<p>1—–&gt;W</p>
<p>ACC—–&gt;MDR</p>
<p>MDR—–&gt;M(MAR)</p>
<p>（3）取数指令</p>
<p>LDA X:</p>
<p>Ad(IR)—–&gt;MAR</p>
<p>1—–&gt;R</p>
<p>M(MAR)—–&gt;MDR</p>
<p>MDR—–&gt;ACC</p>
<p> 5.3转移指令</p>
<p>（1）无条件转 </p>
<p>JMP X：</p>
<p>Ad(IR)—–&gt;PC</p>
<p>（2）条件转移</p>
<p>BAN X:     (负则转)</p>
<p>6.三类指令的指令周期：</p>
<p><a href="https://imgse.com/i/pCHw18s"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/20/pCHw18s.png"
                      alt="pCHw18s.png"
                ></a></p>
<p>7.中断周期：</p>
<p>程序断点存入“0”地址：</p>
<p>0—–&gt;MAR</p>
<p>1—–&gt;W</p>
<p>PC—–&gt;MDR</p>
<p>MDR—–&gt;M(MAR)</p>
<p>向量地址—–&gt;PC</p>
<p>0—–&gt;EINT(置“0”)</p>
<p>程序断点进栈：</p>
<p>(SP) -1 —–&gt;MAR</p>
<p>1—–&gt;W</p>
<p>PC—–&gt;MDR</p>
<p>MDR—–&gt;M(MAR)</p>
<p>向量地址—–&gt;PC</p>
<p>0—–&gt;EINT(置“0”)</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录43</title>
    <url>/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9543/</url>
    <content><![CDATA[<h1 id="控制单元的功能"><a href="#控制单元的功能" class="headerlink" title="控制单元的功能"></a>控制单元的功能</h1><h3 id="一、控制单元的外特性："><a href="#一、控制单元的外特性：" class="headerlink" title="一、控制单元的外特性："></a>一、控制单元的外特性：</h3><p>1.输入信号：</p>
<p>（1）时钟</p>
<p>CU受时钟控制</p>
<p>一个时钟脉冲发一个操作命令或一组需要同时执行的操作命令</p>
<p>（2）指令寄存器   OP(IR)—–&gt;CU</p>
<p>控制信号与操作码有关</p>
<p>（3）标志</p>
<p>CU受标志控制</p>
<p>（4）外来信号</p>
<p>如   INTR 中断请求</p>
<p>​       HRQ 总线请求</p>
<p>2.输出信号：</p>
<p>（1）CPU内的各种控制信号</p>
<p>（2）送至控制总线的信号：访存控制信号、读命令、写命令	、中断响应信号、总线响应信号、访I&#x2F;O存储器的控制信号</p>
<h3 id="二、控制信号举例："><a href="#二、控制信号举例：" class="headerlink" title="二、控制信号举例："></a>二、控制信号举例：</h3><p>1.不采用CPU内部总线方式</p>
<p>（1）取址周期：</p>
<p><a href="https://imgse.com/i/pCbumCD"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/21/pCbumCD.png"
                      alt="pCbumCD.png"
                ></a></p>
<p>（2）间址周期：</p>
<p><a href="https://imgse.com/i/pCbuKvd"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/21/pCbuKvd.png"
                      alt="pCbuKvd.png"
                ></a></p>
<p>（3）执行周期：</p>
<p><a href="https://imgse.com/i/pCbu1bt"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/21/pCbu1bt.png"
                      alt="pCbu1bt.png"
                ></a></p>
<p>2.采用CPU内部总线方式</p>
<p><a href="https://imgse.com/i/pCbuJ58"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/21/pCbuJ58.png"
                      alt="pCbuJ58.png"
                ></a></p>
<h3 id="三、多级时序系统："><a href="#三、多级时序系统：" class="headerlink" title="三、多级时序系统："></a>三、多级时序系统：</h3><p>1机器周期：</p>
<p>（1）机器周期：所有指令执行过程中的一个基准时间</p>
<p>（2）确定机器周期所需考虑的因素：</p>
<p>每条指令的执行步骤</p>
<p>每一个步骤所需要的时间</p>
<p>（3）基准时间的确定：以完成最复杂指令功能的时间为例</p>
<p>以访问一次寄存器的时间为基准</p>
<p>若指令字长&#x3D;存储字长，则取址周期&#x3D;机器周期</p>
<p>2.时钟周期：</p>
<p>（1）时钟周期：一个机器周期内可以完成若干个微操作，每个微操作需要一定的时间，将一个机器周期划分为若干个时间相等的时间段（节拍、状态、时钟周期）</p>
<p>（2）<strong>时钟周期是控制计算机操作的最小单位时间</strong></p>
<p>（3）用时钟周期控制产生一个或几个微操作命令</p>
<p>3.机器周期、节拍（状态）组成多级时序系统</p>
<p>一个指令周期包含若干个机器周期</p>
<p>一个机器周期包含了若干个时钟周期</p>
<p>4.机器的主频f越快机器的速度也越快</p>
<p>在机器周期所含的时钟周期相同的前提下，两机平均指令执行速度之比等于两机主频之比</p>
<p>5.机器速度不仅与主频有关，还与机器周期中所含的时钟周期数以及指令周期中所含的机器周期数有关</p>
<h3 id="四、控制方式："><a href="#四、控制方式：" class="headerlink" title="四、控制方式："></a>四、控制方式：</h3><p>产生不同微操作命令序列所用的时序控制方式</p>
<p>1.同步控制方式：任一微操作均由统一基准时标的时序信号控制</p>
<p>采用定长的机器周期</p>
<p>采用不定长的机器周期：机器周期内节拍数不等</p>
<p>采用中央控制和局部控制结合的方式：局部控制节拍宽度和中央控制的节拍宽度一致</p>
<p>2.异步控制方式：无基准时标信号，无固定的周期节拍和严格的时钟同步，采用应答方式</p>
<p>3.联合控制方式：同步与异步控制方式结合</p>
<p>4.人工控制方式：Reset，连续和单条指令执行转换开关、符合停机开关</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录44</title>
    <url>/2023/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9544/</url>
    <content><![CDATA[<h1 id="组合逻辑设计"><a href="#组合逻辑设计" class="headerlink" title="组合逻辑设计"></a>组合逻辑设计</h1><h3 id="一、组合逻辑控制单元框图："><a href="#一、组合逻辑控制单元框图：" class="headerlink" title="一、组合逻辑控制单元框图："></a>一、组合逻辑控制单元框图：</h3><p>1.CU外特性</p>
<p><a href="https://imgse.com/i/pCqKU4f"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/22/pCqKU4f.png"
                      alt="pCqKU4f.png"
                ></a></p>
<h3 id="二、微操作的节拍安排："><a href="#二、微操作的节拍安排：" class="headerlink" title="二、微操作的节拍安排："></a>二、微操作的节拍安排：</h3><p>1.采用同步控制方式</p>
<p>2.一个机器周期内有多个节拍</p>
<p>3.CPU内部结构采用非总线的方式</p>
<p>4.安排微操作时序的原则：</p>
<p>（1）微操作的先后顺序不能随意修改</p>
<p>（2）被控对象不同的微操作尽量安排在一个节拍内</p>
<p>（3）占用时间较短的微操作尽量安排在一个节拍内完成，并允许有先后顺序</p>
<p>5.取指周期的微操作的节拍安排：</p>
<p>T0     PC—–&gt;MAR</p>
<p>​	 1—–&gt;R</p>
<p>T1     M(MAR)—–&gt;MDR</p>
<p>​	 (PC)+1—–&gt;PC</p>
<p>T2     MDR—–&gt;IR</p>
<p>​	 OP(IR)—–&gt;ID</p>
<p>6.间址周期微操作的节拍安排：</p>
<p>T0     Ad(IR)——&gt;MAR</p>
<p>​	 1—–&gt;R</p>
<p>T1     M(MAR)—–&gt;MDR</p>
<p>T2     MDR—–&gt;Ad(IR)</p>
<p>7.执行周期微操作的节拍安排：</p>
<p>（1）CLK</p>
<p>T0</p>
<p>T1</p>
<p>T2     0—–&gt;AC</p>
<p>（2）COM(取反指令)</p>
<p>T0</p>
<p>T1</p>
<p>T2     AC非—–&gt;AC</p>
<p>（3）SHR(逻辑右移)</p>
<p>T0</p>
<p>T1</p>
<p>T2     L(AC)—–&gt;R(AC)</p>
<p>​	 AC0—–&gt;AC0</p>
<p>（4）CSL(循环左移)</p>
<p>T0</p>
<p>T1</p>
<p>T2     R(AC)—–&gt;L(AC)     AC0—–&gt;ACn</p>
<p>（5）STP(停机指令)</p>
<p>T0</p>
<p>T1</p>
<p>T2     0—–&gt;G</p>
<p>（6）ADD X</p>
<p>T0     Ad(IR)—–&gt;MAR     1—–&gt;R</p>
<p>T1     M(MAR)—–&gt;MDR</p>
<p>T2     (AC)+(MDR)—–&gt;AC</p>
<p>（7）STA X(将累加器中保存的数据存入给定的存储单元，存储单元的地址是X)</p>
<p>T0     Ad(IR)—–&gt;MAR     1—–&gt;W</p>
<p>T1     AC—–&gt;MDR</p>
<p>T2     MDR—–&gt;M(MAR)</p>
<p>（8）LDA X(将地址为X的内存单元保存的数据取出，保存在CPU中，放在累加器)</p>
<p>T0     Ad(IR)—–&gt;MAR     1—–&gt;R</p>
<p>T1     M(MAR)—–&gt;MDR</p>
<p>T2     MDR—–&gt;AC</p>
<p>（9）JMP X(跳转指令)</p>
<p>T0</p>
<p>T1</p>
<p>T2     Ad(IR)—–&gt;PC</p>
<p>（10）BAN X(条件跳转指令，计算结果小于0，跳转到X)</p>
<p>T0</p>
<p>T1</p>
<p>T2     A0*Ad(IR) + A0非 * PC—–&gt;PC</p>
<p>8.中断周期的微操作节拍安排：</p>
<p>T0     0—–&gt;MAR     1—–&gt;W    (硬件关中断)</p>
<p>T1     PC—–&gt;MDR</p>
<p>T2     MDR—–&gt;M(MAR)     向量地址—–&gt;PC</p>
<p>由中断隐指令完成</p>
<h3 id="三、组合逻辑设计步骤："><a href="#三、组合逻辑设计步骤：" class="headerlink" title="三、组合逻辑设计步骤："></a>三、组合逻辑设计步骤：</h3><p>1.列出操作时间表</p>
<p>2.写出微操作命令的最简表达式</p>
<p>3.画出逻辑图</p>
<p>4.特点：</p>
<p>（1）思路清晰，简单明了</p>
<p>（2）庞杂，调试困难，修改困难</p>
<p>（3）速度快（RISC）</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录45</title>
    <url>/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9545/</url>
    <content><![CDATA[<h1 id="微程序设计"><a href="#微程序设计" class="headerlink" title="微程序设计"></a>微程序设计</h1><h3 id="一、微程序思想的产生："><a href="#一、微程序思想的产生：" class="headerlink" title="一、微程序思想的产生："></a>一、微程序思想的产生：</h3><p>1.1951由英国Wilkes提出</p>
<p>2.完成一条机器指令由若干个微操作命令组成</p>
<p>3.一条机器指令对应一个微程序</p>
<p>4.将微指令存入ROM中（存储逻辑）</p>
<h3 id="二、微程序控制单元框图以及工作原理："><a href="#二、微程序控制单元框图以及工作原理：" class="headerlink" title="二、微程序控制单元框图以及工作原理："></a>二、微程序控制单元框图以及工作原理：</h3><p>1.机器指令对应的微程序：</p>
<p><a href="https://imgse.com/i/pCLpJaj"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/23/pCLpJaj.png"
                      alt="pCLpJaj.png"
                ></a></p>
<p>2.微程序控制单元的基本框图：</p>
<p><a href="https://imgse.com/i/pCLpUGq"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/23/pCLpUGq.png"
                      alt="pCLpUGq.png"
                ></a></p>
<h3 id="三、工作原理："><a href="#三、工作原理：" class="headerlink" title="三、工作原理："></a>三、工作原理：</h3><p>1.取指阶段：执行取值微程序</p>
<p>M—–&gt;CMAR</p>
<p>CM(CMAR)—–&gt;CMDR</p>
<p>由CMDR发命令</p>
<p>形成下条微指令地址     M+1</p>
<p>Ad(CMDR)—–&gt;CMAR</p>
<p>CM(CMAR)—–&gt;CMDR</p>
<p>由CMDR发命令</p>
<p>形成下条微指令地址     M+2</p>
<p>Ad(CMDR)—–&gt;CMAR</p>
<p>CM(CMAR)—–&gt;CMDR</p>
<p>由CMDR发命令</p>
<p>2.执行阶段：执行LDA微程序</p>
<p>OP(IR)—–&gt;微地址形成部件—–&gt;CMAR</p>
<p>CM(CMAR)—–&gt;CMDR</p>
<p>由CMDR发命令</p>
<p>形成下条微指令地址吧    P+1</p>
<p>Ad(CMDR)—–&gt;CMAR</p>
<p>CM(CMAR)—–&gt;CMDR</p>
<p>由CMDR发命令</p>
<p>形成下条微指令地址吧    P+2</p>
<p>Ad(CMDR)—–&gt;CMAR</p>
<p>CM(CMAR)—–&gt;CMDR</p>
<p>由CMDR发命令</p>
<p>Ad(CMDR)—–&gt;CMAR</p>
<p>3.取指阶段：执行取指微程序</p>
<p>M—–&gt;CMAR</p>
<p>CM(CMAR)—–&gt;CMDR</p>
<p>由CMDR发命令</p>
<p>4.全部微指令存在CM中，程序执行过程中只需读出</p>
<h3 id="四、微指令的编码方式："><a href="#四、微指令的编码方式：" class="headerlink" title="四、微指令的编码方式："></a>四、微指令的编码方式：</h3><p>1.直接编码（直接控制）方式：在微指令的操作控制字段中，每一位代表一个微操作方式</p>
<p>2.字段直接编码方式：将微指令的控制字段分成若干“段”，每段经过译码后发出控制信号。</p>
<p>每个字段中的命令是互斥的，缩短了微指令字长，增加了译码时间</p>
<p>微程序执行的速度较慢</p>
<p>3.字段间接编码</p>
<p>4.混合编码</p>
<p>5.其他</p>
<h3 id="五、微指令序列地址的形成："><a href="#五、微指令序列地址的形成：" class="headerlink" title="五、微指令序列地址的形成："></a>五、微指令序列地址的形成：</h3><p>1.微指令的下地址字段指出</p>
<p>2.根据机器指令的操作码形成</p>
<p>3.增量计数器</p>
<p>4.分支转移：</p>
<p>转移方式指明判别条件</p>
<p>转移地址指明转移成功后的去向</p>
<p>5.通过测试网络</p>
<p>6.由硬件产生微程序的入口地址：</p>
<p>第一条微指令地址由专门的硬件产生</p>
<p>中断周期由硬件产生中断周期微程序首地址</p>
<h3 id="六、微指令格式："><a href="#六、微指令格式：" class="headerlink" title="六、微指令格式："></a>六、微指令格式：</h3><p>1.水平型微指令：一次能定义并执行多个并行操作</p>
<p>如直接编码、字段直接编码、字段间接编码、直接和字段混合编码</p>
<p>2.垂直型微指令：类似机器指令操作码的方式</p>
<p>3.两种微指令格式比较：</p>
<p>（1）水平型微指令比垂直型微指令并行操作能力强</p>
<p>灵活性强</p>
<p>（2）水平型微指令执行一条机器指令所要的微指令数目少，速度快</p>
<p>（3）水平型微指令用较短的微程序结构换取较长的微指令结构</p>
<h3 id="七、静态微程序设计和动态微程序设计："><a href="#七、静态微程序设计和动态微程序设计：" class="headerlink" title="七、静态微程序设计和动态微程序设计："></a>七、静态微程序设计和动态微程序设计：</h3><p>1.静态：微程序无需改变，采用ROM</p>
<p>2.动态：通过改变微指令和微指令改变机器指令，有利于仿真，采用EPROM</p>
<h3 id="八、毫微程序设计："><a href="#八、毫微程序设计：" class="headerlink" title="八、毫微程序设计："></a>八、毫微程序设计：</h3><p>1.毫微程序设计用毫微程序解释微程序</p>
<p>2.毫微程序控制器的基本组成：</p>
<p><a href="https://imgse.com/i/pCLpdzV"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/23/pCLpdzV.png"
                      alt="pCLpdzV.png"
                ></a></p>
<h3 id="九、串行微程序控制和并行微程序控制："><a href="#九、串行微程序控制和并行微程序控制：" class="headerlink" title="九、串行微程序控制和并行微程序控制："></a>九、串行微程序控制和并行微程序控制：</h3><p>1.串行微程序控制：</p>
<p><a href="https://imgse.com/i/pCLpoee"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/23/pCLpoee.png"
                      alt="pCLpoee.png"
                ></a></p>
<p>2.并行微程序控制：</p>
<p><a href="https://imgse.com/i/pCLpqJI"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/23/pCLpqJI.png"
                      alt="pCLpqJI.png"
                ></a></p>
<h3 id="十、微程序设计举例："><a href="#十、微程序设计举例：" class="headerlink" title="十、微程序设计举例："></a>十、微程序设计举例：</h3><p>1.写出对应机器指令的微操作及节拍安排</p>
<p>2.确定微指令格式</p>
<p>（1）微指令的编码方式</p>
<p>（2）后续微指令的地址形成方式</p>
<p>（3）微指令字长</p>
<p>（4）微指令字长的确定</p>
<p>（5）省去了CMAR的控制存储器：</p>
<p><a href="https://imgse.com/i/pCLpxOS"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/23/pCLpxOS.png"
                      alt="pCLpxOS.png"
                ></a></p>
<p>（6）定义微指令操作控制字段每一位的微操作</p>
<p>3.编写微指令的码点</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录7</title>
    <url>/2023/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%957/</url>
    <content><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="一、树的定义和基本术语："><a href="#一、树的定义和基本术语：" class="headerlink" title="一、树的定义和基本术语："></a>一、树的定义和基本术语：</h3><p>1.树是n个节点的有限集合，当n&#x3D;0时，为空树；n不为0时，为非空树。</p>
<p>2.任意的非空的树，满足以下的两个条件：</p>
<p>（1）有且仅有一个称为根的节点</p>
<p>（2）除了根节点之外，其余节点可以分为m个互不相交的有限集合，每一个集合本身又是一个树，称为根节点的子树</p>
<p>3.相关的术语：</p>
<p>（1）节点：包含数据元素和指向子树的分支信息</p>
<p>（2）节点的度：节点拥有的子树的个数</p>
<p>（3）树的度：树中节点的最大度数</p>
<p>（4）终端节点：度为0的节点，又称为叶子节点</p>
<p>（5）分支节点：度大于0的节点，除了叶子节点以外，都是分支节点</p>
<p>（6）内部节点：除了根节点和叶子节点之外，都是内部节点</p>
<p>4.树形结构是一对多的关系，树是一种递归定义的结构</p>
<p>5.除了根节点之外，任何一个节点有且仅有一个前驱，每个节点可以有0个或多个后继</p>
<p>6.树的链式存储结构：</p>
<p>（1）采用邻接表，将节点的所有孩子存储在一个单链表中</p>
<p>（2）采用二叉链表，左指针存储第一个孩子，右指针存储右兄弟</p>
<p>7.有序树：各个子树从左到右是有次序的</p>
<p>8.森林：由m棵互不相交的树的集合</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录8</title>
    <url>/2023/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%958/</url>
    <content><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="一、树的性质："><a href="#一、树的性质：" class="headerlink" title="一、树的性质："></a>一、树的性质：</h3><p>1.结点数&#x3D;总度数+1</p>
<p>2.m叉树：每个结点最多只能有m个孩子的树</p>
<p>3.度为m的树的第i层至多有m的i-1次方个结点</p>
<p>4.高度为h的m叉树至少有h个结点</p>
<p>高度为h，度为m的树至少有h+m-1个结点</p>
<p>5.具有n个结点的m叉树的最小高度为[logm(n(m-1)+1)]</p>
<h3 id="二、二叉树的基本概念："><a href="#二、二叉树的基本概念：" class="headerlink" title="二、二叉树的基本概念："></a>二、二叉树的基本概念：</h3><p>1.二叉树是n个结点的有限集合</p>
<p>或者为空树，或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</p>
<p>2.二叉树的每个结点至多有两个结点，并且是有序的</p>
<p>3.几种特殊的二叉树：</p>
<p>（1）满二叉树：只有最后一层有叶子结点；不存在度为1的结点；按照层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1;结点i的父节点为i&#x2F;2(如果有的话)</p>
<p>（2）完全二叉树：当且仅当其每个结点都与高度为h的满二叉树中编号为1—n的结点一一对应时，称为满二叉树</p>
<p>完全二叉树只有最后两层可能有叶子结点；最多只有一个度为1的结点</p>
<p>（3）二叉排序树：</p>
<p>左子树上所有结点的值均小于根节点的值</p>
<p>右子树上所有结点的值均大于根节点的值</p>
<p>左子树和右子树又均为一棵二叉排序树</p>
<p>（4）平衡二叉树：</p>
<p>树上任意结点的左子树和右子树的深度之差不超过1</p>
<h3 id="三、二叉树的性质："><a href="#三、二叉树的性质：" class="headerlink" title="三、二叉树的性质："></a>三、二叉树的性质：</h3><p>1.设非空二叉树中度为0，1，2的结点数分别为n0，n1和n2，则n0 &#x3D; n2 + 1</p>
<p>2.二叉树的第i层至多有2的i-1个结点</p>
<p>3.高度为h的二叉树至多有2的h次方减一个结点</p>
<p>4.完全二叉树的性质：</p>
<p><a href="https://imgse.com/i/pCXr9ER"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/25/pCXr9ER.png"
                      alt="pCXr9ER.png"
                ></a></p>
<p>5.完全二叉树的性质：</p>
<p>对于完全二叉树，可以由结点数n推出度为0、1、和2的结点的个数为n0，n1和n2</p>
<p>6.完全二叉树最多只有一个度为1的结点</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录9</title>
    <url>/2023/07/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%959/</url>
    <content><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="一、二叉树的遍历："><a href="#一、二叉树的遍历：" class="headerlink" title="一、二叉树的遍历："></a>一、二叉树的遍历：</h3><p>1.先序遍历（根左右）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T-&gt;data);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>2.中序遍历（左根右）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(TreeNode T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T-&gt;data);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>3.后序遍历（左右根）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>4.遍历的复杂度是树的高度</p>
<p>5.二叉树的层序遍历：</p>
<p>（1）初始化一个辅助队列</p>
<p>（2）根节点入队</p>
<p>（3）若队列非空，则队头结点出队，访问该节点，并将其左右孩子插入队尾（如果有的话）</p>
<p>（4）重复步骤三直到队列为空</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LeaveOrder</span><span class="params">(TreeNode T)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    Initqueue(Q);   <span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    TreeNode p;</span><br><span class="line">    EnQueue(Q,T);  <span class="comment">//将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        DeQueue(Q,p);     <span class="comment">//队头结点出队</span></span><br><span class="line">        <span class="built_in">printf</span>(p-&gt;data);  <span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);  <span class="comment">//左孩子不为空，左孩子入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);  <span class="comment">//右孩子不为空，右孩子入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="二、由遍历序列构造二叉树："><a href="#二、由遍历序列构造二叉树：" class="headerlink" title="二、由遍历序列构造二叉树："></a>二、由遍历序列构造二叉树：</h3><p>1.如果只给出二叉树的前&#x2F;中&#x2F;后&#x2F;层序遍历序列中的一种，不能唯一确定一棵二叉树</p>
<p>2.前序遍历序列中第一个结点必然是根结点</p>
<p>3.后序遍历序列中最后一个结点必然是根结点</p>
<p>4.已知中序+前序、中序+后序、中序+层序的一种就可以恢复出二叉树</p>
<p>5.找到根节点，划分出左右子树</p>
<p>6.前序、后序、层序的两两组合无法唯一确定一棵二叉树</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习记录4</title>
    <url>/2023/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h1 id="计算机网络的三种交换方式"><a href="#计算机网络的三种交换方式" class="headerlink" title="计算机网络的三种交换方式"></a>计算机网络的三种交换方式</h1><h3 id="一、电报交换："><a href="#一、电报交换：" class="headerlink" title="一、电报交换："></a>一、电报交换：</h3><p>1.电报交换的三个步骤：</p>
<p>（1）建立连接：分配通信资源</p>
<p>（2）通话：一直占用通信资源</p>
<p>（3）释放连接：归还通信资源</p>
<p>2.计算机之间的数据传送是突发式的，当使用电路交换来传送计算机数据时，其线路的传送效率一般都会很低，线路上真正使用传送数据的时间往往不到10%甚至1%</p>
<h3 id="二、分组交换："><a href="#二、分组交换：" class="headerlink" title="二、分组交换："></a>二、分组交换：</h3><p>1.主机</p>
<p>2.交换节点</p>
<p>3.发送方的任务：构造分组、发送分组</p>
<p>4.交换节点的任务：缓存分组、转发分组</p>
<p>5.接受方的任务：接受分组、还原报文</p>
<p>6.分组交换的优点：</p>
<p>（1）没有建立连接和释放连接的过程</p>
<p>（2）分组传输过程中逐段占用通信链路，有较高的通信线路利用率</p>
<p>（3）交换节点可以为每一个分组独立选择转发路由，使得网络有很好的生存性</p>
<p>7.分组交换的缺点：</p>
<p>（1）分组首部带来了额外的传输开销</p>
<p>（2）交换节点存储转发分组会造成一定的时延</p>
<p>（3）无法确保通行时端到端通信资源全部可用，在通信量较大的时候可能造成网络拥塞</p>
<p>（4）分组可能会带来失序和丢失的问题</p>
<h3 id="三、报文交换："><a href="#三、报文交换：" class="headerlink" title="三、报文交换："></a>三、报文交换：</h3><p>1.报文交换是分组交换的前身</p>
<p>2.在报文交换中，报文被整个的发送，不是拆分成为若干个分组来发送</p>
<p>3.交换节点将报文整体接收完成后才能查找转发表，将整个报文转发到下一个节点</p>
<p>4.报文交换比分组交换带来的转发时延要长很多，需要交换节点具有的缓存空间也大很多</p>
<h3 id="四、三种交换方式的对比："><a href="#四、三种交换方式的对比：" class="headerlink" title="四、三种交换方式的对比："></a>四、三种交换方式的对比：</h3><p>1.<a href="https://imgse.com/i/pCv9cAU"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/07/26/pCv9cAU.png"
                      alt="pCv9cAU.png"
                ></a></p>
<p>2.如果要连续传送大量数据，并且数据传送时间远远大于建立连接的时间，则使用电路交换可以有较高的传输效率。然而计算机的数据传送是突发式的，使用电路交换通信线路的利用率会很低</p>
<p>3.报文交换和分组交换都不需要事先建立连接，在传送计算机的突发数据时，可以提高通信线路的利用率</p>
<p>4.将报文搞成若干个更小的分组进行分组交换，比将整个报文进行报文交换的时延要小，可以避免太长的报文长时间占用链路，有利于进行差错控制，同时具有更高的灵活性。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录10</title>
    <url>/2023/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9510/</url>
    <content><![CDATA[<h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><h3 id="一、线索二叉树的定义："><a href="#一、线索二叉树的定义：" class="headerlink" title="一、线索二叉树的定义："></a>一、线索二叉树的定义：</h3><p>1.在中序遍历、前序遍历、后序遍历中，定义前驱和后继</p>
<p>2.n个结点具有n+1个空链域，用前驱线索表示左孩子指针，用后继线索来表示右孩子指针</p>
<p>3.指向前驱、后继的指针称为线索</p>
<ol start="4">
<li></li>
</ol>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线索二叉树结点的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag; <span class="comment">//左右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadNode</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>tag为0表示指向的是左右孩子</p>
<p>tag为1表示指向的是左右线索</p>
<h3 id="二、二叉树的线索化："><a href="#二、二叉树的线索化：" class="headerlink" title="二、二叉树的线索化："></a>二、二叉树的线索化：</h3><p>1.找中序前驱：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义如下的全局变量，用于查找结点p的前驱</span></span><br><span class="line">TreeNode *p; <span class="comment">//p为目标结点</span></span><br><span class="line">TreeNode *pre = <span class="literal">NULL</span>;  <span class="comment">//指向当前访问结点的前驱</span></span><br><span class="line">TreeNode *final = <span class="literal">NULL</span>; <span class="comment">//用于记录最终的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(TreeNode T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点p</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(TreeNode *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(q==p)</span><br><span class="line">    &#123;</span><br><span class="line">        final = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>2.中序线索化：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag; <span class="comment">//左右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadNode</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量pre，指向访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历，一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadNode T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InThread(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InThread(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)  <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span>&amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)  <span class="comment">//建立后继线索</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre-&gt;rchild = q;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序线索化二叉树T：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadNode T)</span></span><br><span class="line">&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InThread(T);</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>3.中序遍历的最后一个结点右孩子指针必然为空</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录11</title>
    <url>/2023/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9511/</url>
    <content><![CDATA[<h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><h3 id="一、双亲表示法："><a href="#一、双亲表示法：" class="headerlink" title="一、双亲表示法："></a>一、双亲表示法：</h3><p>1.每个结点中保存指向双亲的指针</p>
<p>2.用一个一维数组存储树中的各个结点，数组元素是一个结构体型数据，包含两个域：data和parent，分别表示结点的数据值和其双亲结点在数组中的下标。</p>
<p>3.缺点：查找定结点的孩子只能从头开始遍历</p>
<h3 id="二、孩子表示法："><a href="#二、孩子表示法：" class="headerlink" title="二、孩子表示法："></a>二、孩子表示法：</h3><p>1.顺序+链式存储</p>
<p>2.将每个结点的孩子结点构成一个单链表，称为孩子链表。n个结点的树有n个这样的孩子链表</p>
<p>将每个结点存放在一个顺序表中，顺序表的每个元素有两个域，一个是存放该结点的数据域；另一个是存放该结点的第一个孩子的地址。孩子节点也有两个域，一个是存放该孩子结点在顺序表中的位置，另一个是存放下一个孩子的地址</p>
<h3 id="三、树和森林的转化："><a href="#三、树和森林的转化：" class="headerlink" title="三、树和森林的转化："></a>三、树和森林的转化：</h3><p>1.将一棵树转换为二叉树：</p>
<p>（1）加线：树中所有相邻的兄弟之间加一条连线</p>
<p>（2）抹线：对树中的结点，只保留它与左边第一个孩子结点之间的连线，删除它与其他孩子结点之间的连线</p>
<p>（3）旋转：以树的根节点为轴心，将整棵树顺时针旋转45度，使之称为二叉树</p>
<p>2.在转换产生的二叉树中，左分支上的各结点在原来的树中是父子关系；而右分支上的结点在原来的树中是兄弟关系</p>
<p>3.由于树的根结点没有兄弟，所以在转换后的二叉树中根结点必定没有右子树</p>
<p>4.一棵树转换为二叉树后，树的深度增加</p>
<p>5.森林转换为二叉树：</p>
<p>（1）将森林中的每一棵树转换成相应的二叉树</p>
<p>（2）第一课二叉树保持不动，从第二棵二叉树开始，依次把后一棵二叉树作为前一棵二叉树根结点的右子树，直到把最后一棵二叉树作为其前一棵二叉树的右子树为止</p>
<p>6.将二叉树还原为树：</p>
<p>（1）加线：如果某结点的左孩子有右子树，在该结点和其左孩子的右子树的右分支上各结点间加线</p>
<p>（2）抹线：抹掉各结点的右子树的右分支与上面结点的连线</p>
<p>（3）旋转整理得到树</p>
<p>7.二叉树还原成为森林：</p>
<p>（1）连线：若某结点是 其双亲的左孩子，则把该结点的右孩子、右孩子的右孩子、……、都与该结点的双亲结点用连线连起来</p>
<p>（2）抹线：删除原二叉树中原来双亲结点与右孩子结点的连线</p>
<p>（3）整理由前两个步骤得到的树或森林，使其结构层次分明</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录12</title>
    <url>/2023/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9512/</url>
    <content><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="一、树和森林的遍历："><a href="#一、树和森林的遍历：" class="headerlink" title="一、树和森林的遍历："></a>一、树和森林的遍历：</h3><p>1.先根遍历：若树非空，先访问根结点，再依次对每棵子树进行先根遍历</p>
<p>2.后跟遍历：若树非空，先依次对每棵子树进行后跟遍历，最后再访问根结点</p>
<p>3.层次遍历：</p>
<p>（1）若树非空，则根结点入队</p>
<p>（2）若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</p>
<p>（3）重复步骤二直到队列为空</p>
<p>4.森林的遍历：</p>
<p>（1）先序遍历：若森林非空，按照如下的规则遍历：访问森林的第一棵树的根结点，先序遍历第一棵树中根结点的子树森林，先序遍历除去第一棵树之后的树构成的森林</p>
<p>（2）中序遍历：若森林非空，按照以下的规则遍历：中序遍历森林中第一棵树的根结点的子树森林，访问第一棵树的根结点，中序遍历除去第一棵树之后剩余的树构成的森林</p>
<h3 id="二、哈夫曼树："><a href="#二、哈夫曼树：" class="headerlink" title="二、哈夫曼树："></a>二、哈夫曼树：</h3><p>1.哈夫曼树是一种特殊的二叉树，树的所有叶子结点都有权值，构造出带权路径长度最短的二叉树，即为哈夫曼树</p>
<p>2.路径：树中一个结点与另一个结点之间的分支构成这两个结点之间的路径</p>
<p>3.路径长度：树中路径上的分支数目</p>
<p>4.树的路径长度：根结点到树中每个结点的路径长度之和</p>
<p>5.叶子结点的权值：人们根据需要为每个叶子结点赋予的一个数值</p>
<p>6.叶子结点的带权路径长度：指从树根到该叶子结点之间的路径长度与该结点的权值乘积</p>
<p>7.树的带权路径长度：树中所有叶子结点的权值乘以该结点的路径长度之和</p>
<p>8.哈夫曼树是n个带权值的叶子结点所构成的所有二叉树中带权路径长度WPL最小的二叉树</p>
<p>9.哈夫曼树构造的基本思想：</p>
<p>（1）将给定的n个权值作为n个根结点的权值构造一个具有n棵二叉树的森林，每个二叉树只有一个根结点</p>
<p>（2）在森林中选取两棵树根结点的权值最小的二叉树作为左右子树构造一棵新的二叉树，新二叉树的根结点的权值为原来两棵树根结点的权值之和</p>
<p>（3）在森林中，将上面选择的这两棵根结点的权值最小的二叉树从森林中删除，并将最新构造的二叉树加入到森林中</p>
<p>（4）重复上面的步骤2和3，直到森林中只有一棵二叉树为止，这棵树就是哈夫曼树</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录13</title>
    <url>/2023/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9513/</url>
    <content><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h3 id="一、并查集的定义："><a href="#一、并查集的定义：" class="headerlink" title="一、并查集的定义："></a>一、并查集的定义：</h3><p>1.用互不相交的树，表示多个集合</p>
<p>2.判断两个元素是否属于同一个集合：分别查到两个元素的根，判断根结点是否相同</p>
<p>3.把两个集合并为一个集合：让一棵树成为另一棵树的子树</p>
<p>4.并查集是集合的一种具体的实现，只进行并和查两种基本操作</p>
<ol start="5">
<li></li>
</ol>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="type">int</span> UFSets[SIZE];  <span class="comment">//集合元素数组</span></span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initial</span><span class="params">(<span class="type">int</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        S[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = S[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1==Root2) <span class="keyword">return</span>;</span><br><span class="line">    S[Root2] = Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>6.查操作的时间复杂度为O(n)</p>
<p>7.Union操作的优化：</p>
<p>（1）用根结点的绝对值表示树的结点总数</p>
<p>（2）Union操作，让小树合并到大树</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化后的并操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1==Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(S[Root2]&gt;S[Root1])</span><br><span class="line">    &#123;</span><br><span class="line">        S[Root1] += S[Root2];  <span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root2] = Root1;   <span class="comment">//小树合并到大树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        S[Root2] += S[Root1];  <span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root1] = Root2;   <span class="comment">//小树合并到大树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>8.对查操作的优化：（压缩路径）</p>
<p>先找到根结点，再将查找路径上的所有结点都挂到根结点下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span>(S[root]&gt;=<span class="number">0</span>) root = S[root];  <span class="comment">//循环找到根</span></span><br><span class="line">    <span class="keyword">while</span>(x!=root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = S[x]; </span><br><span class="line">        S[x] = root;</span><br><span class="line">        x = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录14</title>
    <url>/2023/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9514/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h3><p>1.图G由顶点集V和边集E组成，记为G&#x3D;（V,E）</p>
<p>2.图的顶点集是非空集</p>
<p>3.若E是无向边的有限集合时，则图G为无向图</p>
<p>4.若E是有向边的有限集合时，则图G为有向图</p>
<p>5.弧是顶点的有序对，记为&lt;v,w&gt;，其中v、w是顶点</p>
<p>6.简单图：</p>
<p>（1）不存在重复的边</p>
<p>（2）不存在顶点到自身的边</p>
<p>7.多重图：图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G为多重图</p>
<p>8.顶点的度：</p>
<p>（1）对于无向图：顶点的度是指依附于该顶点的边的条数，记为TD(v)</p>
<p>（2）对于有向图：入度是指以顶点v为终点的有向边的数目，记为ID(v)</p>
<p>​				 出度是指以顶点v为起点的有向边的数目，记为OD(v)</p>
<p>有向图中顶点的度是指入度和出度之和</p>
<p>9.有向图的路径是有向的</p>
<p>10.回路：第一个顶点和最后一个顶点相同的路径称为回路或环</p>
<p>11.路径长度：路径上边的数目</p>
<p>12.点到点的距离：从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为u到v的距离，若u到v不存在路径，则点到点的距离为无穷</p>
<p>13.在无向图中，若顶点v到顶点w的路径存在，则称v和w是连通的</p>
<p>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的</p>
<p>14.无向图中，若任意两个顶点都是连通的，则改图为连通图，否则称为非连通图</p>
<p>15.有向图中，若任意两个顶点都是强连通的，则该图为强连通图</p>
<p>16.对于n个顶点的无向图G，若G是连通图，则至少有n-1条边</p>
<p>若G是非连通图，则最多可能有n-1中取2的组合数条边</p>
<p>17.对于n个顶点的有向图G，若G是强连通图，则最少有n条边（形成回路）</p>
<p>18.如果子图中包含了原图的所有顶点，则称该图为原图的生成子图</p>
<p>19.无向图中的极大连通子图称为连通分量</p>
<p>有向图中的极大强连通子图称为有向图强连通分量</p>
<p>20.生成树：连通图的生成树是包含图中全部顶点的一个极小连通子图</p>
<p>21.生成森林：在非连通图中，连通分量的生成树构成了非连通图的生成森林</p>
<p>22.边的权：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值</p>
<p>23.边上带权值的图称为带权图，也称为网</p>
<p>24.带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p>
<p>25.几种特殊的图：</p>
<p>（1）无向完全图：无向图中任意两个顶点	之间都存在边</p>
<p>（2）有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧</p>
<p>（3）树：不存在回路，且连通的无向图（n个顶点的树，必有n-1条边）</p>
<p>（4）有向树：一个顶点的入度为0，其余顶点的入度均为1的有向图，称为有向树</p>
<p>有向树不是强连通图</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录15</title>
    <url>/2023/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9515/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="一、图的邻接矩阵存储："><a href="#一、图的邻接矩阵存储：" class="headerlink" title="一、图的邻接矩阵存储："></a>一、图的邻接矩阵存储：</h3><p>1.图没有顺序存储的方式，但是可以通过二维数组来表示元素之间的关系</p>
<p>2.邻接矩阵是表示顶点之间相邻关系的矩阵。假设图G&#x3D;(V,E)具有n个顶点，则邻接矩阵是具有如下性质的n阶方阵：</p>
<p><a href="https://imgse.com/i/pPC2Bes"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/08/01/pPC2Bes.png"
                      alt="pPC2Bes.png"
                ></a></p>
<p>3.图的邻接矩阵表示法的特点：</p>
<p>（1）无向图的邻接矩阵是对称的，而有向图的邻接矩阵不一定对称</p>
<p>（2）对于无向图，顶点Vi的度是邻接矩阵中第i行（或第i列）的非零元素的个数</p>
<p>（3）对于有向图，顶点Vi的度是邻接矩阵中第i行和第i列的非零元素之和</p>
<p>（4）邻接矩阵确定图的边数，所花费的时间代价很大</p>
<p>4.图的邻接矩阵存储结构定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100  <span class="comment">/*图中最大顶点个数*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> n,e;     <span class="comment">//顶点数，边数</span></span><br><span class="line">    <span class="type">char</span> vexs[MAX]; <span class="comment">//顶点数组</span></span><br><span class="line">    <span class="type">int</span> edges[MAX][MAX]; <span class="comment">//边的邻接矩阵</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure></div>

<p>5.建立图的邻接矩阵算法：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateMGraph</span><span class="params">(MGraph *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">char</span> ch1,ch2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入顶点数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;G-&gt;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入边数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;G-&gt;e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入各顶点信息（每个顶点以回车作为结束）:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入第%d个顶点：&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;(G-&gt;vexs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G-&gt;n;j++)</span><br><span class="line">            G-&gt;edges[i][j] = <span class="number">0</span>;  <span class="comment">//将邻接矩阵元素全部置为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;e;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;建立第%d条边（输入格式：顶点1，顶点2）:&quot;</span>,k+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c,%c&quot;</span>,&amp;ch1,&amp;ch2);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G-&gt;n;j++)</span><br><span class="line">                <span class="keyword">if</span>(ch1==G-&gt;vexs[i] &amp;&amp; ch2==G-&gt;vexs[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    G-&gt;edges[i][j] = <span class="number">1</span>;</span><br><span class="line">                    G-&gt;edges[j][i] = <span class="number">1</span>;  <span class="comment">//无向图邻接矩阵</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="二、图的邻接表存储："><a href="#二、图的邻接表存储：" class="headerlink" title="二、图的邻接表存储："></a>二、图的邻接表存储：</h3><p>1.邻接表是图的一种顺序存储和链式存储相结合的存储方法，类似于树的孩子链表表示法</p>
<p>2.对于图G中的每一个顶点Vi，将所有邻接于Vi的顶点Vj连成一个单链表，这个单链表称为顶点	Vi的邻接表。将所有顶点的邻接表表头放在数组中，就构成了图的邻接表</p>
<p>3.邻接表中有两种结点结构，顶点表和边表</p>
<p>4.顶点表的结点结构由顶点域（vertex）和指向第一条边邻接边的指针域（firstedge）构成</p>
<p>边表结点由邻接点域（adjvex）和指向下一条邻接边的指针域（next）构成</p>
<p>5.对于网的边表需要在增加一个存储边上信息（如权值）的域（info）</p>
<p>6.图的邻接表表示法的特点：</p>
<p>（1）无向图中若有n个顶点、e条边、它的邻接表需要n个表头指针和2e个边结点</p>
<p>有向图中有n个顶点，e条边，则它的邻接表需要n个表头指针和e个边结点</p>
<p>（2）对于无向图，顶点Vi的度是第i个链表的结点数</p>
<p>对于有向图，顶点Vi的出度是第i个链表的结点数，而要求入度必须遍历整个邻接表，在所有链表中找邻接点域的值为i的边结点的个数</p>
<p>7.图的邻接表存储：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100   <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>   //定义边表结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex;  <span class="comment">//邻接点域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一个邻接点的指针域</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vexnode</span>   //定义顶点表结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType data;  <span class="comment">//顶点域</span></span><br><span class="line">    EdgeNode *firstedge;  <span class="comment">//指向第一条边结点</span></span><br><span class="line">&#125;VHeadNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VHeadNode adjlist[MAX];  <span class="comment">//邻接表头结点数组</span></span><br><span class="line">    <span class="type">int</span> n,e;    <span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;AdjList;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录16</title>
    <url>/2023/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9516/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="一、图的十字链表存储："><a href="#一、图的十字链表存储：" class="headerlink" title="一、图的十字链表存储："></a>一、图的十字链表存储：</h3><p>1.十字链表是有向图的一种链式存储结构，它结合了邻接表和逆邻接表的特性</p>
<p>2.邻接表反映的是顶点的出度情况</p>
<p>逆邻接表反映的是顶点的入度情况</p>
<p>3.十字链表也包含两部分：顶点节 点和弧节点。顶点节点包括顶点信息和两个指针（分别指向第一个入弧和第一个出弧），弧 节点包括两个数据域（弧尾、弧头）和两个指针域（分别指向同弧头和同弧尾的弧） </p>
<p>4.弧结点的定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arcNode</span>  //定义弧结点类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> tail;  <span class="comment">//弧尾下标</span></span><br><span class="line">    <span class="type">int</span> head;  <span class="comment">//弧头下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arcNode</span> *<span class="title">hlink</span>;</span>  <span class="comment">//指针，指向同弧头的弧</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arcNode</span> *<span class="title">tlink</span>;</span>  <span class="comment">//指针，指向同弧尾的弧</span></span><br><span class="line">&#125;arcNode;</span><br></pre></td></tr></table></figure></div>

<p>5.顶点结点的定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vexNode</span>  //定义顶点类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VexType data;  <span class="comment">//顶点数据，VexType为顶点的数据类型，根据需要来定义</span></span><br><span class="line">    arcNode *firstin;  <span class="comment">//指针，指向第一个入弧</span></span><br><span class="line">    arcNode *firstout;  <span class="comment">//指针。指向第一个出弧</span></span><br><span class="line">&#125;vexNode;</span><br></pre></td></tr></table></figure></div>

<p>6.有向图的十字链表存储的结构体定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVnum 100  <span class="comment">//顶点的最大数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VexNode Vex[MaxVnum];  <span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> vexnum,edgenum;   <span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;OLGragh;</span><br></pre></td></tr></table></figure></div>

<p>7.十字链表存储稀疏有向图，可以高效访问每个顶点的出弧和入弧，很容易得到顶点的出度和入度</p>
<h3 id="二、图的邻接多重表存储："><a href="#二、图的邻接多重表存储：" class="headerlink" title="二、图的邻接多重表存储："></a>二、图的邻接多重表存储：</h3><p>1.邻接多重表是无向图的一种链式存储结构。</p>
<p>2.邻接表的关注点是 顶点，而邻接多重表的关注点是边，适合对边做访问标记、删除边等操作 </p>
<p>3.邻接多重表类似 十字链表，也包含两部分：顶点节点和边节点。顶点节点包括 顶点信息和一个指针（指向第一个依附于该顶点的边），边节 点包括两个数据域（顶点 i、顶点 j）和两个指针域（分别指向 依附于 i、j 的下一条边）</p>
<p>4.边节点的定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edgeNode</span>   //定义边节点类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;  <span class="comment">//顶点下标</span></span><br><span class="line">    <span class="type">int</span> j;  <span class="comment">//顶点下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edgeNode</span> *<span class="title">jlink</span>;</span>  <span class="comment">//指针，指向与i同顶点的边</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edgeNode</span> *<span class="title">jlink</span>;</span>  <span class="comment">//指针，指向与j同顶点的边</span></span><br><span class="line">&#125;edgeNode;</span><br></pre></td></tr></table></figure></div>

<p>5.顶点节点的定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vexNode</span>  //定义顶点类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VexType data;   <span class="comment">//顶点数据，VexType为顶点的数据类型，根据需要定义</span></span><br><span class="line">    adgeNode *firstedge;   <span class="comment">//指针，指向第一条连接边</span></span><br><span class="line">&#125;VexNode;</span><br></pre></td></tr></table></figure></div>

<p>6.无向图的邻接多重表存储的结构体定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVnum 100  <span class="comment">//顶点数的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VexNode Vex[MaxVnum];  <span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> vexnum,edgenum;  <span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;AMLGragh;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录17</title>
    <url>/2023/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9517/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="一、图的遍历—广度优先搜索："><a href="#一、图的遍历—广度优先搜索：" class="headerlink" title="一、图的遍历—广度优先搜索："></a>一、图的遍历—广度优先搜索：</h3><p>1.图的遍历和树的遍历类似，是从图的某一顶点出发，按照某种搜索方式对图中所有顶点 访问一次且仅一次 </p>
<p>2.广度优先搜索（BFS），又称宽度优先搜索，是最常见的图搜索方法 之一</p>
<p>广度优先搜索：先访问的顶点，其邻接点先被访问</p>
<p>3.BFS的步骤：</p>
<p>（1）初始化图中所有顶点未被访问，初始化一个空队列</p>
<p>（2）从图中的某个顶点v出发，访问v并标记已访问，将v入队</p>
<p>（3）如果队列非空，则继续执行，否则算法结束</p>
<p>（4）队头元素v出队，依次访问v的所有未被访问的邻接点，标记已经访问并入队，转向步骤三</p>
<p>4.基于邻接矩阵的BFS：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS_AM</span><span class="params">(AMGragh G,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u,w;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;<span class="comment">//创建一个普通的队列，存放int类型</span></span><br><span class="line">    cout&lt;&lt;G.Vex[v]&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(v);  <span class="comment">//源点v入队</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        u = Q.<span class="built_in">front</span>();  <span class="comment">//去除队头元素赋值给u</span></span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.Edge[u][w] &amp;&amp; !visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;G.Vex[w]&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>5.基于邻接表的BFS：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS_AL</span><span class="params">(ALGragh G,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u,w;</span><br><span class="line">    AdjNode *p;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    cout&lt;&lt;G.Vex[v].data&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(v); <span class="comment">//源点v入队</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        u = Q.<span class="built_in">front</span>(); <span class="comment">//取出队头元素赋值给u</span></span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        p = G.Vex[u].<span class="built_in">first</span>();</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            w = p-&gt;v;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;G.Vex[w].data&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(w);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="二、图的遍历—深度优先搜索："><a href="#二、图的遍历—深度优先搜索：" class="headerlink" title="二、图的遍历—深度优先搜索："></a>二、图的遍历—深度优先搜索：</h3><p>1.深度优先搜索沿着一条路径一直走下去，无法行进时，回退到刚刚访问的节点 </p>
<p>2.深度优先遍历是按照深度优先搜索的方式对图进行遍历 </p>
<p>3.深度优先搜索的特点：后被访问的顶点，其邻接点先被访问</p>
<p>4.深度优先的递归实现步骤：</p>
<p>（1）初始化图中所有顶点未被访问</p>
<p>（2）从图中的某个顶点v出发，访问v并标记已访问</p>
<p>（3）依次检查v的所有邻接点w，如果w未被访问，则从w出发进行深度优先遍历（递归调用，重复第二步和第三步）</p>
<p>5.基于邻接矩阵的DFS：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_AM</span><span class="params">(AMGragh G,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    cout&lt;&lt;G.Vex[v]&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)  <span class="comment">//依次检查v的所有邻接点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(G.Edge[v][w] &amp;&amp; !visited[w])  <span class="comment">//v,w邻接而且w未被访问</span></span><br><span class="line">            <span class="built_in">DFS_AM</span>(G,w); <span class="comment">//从w顶点开始递归深度优先遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>6.基于邻接表的DFS：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_AL</span><span class="params">(ALGragh G,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    AdjNode *p;</span><br><span class="line">    cout&lt;&lt;G.Vex[v].data&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    p = G.Vex[v].first;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        w = p-&gt;v;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            <span class="built_in">DFS_AL</span>(G,w);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录18</title>
    <url>/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9518/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="一、最小生成树："><a href="#一、最小生成树：" class="headerlink" title="一、最小生成树："></a>一、最小生成树：</h3><p>1.一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的n-1条边</p>
<p>2.构造连通网的最小代价生成树称为最小生成树</p>
<p>3.对于 n 个顶点的连通图，只需 n−1 条边就可以使这个图连通，n−1 条边要想保证图连通， 就必须不含回路</p>
<p>4.子图：从原图中选出一些顶点和边组成的图，称为原图的子图</p>
<p>5.生成子图：选中一些边和所有顶点组成的子图，称为原图的生成子图</p>
<p>6.生成树：如果生成子图恰好是一棵树，则称为生成树</p>
<p>7.最小生成树：权值之和最小的生成树，称为最小生成树</p>
<p>8.Prim算法求解最小生成树：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> u0,<span class="type">int</span> c[N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//顶点个数为n，开始顶点u0，带权邻接矩阵c[n][n]</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果s[i]=true，说明顶点i已经加入最小生成树的顶点集合u，否则顶点i在集合v-u中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s[u0] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">int</span> lowcast[MAXVEX];</span><br><span class="line">    lowcast[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> closest[MAXVEX];</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> s[MAXVEX];</span><br><span class="line">    <span class="comment">//数组初始化</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=u0)</span><br><span class="line">        &#123;</span><br><span class="line">            lowcast[i] = c[u0][i];</span><br><span class="line">            cloest[i] = u0;</span><br><span class="line">            s[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            lowecast[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = INF;</span><br><span class="line">        <span class="type">int</span> t = u0;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((!s[j])&amp;&amp;(lowcast[j]&lt;temp))</span><br><span class="line">            &#123;</span><br><span class="line">                t = j;</span><br><span class="line">                temp = lowcast[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==u0)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        s[t]  = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新lowcast和closest</span></span><br><span class="line">            <span class="keyword">if</span>((!s[j])&amp;&amp;(c[t][j]&lt;lowcast[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                lowcast[j] = c[t][j];</span><br><span class="line">                closest[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>9.Kruskal算法构造最小生成树：</p>
<p>算法步骤：</p>
<p>（1）初始化，将图中G的边集E中的所有边按照权值从小到大排序，边集TE&#x3D;{}，把每个顶点都初始化成为一个孤立的分支，即一个顶点对应一个集合</p>
<p>（2）在E中寻找权值最小的边（i，j）</p>
<p>（3）如果顶点i和j位于两个不同连通分支，则将边（i，j）加入边集TE，并执行合并操作，将两个连通分支进行合并</p>
<p>（4）将边（i，j）从集合E中删去，即E &#x3D; E-{（i，j）}</p>
<p>（5）如果选取边数小于n-1，转第二步，否则，算法结束，T为最小生成树</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = nodeset[a];</span><br><span class="line">    <span class="type">int</span> q = nodeset[b];</span><br><span class="line">    <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检查所有节点，把集合是q的改为p</span></span><br><span class="line">        <span class="keyword">if</span>(nodeset[i]==q)</span><br><span class="line">        &#123;</span><br><span class="line">            nodeset[i] = p;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Merge</span>(e[i].u,e[i].v))</span><br><span class="line">        &#123;</span><br><span class="line">            ans += e[i].w;</span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面代码中得到的ans即为最小生成树权值之和</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录19</title>
    <url>/2023/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9519/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="一、单源最短路径："><a href="#一、单源最短路径：" class="headerlink" title="一、单源最短路径："></a>一、单源最短路径：</h3><p>1.给定有向带权图 G &#x3D;(V, E)，其中每条边的权值是非负实数。此外，给定 V 中的一个顶 点，称为源点 </p>
<p>2.Dijkstra 算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径，直到求出从源点到其他各个顶点的最短路径 </p>
<p>3.Dijkstra 算法的基本思想是首先假定源点为 u，顶点集合 V 被划分为两部分：集合 S 和 V−S。初始时 S 中仅含有源点 u， S 中的顶点到源点的最短路径已经确定，V−S 中的顶点 到源点的最短路径待定。从源点出发只经过 S 中的点到达 V−S 中的点的路径为特殊路径，用 数组 dist[]记录当前每个顶点所对应的最短特殊路径长度 </p>
<ol start="4">
<li></li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(AMGragh G,<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = G.Edge[u][i];</span><br><span class="line">        flag[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(dist[i]==INF)</span><br><span class="line">            p[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[i] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[u] = <span class="number">0</span>;</span><br><span class="line">    flag[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = INF,t = u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[j]&amp;&amp;dist[j]&lt;temp)</span><br><span class="line">            &#123;</span><br><span class="line">                t = j;</span><br><span class="line">                temp = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==u) <span class="keyword">return</span>;</span><br><span class="line">        flat[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">            <span class="keyword">if</span>(!flag[j] &amp;&amp; G.Edge[t][j]&lt;INF)</span><br><span class="line">                <span class="keyword">if</span>(dist[j]&gt;(dist[t]+G.Edge[t][j]))</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[j] = dist[t] + G.Edge[t][j];</span><br><span class="line">                    p[j] = t;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="二、各顶点之间的最短路径："><a href="#二、各顶点之间的最短路径：" class="headerlink" title="二、各顶点之间的最短路径："></a>二、各顶点之间的最短路径：</h3><p>1.Floyd算法求解任意两个顶点的最短路径，Floyd 算法又称为插点法，其算法核心 是在顶点 i 到顶点 j 之间，插入顶点 k，看是否能够缩短 i 和 j 之间距离 </p>
<p>2.Floyd算法的基本思想是通过动态规划的方式逐步更新最短路径的估计值 </p>
<p>3.Floyd算法的核心是利用”中间节点”的概念，即假设对于图中的每一对节点(i, j)，我们考虑在最短路径中可能会经过的节点k。那么我们可以通过比较直接从节点i到节点j的路径和通过节点k的路径的长度，来更新最短路径的估计值 </p>
<p>4.算法步骤：</p>
<div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">（1）初始化路径估计矩阵D，设Di表示从节点i到节点j的最短路径长度</span><br><span class="line"></span><br><span class="line">（2）对于每一对节点(i, j)作为目的节点，遍历所有可能的中间节点k： </span><br><span class="line">若路径长度D[i][j]大于D[i][k] + D[k][j]，说明通过节点k可以得到更短的路径，更新D[i][j]为</span><br><span class="line">D[i][k] + D[k][j]</span><br><span class="line"></span><br><span class="line">（3）重复步骤2，直到所有节点对的最短路径都被计算出来</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li></li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(AMGragh G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[i][j] = G.Edge[i][j];</span><br><span class="line">            <span class="keyword">if</span>(dist[i][j]&lt;INF &amp;&amp; i!=j)</span><br><span class="line">                p[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                p[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.vexnum;k++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">        	<span class="keyword">if</span>(dist[i][k]+dist[k][j]&lt;dist[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                p[i][j] = p[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>6.Dijkstra算法适用于求解单源最短路径问题，对边权重为正的图效果较好；而Floyd算法适用于求解全源最短路径问题，可以处理包括负权重边在内的更多复杂情况，但在时间复杂度上相对较高。选择使用哪种算法取决于具体场景和问题要求 </p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录20</title>
    <url>/2023/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9520/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="一、拓扑排序："><a href="#一、拓扑排序：" class="headerlink" title="一、拓扑排序："></a>一、拓扑排序：</h3><p>1.一个无环的有向图称为有向无环图 </p>
<p>2.用顶点表示活动，用弧表示活动之间的优先关系的有向图，称为顶点表示活动的网 ，简称 AOV 网 </p>
<p>3.在 AOV 网中，若从顶点 i 到顶点 j 之间存在一条有向路径，称顶点 i 是顶点 j 的前驱，或者称顶点 j 是顶点 i 的后继。若是图中的弧，则称顶点 i 是顶点 j 的直接前驱，顶点 j 是顶点 i 的直接后驱</p>
<p>4.拓扑排序是指将 AOV 网中的顶点排成一个线性序列，该 序列必须满足：若从顶点 i 到顶点 j 有一条路径，则该序列中 顶点 i 一定在顶点 j 之前 </p>
<p>5.拓扑排序的步骤：</p>
<p>（1）找到所有入度为0的顶点：遍历图中所有的顶点，记录入度为0的顶点 </p>
<p>（2）选择一个入度为0的顶点并输出：从步骤1中找到的入度为0的顶点中任选一个，将其输出到排序结果中，并将其从图中删除。</p>
<p>（3）更新剩余顶点的入度：对于被删除的顶点所指向的顶点，将其入度减1。</p>
<p>（4）重复步骤2和步骤3，直到所有顶点都被输出或删除</p>
<p>6.拓扑排序的代码实现：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopologicalSort</span><span class="params">(ALGragh G,<span class="type">int</span> topo[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有向图采用邻接表存储</span></span><br><span class="line">    <span class="type">int</span> i,m;</span><br><span class="line">    satck&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="built_in">FindInDegree</span>(G); <span class="comment">//求出各顶点的入度存入数组indegree[]中</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!indegree[i])</span><br><span class="line">            S.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    	i = S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">        topo[m] = i;</span><br><span class="line">        m++;</span><br><span class="line">        AdjNode *p = G.Vex[i].first;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = p-&gt;v;</span><br><span class="line">            --indegree[k];</span><br><span class="line">            <span class="keyword">if</span>(indegree[k]==<span class="number">0</span>)</span><br><span class="line">                S.<span class="built_in">push</span>(k);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;G.vexnum)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>7.求有向图中各顶点的入度需要遍历邻接表，算法的时间复杂度为 O(e)。度数为 0 的顶点 入栈的时间复杂度为 O(n)，若有向图无环，每个顶点出栈后其邻接点入度减 1，时间复杂度 为 O(e)。总的时间复杂度为 O(n+e)</p>
<p>8.拓扑排序的应用场景：</p>
<p>（1）任务调度：拓扑排序可以用于任务调度，其中任务可以表示为有向图中的顶点，依赖关系可以表示为有向边。通过拓扑排序，可以确定任务的执行顺序，保证没有任务的依赖关系被违反 </p>
<p>（2）编译顺序：在编译器中，源代码中的文件可以看作是顶点，而文件之间的依赖关系可以看作是有向边。拓扑排序可以确定编译的顺序，保证每个文件在被使用之前已经编译完成 </p>
<p>（3）课程安排：拓扑排序可以用于大学课程的安排，其中课程可以看作是顶点，而先修课程关系可以看作是有向边。通过拓扑排序，可以确定学习课程的顺序，保证没有先修课程的要求被违反 </p>
<p>（4）网络通信 ：拓扑排序可以用于确定网络中设备之间的通信顺序。在网络拓扑图中，设备可以表示为顶点，而设备之间的依赖关系（例如路由路径）可以表示为有向边。通过拓扑排序，可以决定设备之间的通信顺序，确保数据包能够按照正确的路径传输 </p>
<p>（5）依赖关系分析：拓扑排序可以用于分析软件或系统中的各种依赖关系。通过拓扑排序，可以清楚地了解到各个组件之间的依赖关系，进而用于系统设计、优化和维护等方面 </p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录21</title>
    <url>/2023/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9521/</url>
    <content><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h3 id="一、线性表查找："><a href="#一、线性表查找：" class="headerlink" title="一、线性表查找："></a>一、线性表查找：</h3><p>1.查找也叫作搜索，指从数据表中找到符合特定条件的记录</p>
<p>2.线性表的查找分为顺序查找（线性表无序）和折半查找（线性表有序）</p>
<p>3.顺序查找是最简单的查找方式，以暴力穷举的方式依次将表中的关键字与待查找关键字 比较 </p>
<p>4.对于有序线性表，可以使用折半查找的策略，每次和中间的元素比 较。如果比中间元素小，则在前半部分查找；如果比中间元素大，则去后半部分查找。这种 方法称为二分查找或折半查找，也称为二分搜索</p>
<p>5.二分搜索的非递归实现：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> n,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>,high = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==s[middle])</span><br><span class="line">        	<span class="keyword">return</span> middle;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;s[middle])</span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="6">
<li></li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">recursionBS</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> x,<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//low指向数组的第一个元素。high指向数组的最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==s[middle])</span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;s[middle])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursionBS</span>(s,x,low,middle<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursionBS</span>(s,x,middle+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="二、二叉搜索树："><a href="#二、二叉搜索树：" class="headerlink" title="二、二叉搜索树："></a>二、二叉搜索树：</h3><p>1.将二分查找策略与二叉树结合起来，实现二叉查找树结构，可以在最坏的情况下使得单 次修改和查找在 O(logn)时间内完成 </p>
<p>2.二叉查找树可能是空树，如果非空，则具有以下的性质：</p>
<p>（1）若其左子树非空，则左子树上所有节点的值 均小于根节点的值 </p>
<p>（2）若其右子树非空，则右子树上所有节点的值 均大于根节点的值 </p>
<p>（3）其左右子树本身又各是一棵二叉查找树 </p>
<p>3.二叉查找树的递归查找：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree T,ElemType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((!T) || key==T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lchild,key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rchild,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>4.二叉查找树的插入：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertBST</span><span class="params">(BSTree &amp;T,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">    &#123;</span><br><span class="line">        BSTree S = <span class="keyword">new</span> BSTNode;</span><br><span class="line">        S-&gt;data = e;</span><br><span class="line">        S-&gt;lchild = S-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        T = S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e&lt;T-&gt;data)</span><br><span class="line">        <span class="built_in">InsertBST</span>(T-&gt;lchild,e);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e&gt;T-&gt;data)</span><br><span class="line">        <span class="built_in">InsertBST</span>(T-&gt;rchild,e);</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure></div>

<p>5.二叉查找树的创建：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBST</span><span class="params">(BSTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">    ElemType e;</span><br><span class="line">    cin&gt;&gt;e;</span><br><span class="line">    <span class="keyword">while</span>(e!=ENDFLAG)   <span class="comment">//ENDFLAG是结束标志，可以自定义</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InsertBST</span>(T,e);</span><br><span class="line">        cin&gt;&gt;e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>6.二叉查找树的删除：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteBST</span><span class="params">(BSTree &amp;T,<span class="type">char</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从二叉查找树中删除关键字等于key的节点</span></span><br><span class="line">    BSTree p =T;</span><br><span class="line">    BSTree f = <span class="literal">NULL</span>;</span><br><span class="line">    BSTree q,s;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)<span class="comment">//查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==key) <span class="keyword">break</span>;</span><br><span class="line">        f = p;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&gt;key)</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span>;  <span class="comment">//找不到被删的节点则返回</span></span><br><span class="line">    <span class="keyword">if</span>((p-&gt;lchild) &amp;&amp; (p-&gt;rchild))</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(q!=p)</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f)</span><br><span class="line">            T = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q==f-&gt;lchild)</span><br><span class="line">            f-&gt;lchild = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f-&gt;rchild = p;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>7.二叉查找树的删除，主要是查找的过程，需要 O(logn)时间。删除的过程中，如果需要 找被删节点的前驱，也需要 O(logn)时间，二叉查找树的删除时间复杂度为 O(logn)</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录22</title>
    <url>/2023/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9522/</url>
    <content><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h3 id="一、平衡二叉搜索树："><a href="#一、平衡二叉搜索树：" class="headerlink" title="一、平衡二叉搜索树："></a>一、平衡二叉搜索树：</h3><p>1.平衡二叉查找树（Balanced Binary Search Tree，BBST），简称平衡二叉树，由苏联数学 家 Adelson-Velskii 和 Landis 提出，所以又称为 AVL 树</p>
<p>2.平衡二叉树可以是空树，若非空，则满足以下的性质：</p>
<p>（1）左右子树高度差的绝对值不超过 1 </p>
<p>（2）左右子树也是平衡二叉树 </p>
<p>节点左右子树的高度之差称为平衡因子。二叉查找树中，每个节点的平衡因子绝对值不 超过 1 即为平衡二叉树 </p>
<p>3.平衡二叉树除了适度平衡性，还具有局部性：</p>
<p>（1）单次插入、删除后，至多有 O(1)处出现不平衡； </p>
<p>（2）总可以在 O(logn)时间内，使这 O(1)处不平衡重新调整为平衡 </p>
<p>4.插入操作后，调整平衡可以分为四种情况：</p>
<p>（1）LL型：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">LL_Rotation</span><span class="params">(AVLTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree temp = T-&gt;lchild;</span><br><span class="line">    T-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = T;</span><br><span class="line">    <span class="built_in">updateHeight</span>(T);</span><br><span class="line">    <span class="built_in">updateHeight</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（2）RR型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">RR_Rotation</span><span class="params">(AVLTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree temp = T-&gt;rchild;</span><br><span class="line">    T-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = T;</span><br><span class="line">    <span class="built_in">updateHeight</span>(T);</span><br><span class="line">    <span class="built_in">updateHeight</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（3）LR型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">LR_Rotation</span><span class="params">(AVLTree &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T-&gt;lchild = <span class="built_in">RR_Rotation</span>(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LL_Rotation</span>(T);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></div>

<p>（4）RL型</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">RL_Rotation</span><span class="params">(AVLTree &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T-&gt;rchild = <span class="built_in">LL_Rotation</span>(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RR_Rotation</span>(T); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>5.平衡二叉树的插入操作：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">Insert</span><span class="params">(AVLTree &amp;T,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)  <span class="comment">//如果T为空，创建新的节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = <span class="keyword">new</span> AVLNode;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;data = x;</span><br><span class="line">        T-&gt;height = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data==x) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;T-&gt;data) <span class="comment">//插入左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;lchild = <span class="built_in">Insert</span>(T-&gt;lchild,x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Height</span>(T-&gt;lchild)-<span class="built_in">Height</span>(T-&gt;rchild)==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;T-&gt;lchild-&gt;data)</span><br><span class="line">                T = <span class="built_in">LL_Rotation</span>(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            	T = <span class="built_in">LR_Rotation</span>(T);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//插入右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;rchild = <span class="built_in">Insert</span>(T-&gt;rchild,x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Height</span>(T-&gt;rchild)-<span class="built_in">Height</span>(T-&gt;lchild)==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;T-&gt;rchild-&gt;data)</span><br><span class="line">                T = <span class="built_in">RR_Rotation</span>(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = <span class="built_in">RL_Rotation</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">updataHeight</span>(T);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>6.平衡二叉树的创建：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">Create</span><span class="params">(AVLTree &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,x;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        T = <span class="built_in">Insert</span>(T,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录23</title>
    <url>/2023/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9523/</url>
    <content><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h3 id="一、红黑树的基本概念："><a href="#一、红黑树的基本概念：" class="headerlink" title="一、红黑树的基本概念："></a>一、红黑树的基本概念：</h3><p>1.红黑树是一种二叉排序树，具有以下的特点：</p>
<p>（1）每个结点或是红色，或是黑色</p>
<p>（2）根结点是黑色</p>
<p>（3）叶结点均是黑色的，叶子结点是NULL</p>
<p>（4）不存在两个相邻的红色结点（红色结点的父结点和孩子结点均是黑色）</p>
<p>（5）对于每个结点，从该结点到任一结点的简单路径上，所含有的黑色结点的数目相同</p>
<p>2.在红黑树中插入和删除时，不需要频繁调整树的形态</p>
<p>3.结点的黑高：从某一个结点出发（不含该结点）到达任一空叶结点的路径上的黑色结点的总数</p>
<p>4.红黑树的性质：</p>
<p>（1）从根节点到叶子结点的最长路径不大于最短路径的2倍</p>
<p>（2）有n个内部节点的红黑树的高度h小于等于2log2(n+1)</p>
<p>5.红黑树的查找：从根结点出发，左小右大，若查找到一个空叶结点，则查找失败</p>
<h3 id="二、红黑树的插入："><a href="#二、红黑树的插入：" class="headerlink" title="二、红黑树的插入："></a>二、红黑树的插入：</h3><p>1.先查找，确定插入的位置（原理同二叉排序树），插入新的结点；新的结点是根，则染成黑色，新的结点非根，则染成红色；若插入新结点之后依然满足红黑树的定义，则插入结束，若插入新的结点后不满足红黑树的定义，需要调整，使其重新满足红黑树的定义</p>
<p>2.调整的策略：看新结点的叔叔结点的颜色</p>
<p>3.当插入节点的父节点为黑色时，不会违反红黑树的规则，无需进行其他操作 </p>
<p>4.当插入节点的父节点为红色时，存在两种情况： </p>
<p>（1）父节点的兄弟节点为红色。这种情况下，将父节点和兄弟节点都着色为黑色，将父节点的父节点（也就是祖父节点）着色为红色，然后以祖父节点为当前节点，继续进行下面的操作 </p>
<p>（2）父节点的兄弟节点为黑色或者为空。这种情况下，需要考虑插入节点和其父节点的位置关系，以及祖父节点是否存在 ：</p>
<p>1&gt;如果插入节点是父节点的左子节点，并且父节点是祖父节点的左子节点（LL情况），则需要进行右旋转操作 </p>
<p>2&gt;如果插入节点是父节点的右子节点，并且父节点是祖父节点的右子节点（RR情况），则需要进行左旋转操作 </p>
<p>3&gt;如果插入节点是父节点的右子节点，并且父节点是祖父节点的左子节点（RL情况），则需要进行先左旋再右旋的操作 </p>
<p>4&gt;如果插入节点是父节点的左子节点，并且父节点是祖父节点的右子节点（LR情况），则需要进行先右旋再左旋的操作 </p>
<h3 id="三、红黑树的删除："><a href="#三、红黑树的删除：" class="headerlink" title="三、红黑树的删除："></a>三、红黑树的删除：</h3><p>1.红黑树的删除结点的处理方式和二叉排序树的删除一样，删除结点后需要进行调整，使之重新满足红黑树的性质</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录24</title>
    <url>/2023/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9524/</url>
    <content><![CDATA[<h1 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h1><h3 id="一、2-3树："><a href="#一、2-3树：" class="headerlink" title="一、2-3树："></a>一、2-3树：</h3><p>1.2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子<br>或三个孩子</p>
<p>2.一个2结点包含一个元素和两个孩子（或者没有孩子），与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素；一个3结点包含一小一大两个元素和三个孩子，一个3结点要么没有孩子，要么有三个孩子</p>
<h3 id="二、2-3-4树："><a href="#二、2-3-4树：" class="headerlink" title="二、2-3-4树："></a>二、2-3-4树：</h3><p>1.2-3-4树中有4结点，一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子<br>树包含大于最大元素的元素</p>
<h3 id="三、B树："><a href="#三、B树：" class="headerlink" title="三、B树："></a>三、B树：</h3><p>1.B树（B-tree）是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶，因此，2-3树是3阶B树，2-3-4树是4阶B树</p>
<p>2.一个m阶的B树具有如下的性质：</p>
<p>（1）如果根结点不是叶子结点，则至少有两颗子树</p>
<p>（2）每一个非根的分支结点都有k-1个元素和k个孩子，其中。每一个叶子结点n都有k-1个元素。其中：所有叶子结点都位于同一层次。所有分支结点包含下列信息数据（n,A0,K1,A1,K2,A2,…,Kn,An）</p>
<h3 id="四、B-树："><a href="#四、B-树：" class="headerlink" title="四、B+树："></a>四、B+树：</h3><p>1.在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针</p>
<p>2.一棵m阶的B+树和m阶的B树的差异在于：</p>
<p>（1）有n棵子树的结点中包含有n个关键字</p>
<p>（2）所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接</p>
<p>（3）所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字</p>
<p>3.B+树的结构适合带有范围的查找</p>
<p>4.B+树的插入、删除过程与B树类似，只不过插入和删除的元素都是在叶子结点上进行的</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录25</title>
    <url>/2023/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9525/</url>
    <content><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h3 id="一、散列表查找："><a href="#一、散列表查找：" class="headerlink" title="一、散列表查找："></a>一、散列表查找：</h3><p>1.散列表是根据关键字直接进行访问的数据结构</p>
<p>2.散列表通过散列函数将关键字映射到存 储地址，建立了关键字和存储地址之间的一种直接映射关系。这里的存储地址可以是数组下 标、索引、内存地址等 </p>
<p>3.散列函数（Hash function），又称为哈希函数，是将关键字映射到存储地址的函数 </p>
<p>4.常见的散列函数有：</p>
<p>（1）直接定址法</p>
<p>（2）除留余数法</p>
<p>（3）随机数法</p>
<p>（4）数字分析法</p>
<p>（5）平方取中法</p>
<p>（6）折叠法</p>
<p>（7）基数转换法</p>
<p>（8）全域散列法</p>
<p>5.散列函数设计中的冲突处理的方法有以下的三种：</p>
<p>（1）开放地址法</p>
<p>根据增量序列的不同，开放地址法又分为线性探测法、二次探测法、随机探测法、再散列法 </p>
<p>（2）链地址法</p>
<p>（3）建立公共溢出区</p>
<p>6.散列表能够快速地查找和插入常见数据类型的数据，对其他数据类型需要相应的转 换。其查找和插入的效率与处理冲突的方法有关，不同的冲突处理方法效率不同 </p>
<p>7.散列表查找的一般步骤：</p>
<p>（1）使用哈希函数将要查找的键转换为散列值 </p>
<p>（2）根据散列值计算出对应的数组索引位置 </p>
<p>（3）在索引位置上查找是否存在对应的键值对，如果存在则返回对应的值，否则表示查找失败 </p>
<p>8.在c++中可以使用标准库中的unordered_map 实现散列表，一些常用的成员函数如下：</p>
<p>（1）insert：插入键值对到散列表中</p>
<p>（2）erase：从散列表中删除特定的键值对</p>
<p>（3）clear：清空散列表中所有的键值对</p>
<p>（4）find：查找特定的键是否存在</p>
<p>（5）at：访问特定键对应的值，如果键不存在则抛出异常</p>
<p>（6）size：返回散列表中键值对的数量</p>
<p>（7）empty：检查散列表是否为空</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录26</title>
    <url>/2023/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9526/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h3 id="一、插入排序："><a href="#一、插入排序：" class="headerlink" title="一、插入排序："></a>一、插入排序：</h3><p>1.插入排序是一种简单直观的排序算法。它的基本思想是将待排序的元素逐个插入到已经有序的部分序列中，直到全部元素都插入完毕 </p>
<p>2.插入排序的具体步骤：</p>
<p>（1）假设第一个元素已经排好序</p>
<p>（2）从第二个元素开始，将它与已排序的部分依次比较 </p>
<p>（3）如果当前元素小于已排序部分的某个元素，则将其插入到该位置，并将后续元素依次后移 </p>
<p>（4）重复第3步，直到所有元素都插入完毕 </p>
<h3 id="二、希尔排序："><a href="#二、希尔排序：" class="headerlink" title="二、希尔排序："></a>二、希尔排序：</h3><p>1.希尔排序又称“缩小增量排序”，将待排序记录按下标的一定增量分组， 对每组记录使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个序列基本有序，再对全部记录进行一次直接插入排序 </p>
<p>2.希尔排序的基本步骤：</p>
<p>（1）设待排序的记录存储在数组 r[1..n]中，增量序列为{d1, d2, …, dt}，n&gt;d1&gt;d2&gt;…&gt;dt&#x3D;1 </p>
<p>（2）第一趟取增量 d1，所有间隔为 d1的记录分在一组，对每组记录进行直接插入排序 </p>
<p>（3）第二趟取增量 d2，所有间隔为 d2的记录分在一组，对每组记录进行直接插入排序 </p>
<p>（4）依次进行下去，直到所取增量 dt&#x3D;1，所有记录在一组中进行直接插入排序 </p>
<h3 id="三、冒泡排序："><a href="#三、冒泡排序：" class="headerlink" title="三、冒泡排序："></a>三、冒泡排序：</h3><p>1.冒泡排序是一种最简单的交换排序算法，通过两两比较关键字，如果逆序就交换， 使关键字大的记录像泡泡一样冒出来放在尾部。重复执行若干次冒泡排序，最终得到有序序列 </p>
<p>2.冒泡排序的基本步骤：</p>
<p>（1）从数组的第一个元素开始，依次比较相邻的两个元素 </p>
<p>（2）如果前一个元素大于后一个元素，则交换它们的位置，使较大的元素“冒泡”到后面 </p>
<p>（3）继续对下一个相邻的元素进行比较和交换，直到将最大的元素排在数组的末尾 </p>
<p>（4）重复步骤1~3，每一轮将当前未排序部分的最大元素放到已排序部分的末尾 </p>
<p>（5）最终整个数组按照升序排列 </p>
<p>3.冒泡排序的时间复杂度为O(n^2)，其中n为待排序元素的个数。它是一个稳定的排序算法，适用于数据量较小或数据已经部分有序的情况 </p>
<h3 id="四、快速排序："><a href="#四、快速排序：" class="headerlink" title="四、快速排序："></a>四、快速排序：</h3><p>1.快速排序是一种高效的排序算法，它采用分治的思想，能够在平均情况下以O(nlogn)的时间复杂度对数组进行排序 </p>
<p>2.快速排序的基本步骤：</p>
<p>（1）选择一个基准元素（pivot），可以是数组中的任意一个元素 </p>
<p>（2）将数组划分为两个子数组，使得左边的子数组中的所有元素都小于等于基准元素，右边的子数组中的所有元素都大于基准元素。这个过程称为分区（partition） </p>
<p>（3）对左右子数组分别进行递归调用快速排序，直到子数组的大小为1或0，即达到了排序的基本情况 </p>
<p>（4）将左子数组、基准元素和右子数组依次拼接起来，得到排序后的数组 </p>
<p>3.快速排序算法的时间复杂度为O(nlogn)，其中n为待排序元素的个数。在最坏情况下，即每次分区都不平衡地划分数组时，时间复杂度退化为O(n^2)。为了避免最坏情况，可以选择合适的基准元素或使用随机化的快速排序算法 </p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录27</title>
    <url>/2023/08/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9527/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h3 id="一、简单选择排序："><a href="#一、简单选择排序：" class="headerlink" title="一、简单选择排序："></a>一、简单选择排序：</h3><p>1.简单选择排序又称为直接选择排序，是一种最简单的选择排序算法，每次从待排序序列 中选择一个最小的放在最前面 </p>
<p>2.简单选择排序的算法步骤如下：</p>
<p>（1）设待排序的记录存储在数组 r[1..n]中，首先从 r[1..n]中选择一个关键字最小的记录 r[k]，r[k]与 r[1]交换 </p>
<p>（2）第二趟排序，从 r[2..n]中选择一个关键字最小的记录 r[k]，r[k]与 r[2]交换 </p>
<p>（3）重复上述过程，经过 n−1 趟排序，得到有序序列 </p>
<ol start="3">
<li></li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SimpleSeleSort</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[j]&lt;r[k])</span><br><span class="line">                k = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = r[i];</span><br><span class="line">            r[i] = r[k];</span><br><span class="line">            r[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="二、堆排序："><a href="#二、堆排序：" class="headerlink" title="二、堆排序："></a>二、堆排序：</h3><p>1.堆排序是一种树形选择排序算法。简单选择排序算法每次选择一个关键字最小的记录需 要 O(n)的时间，而堆排序选择一个关键字最小的记录只需要 O(logn)的时间 </p>
<p>2.堆可以看作一棵完全二叉树的顺序存储结构 。在这棵完全二叉树中，如果每一个节点的 值都大于等于左右孩子的值，称为最大堆（大顶堆）。如果每一个节点的值都小于等于左右 孩子的值，称为最小堆（小顶堆）</p>
<p>3.堆排序的算法步骤：</p>
<p>（1）构建初始堆</p>
<p>（2）堆顶和最后一个记录交换，即r[1]和r[n]交换，将 r[1..n−1]重新调整为堆 </p>
<p>（3）堆顶和最后一个记录交换，即 r[1]和 r[n−1]交换，将 r[1..n−2]重新调整为堆 </p>
<p>（4）循环 n−1 次，得到一个有序序列 </p>
<p>4.堆排序时多次交换关键字，可能会发生相等关键字排序前后位置不一致的情况，因此堆 排序是不稳定的排序方法 </p>
<h3 id="三、合并排序："><a href="#三、合并排序：" class="headerlink" title="三、合并排序："></a>三、合并排序：</h3><p>1.合并排序就是采用分治的策略，将一个大的问题分成若干个小问题，先解决小问题，再 通过小问题解决大问题 </p>
<p>2.合并排序是采用分治策略实现对 n 个元素进行排序的算法，是分治法的一个典型应用和 完美体现 </p>
<p>3.合并排序的算法步骤：</p>
<p>（1）分解—将待排序序列分成规模大致相等的两个子序列 </p>
<p>（2）治理—对两个子序列进行合并排序 </p>
<p>（3）合并—将排好序的有序子序列进行合并，得到最终的有序序列 </p>
<h3 id="四、桶排序："><a href="#四、桶排序：" class="headerlink" title="四、桶排序："></a>四、桶排序：</h3><p>1.桶排序将待排序序列划分成若干个区间，每个区间可形象地看作一个桶，如果桶中的 记录多于一个则使用较快的排序方法进行排序，把每个桶中的记录收集起来，最终得到有序序列 </p>
<p>2.桶排序的算法步骤：</p>
<p>（1）确定桶的数量，并创建对应数量的空桶。桶的数量可以根据待排序数组的范围和数据分布情况来确定 </p>
<p>（2）将待排序的数据依次分配到对应的桶中。具体的分配方式可以使用线性映射函数，将数据映射到桶的索引上 </p>
<p>（3）对每个非空的桶进行单独排序。可以选择使用其他排序算法，比如插入排序、快速排序等。也可以使用递归的方式继续使用桶排序 </p>
<p>（4）将所有非空桶中的元素按照顺序合并起来，形成有序的结果数组 </p>
<h3 id="五、外部排序："><a href="#五、外部排序：" class="headerlink" title="五、外部排序："></a>五、外部排序：</h3><p>1.外部排序是一种用于处理大规模数据的排序算法，其中待排序的数据无法全部加载到内存中进行排序 </p>
<p>2.在外部排序中，数据被分割成多个较小的块，并通过磁盘或文件系统进行读取和写入。这样可以将数据分为适应内存的大小，并对每个分块进行排序。最后，对已排序的分块进行合并，生成完整的有序数据 </p>
<p>3.外部排序的基本步骤：</p>
<p>（1）将待排序的大规模数据分割成适当大小的块，并一次性读取一块数据到内存中 </p>
<p>（2）对每个块进行排序。可以使用内存中的排序算法，如快速排序或归并排序 </p>
<p>（3）将排序后的块写回磁盘，并按照顺序进行编号，以便在后续合并阶段能够准确地读取并合并块 </p>
<p>（4）重复步骤1-3，直到将所有数据都分割成了排序好的块，并写回磁盘 </p>
<p>（5）对已排序的块进行合并。可以采用合并排序算法，将多个块逐个合并为一个有序的大块 </p>
<p>合并后的结果是完整的有序数据</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习记录5</title>
    <url>/2023/08/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="一、计算机网络的定义："><a href="#一、计算机网络的定义：" class="headerlink" title="一、计算机网络的定义："></a>一、计算机网络的定义：</h3><p>1.计算机网络只要是由一些通用的、可编程的硬件互连而成的，这些硬件并非专门用来实现某一个特定目的</p>
<p>2.计算机网络并非只能进行数据传输，而是能够基于数据传送实现各种各样的应用</p>
<p>3.计算机网络的分类：</p>
<p>（1）按照交换方式分类：分组交换、报文交换、电路交换</p>
<p>（2）按照使用者分类：公用网、专用网</p>
<p>（3）按照传输介质分类：有线网络、无线网络</p>
<p>（4）按照覆盖范围分类：广域网（WAN）、城域网（MAN）、局域网（LAN）、个域网（PAN）</p>
<p>（5）按照拓扑结构分类：总线型、星型、环型、网状型</p>
<h3 id="二、计算机网络的性能指标："><a href="#二、计算机网络的性能指标：" class="headerlink" title="二、计算机网络的性能指标："></a>二、计算机网络的性能指标：</h3><p>1.计算机网络的性能指标被用来从不同方面度量计算机网络的性能</p>
<p>2.bite是计算机中数据量的基本单位，一个比特就是二进制数字中的一个1或0</p>
<p>3.速率是指数据的传输率（每秒传送多少个比特），也称为数据率或比特率</p>
<p><a href="https://imgse.com/i/pPMtFeg"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/08/14/pPMtFeg.png"
                      alt="pPMtFeg.png"
                ></a></p>
<p>4.带宽：用来表示网络的通信线路所能传送数据的能力，单位时间内从网络的某一点到另外一点所能通过的最高数据率</p>
<p>5.吞吐量：单位时间内通过某个网络或接口的实际数据量。吞吐量常被用来对实际网络的测量，以便获知到底有多少数据通过了网络</p>
<p>吞吐量受到网络带宽的限制</p>
<p>6.时延：数据从网络的一端传送到另外一端所耗费的时间，也称为延迟或迟延，数据可以由一个多个分组、甚至是一个比特构成</p>
<p>时延由发送时延、传播时延、排队时延、和处理时延构成</p>
<p>7.时延带宽积：时延与带宽的乘积</p>
<p>链路的时延带宽积又称为以比特为单位的链路长度</p>
<p>8.利用率：信道利用率和网络利用率</p>
<p>信道利用率并非越高越好</p>
<p>9.丢包率：分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量和总的分组数量的比率</p>
<p>分组丢失的两种情况：</p>
<p>（1）分组在传输的过程中出现误码，被结点丢弃</p>
<p>（2）分组到达一台队列已满的分组交换机时被丢弃；在通信量较大时就可能造成网络拥塞</p>
<p>丢包率反映了网络的拥塞情况</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
