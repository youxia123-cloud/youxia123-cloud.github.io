<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2023/01/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><p>从今天起，正式开始写博客啦。这次用hexo搭建博客还有许多要完善的地方。一些小的细节方面后续也会持续改进。最近其实还是比较忙的，这次也算是一个总结和记录吧（虽说也没有做啥总结）。总之，依然要做好安排，不断学习，不断进步。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Start</title>
    <url>/2023/01/08/Start/</url>
    <content><![CDATA[<h2 id="1月8日记录"><a href="#1月8日记录" class="headerlink" title="1月8日记录"></a>1月8日记录</h2><p>今天用hexo框架搭建了属于自己的博客，还是很开心的，虽然遇到了许多困难，但是我还是一步一步的实现了自己的博客。感觉很开心。也希望自己以后不断学习，不断提高自己的技术，在IT的旅途上追逐梦想，扬帆起航。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录1</title>
    <url>/2023/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="串和广义表"><a href="#串和广义表" class="headerlink" title="串和广义表"></a>串和广义表</h1><h3 id="串的定义和运算"><a href="#串的定义和运算" class="headerlink" title="串的定义和运算"></a>串的定义和运算</h3><p>1.串是由零个或任意多个字符组成的有限序列<br>2.子串是串中任意连续的字符组成的子序列<br>注：空串是任意串的子串，任意串是自身的子串<br>3.模式匹配是一种求子串在主串中第一次出现的第一个字符的位置<br>4.串的操作有很多种，比如赋值，复制，求串的长度，串的连接，插入删除等等<br>5.串的存储结构有顺序存储和链式存储<br>6.在实际应用中，可以采用堆分配存储（动态存储）<br>堆分配存储的方法：<br>（1）开辟一块地址连续的存储空间，该存储空间称为“堆”<br>（2）建立一个索引表，用来存储串的名字，长度和该串在堆中的起始位置<br>（3）程序执行过程中，每产生一个串，系统就从堆中分配一块大小和串长度相等的连续空间，用来存储该串的值，并且在索引表中增加一个索引项，用于记录串的信息。</p>
<h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p>1.广义表是n个数据元素的有序序列，它是线性表的推广，也称为“列表”<br>2.广义表是一种多层次的数据结构，其中的元素可以是单元素，也可以是子表<br>3.广义表可以是递归的表，即它可以是自身的子表<br>4.广义表可以被其他表所共享<br>5.广义表常采用链式存储结构，有头尾表示法和孩子兄弟表示法两种存储方式</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习纪录2</title>
    <url>/2023/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%BA%AA%E5%BD%952/</url>
    <content><![CDATA[<h1 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h1><h3 id="树的定义："><a href="#树的定义：" class="headerlink" title="树的定义："></a>树的定义：</h3><p>1.树是n（n&gt;&#x3D;0）个有限数据元素的集合。</p>
<p>2.树满足的条件：</p>
<p>（1）有且仅有一个根节点</p>
<p>（2）其余的节点分为m（m&gt;&#x3D;0）个互不相交的非空集合，其中每个集合本身就是一棵树，称为根的子树</p>
<h3 id="树的表示方法："><a href="#树的表示方法：" class="headerlink" title="树的表示方法："></a>树的表示方法：</h3><p>1.树形表示法</p>
<p>2.嵌套集合表示法</p>
<p>3.凹入表示法</p>
<p>4.广义表示法</p>
<h3 id="树的基本术语："><a href="#树的基本术语：" class="headerlink" title="树的基本术语："></a>树的基本术语：</h3><p>1.结点：树的结点包含一个数据元素及若干指向其子树的分支</p>
<p>2.结点的度：结点所拥有的分支数目或后继结点个数</p>
<p>3.树的度：树中各结点度的最大值</p>
<p>4.叶子（终端结点）：度为零的结点称为叶子结点</p>
<p>5.分支（非终端结点）：度不为零的结点</p>
<p>6.孩子结点：一个结点的后继称为该结点的孩子结点</p>
<p>7.双亲结点：一个结点是其后继结点的双亲节点</p>
<p>8.兄弟结点：同一个双亲结点下的孩子节点互称为兄弟结点</p>
<p>9.堂兄弟：双亲互为兄弟的两个结点互称为堂兄弟</p>
<p>10.子孙结点：一个结点的所有子树的结点</p>
<p>11.祖先结点：从树根结点到达一个结点路径上的所有结点称为该结点的祖先结点</p>
<p>12.结点的层次：根结点的层次为1，其余结点的层次等于它双亲结点的层次加一</p>
<p>13.树的深度：树中结点的最大层次称为树的深度（或高度）</p>
<p>14.有序树、无序树：交换某结点各子树的相对位置，会构成不同的树，这样的树称为有序树，反之则是无序树</p>
<p>15.森林：m（m&gt;&#x3D;0）棵互不相交的树的集合</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>1.二叉树是有n（n&gt;&#x3D;0）个结点的有限集合，该集合或者为空，或者由一个根结点及两个不相交的子树组成（左子树和右子树）</p>
<p>2.左子树和右子树同样都是二叉树</p>
<p>3.二叉树是特殊的有序树</p>
<p>4.二叉树的性质：</p>
<p>（1）在二叉树的第i层至多有2^(i-1)个结点</p>
<p>（2）深度为h的二叉树中至多有(2^h) - 1结点</p>
<p>（3）对任意一棵二叉树T，如果其叶子结点数为n0，度为2的结点数为n2，则有n0 &#x3D; n2 + 1</p>
<p>（4）具有n个结点的完全二叉树的深度为log2n（以2为底的对数） + 1</p>
<p>（5）如果一棵n个结点的完全二叉树的结点按层次有：</p>
<p>如果i&#x3D;1，结点i是根结点，无双亲；如果i&gt;1。则其双亲结点是结点i&#x2F;2</p>
<p>如果2i&gt;n，则结点i无左孩子，该结点为叶子结点；否则其左孩子是结点2i</p>
<p>如果2i+1&gt;n，则结点i无右孩子，该结点为叶子结点；否则其右孩子是结点2i+1</p>
<p>5.二叉树的存储结构：</p>
<p>（1）顺序存储</p>
<p>（2）链式存储</p>
<p>6.二叉树的遍历方式：</p>
<p>（1）先序遍历：根—-左—–右</p>
<p>（2）中序遍历：左—-根—-右</p>
<p>（3）后序遍历：左—-右—-根</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习记录1</title>
    <url>/2023/01/19/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h3 id="一、选择排序"><a href="#一、选择排序" class="headerlink" title="一、选择排序"></a>一、选择排序</h3><p>1.每一趟从待排序的数据元素中选择最小（或最大）的一个元素，顺序放在待排序的数组最前面，直到数据元素全部排完为止。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1001</span>;</span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,k,i,j;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">		k = i;</span><br><span class="line">		<span class="keyword">for</span>(j = i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;a[k]) k = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k!=i)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = a[i];</span><br><span class="line">			a[i] = a[k];</span><br><span class="line">			a[k] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h3><p>1.n个数据元素，从第一个开始，依次比较相邻的两个是否顺序，如果不满足就交换。直到n-1和n相比，经过n-1轮后，得到有序的队列</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">10001</span>; </span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> flag;</span><br><span class="line">	<span class="type">int</span> n,j;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)  <span class="comment">//n-1轮冒泡排序</span></span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)  <span class="comment">//进行i次的比较</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">swap</span>(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;  <span class="comment">//没有进行交换，直接退出循环</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h3><p>1.当读入一个数据元素时，在已经排序好的序列中，寻找它正确的位置放入。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,i,j,k,temp;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;a[i]) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j!=i<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">			temp = a[i];</span><br><span class="line">			<span class="keyword">for</span>(k=i<span class="number">-1</span>;k&gt;j;k--)</span><br><span class="line">				a[k+<span class="number">1</span>] = a[k];</span><br><span class="line">			a[k+<span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="四、桶排序"><a href="#四、桶排序" class="headerlink" title="四、桶排序"></a>四、桶排序</h3><p>1.若待排序的值在一个明显有限的范围内，可设计有限个有序桶，待排序的值装入相对应的桶，顺序输出各桶的值就可以得到有序的序列。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b[<span class="number">101</span>],n,i,k;</span><br><span class="line">	<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		b[k]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(b[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">			cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			b[i]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="五、快速排序"><a href="#五、快速排序" class="headerlink" title="五、快速排序"></a>五、快速排序</h3><p>1.快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将待排序的序列分为两部分，其中一部分中的每一个数都比另一部分小，则可以对这两部分继续进行排序，最终使得整个序列有序。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> x = q[l],i = l<span class="number">-1</span>,j =r+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">		<span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">		<span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h3><p>1.归并排序算法采用的是分治算法,即把两个(或两个以上)有序表合并成一个新的有序表,把待排序的序列分成若干个子序列,每个子序列都是有序的,然后把有序子序列合并成整体有序序列 。若将两个有序表合并成一个有序表，称为二路归并。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">100001</span>;</span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = low,j = mid + <span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span> [high-low+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">		<span class="keyword">if</span>(arr[i]&lt;=arr[j])</span><br><span class="line">		&#123;</span><br><span class="line">			temp[k++] = arr[i++]; <span class="comment">//较小的哪一个先存入temp数组中</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			temp[k++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">		temp[k++] = arr[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">		temp[k++] = arr[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=low,k=<span class="number">0</span>;i&lt;=high;i++,k++)</span><br><span class="line">		arr[i] = temp[k];</span><br><span class="line">	<span class="keyword">delete</span> []temp; <span class="comment">//释放数组空间，必须用delete[]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &gt;= high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">MergeSort</span>(arr,low,mid);</span><br><span class="line">		<span class="built_in">MergeSort</span>(arr,mid+<span class="number">1</span>,high);</span><br><span class="line">		<span class="built_in">Merge</span>(arr,low,mid,high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">MergeSort</span>(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习记录3</title>
    <url>/2023/01/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h1><h3 id="图的定义："><a href="#图的定义：" class="headerlink" title="图的定义："></a>图的定义：</h3><p>1.图是一个由非空的顶点集合和一个描述顶点之间的关系即边（Edges）的有限集合组成的一种数据结构。</p>
<p>可以定义为一个二元组：</p>
<p>G&#x3D;（V,E）</p>
<p>V是顶点集合，E是边的集合</p>
<p>2.按照图中的边是否有方向，图分为有向图和无向图两类</p>
<h3 id="图的相关术语："><a href="#图的相关术语：" class="headerlink" title="图的相关术语："></a>图的相关术语：</h3><p>（1）无向图：在一个图中，每条边都没有方向</p>
<p>（2）有向图：在一个图中，每条边都有方向</p>
<p>（3）无向完全图：在一个无向图中，任意两个顶点都有一条直接边相连。在一个含有n个顶点的无向完全图中，有（n-1）n&#x2F;2 条边</p>
<p>（4）有向完全图：在一个有向图中，任意两顶点之间都有方向互为相反的两条弧相连接</p>
<p>（5）顶点的度：一个顶点所拥有的边数</p>
<p>（6）顶点的入度：在有向图中，一个顶点拥有的弧头的数目</p>
<p>（7）顶点的出度：在有向图中，一个顶点拥有的弧尾的数目</p>
<p>一个顶点的度 &#x3D;  顶点的入度 + 顶点的出度</p>
<p>（8）权：图的边或弧有时具有与它相关的数据信息，这个数据信息称为权（权重）</p>
<p>（9）网：带权的图称为网，同样可以分为有向网和无向网</p>
<p>（10）回路或环：在一个路径中，若其第一个顶点和最后一个顶点是相同的，则称该路径为一个回路或环</p>
<p>（11）简单路径：表示路径的顶点序列中的顶点各不相同</p>
<p>（12）简单回路：除了第一个和最后一个顶点之外，其余各顶点均不重复出现</p>
<p>（13）稀疏图：有很少条边的图称为稀疏图</p>
<p>（14）连通图：无向图中，任意两个顶点都是连通的图称为连通图。无向图的极大连通子图称为连通分量</p>
<p>（15）强连通图：对于有向图来说，图中任意一对顶点Vi和Vj均有从一个顶点Vi到另一个顶点Vj有路径，也有从Vj到Vi的路径，则称该有向图是强连通图。有向图的极大强连通子图称为强连通分量</p>
<p>（16）生成树：连通图G的一个子图如果是一棵包含G的所有顶点的树，则该子图称为G的生成树</p>
<h3 id="图的存储结构："><a href="#图的存储结构：" class="headerlink" title="图的存储结构："></a>图的存储结构：</h3><p>（1）邻接矩阵</p>
<p>（2）邻接表</p>
<h3 id="图的遍历："><a href="#图的遍历：" class="headerlink" title="图的遍历："></a>图的遍历：</h3><p>1.深度优先搜索（DFS）</p>
<p>2.广度优先搜索（BFS）</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习记录2</title>
    <url>/2023/01/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="搜索与回溯"><a href="#搜索与回溯" class="headerlink" title="搜索与回溯"></a>搜索与回溯</h1><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>1.深度优先搜索类似于树的先序遍历，是树的先序遍历的推广</p>
<p>2.深度优先搜索方法：</p>
<p>（1）首先从图中某个顶点v出发，首先访问此顶点，将其标记为已经访问</p>
<p>（2）任选一个v的未被访问的邻接点w出发，继续进行深度优先搜索</p>
<p>（3）直到图中所有和v路径想通的顶点被访问到</p>
<p>（4）若此时还有顶点未访问，则选另一个顶点作为起始点，重复上述步骤，直到所有的顶点都被访问为止。</p>
<h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><ol>
<li>广度优先搜索类似于树的按层次遍历</li>
<li>广度优先搜索的思想：</li>
</ol>
<p>（1）从图中的某一个顶点V0开始，访问V0，</p>
<p>（2）访问与V0相邻接的顶点V1，V2，……Vt</p>
<p>（3）依次访问与V1，V2，……..Vt相邻接的点</p>
<p>（4）循环进行，直到所有的顶点都被访问</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>1.回溯法是从初始状出发，按照深度优先搜索的方式，根据产生子结点的条件约束，搜索问题的解。当发现当前节点满足不了求解条件时，就回溯，尝试其他的路径。</p>
<p>注：在搜索中，常采用剪枝的策略进行优化</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习记录3</title>
    <url>/2023/01/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="贪心和分治"><a href="#贪心和分治" class="headerlink" title="贪心和分治"></a>贪心和分治</h1><h3 id="一、贪心算法"><a href="#一、贪心算法" class="headerlink" title="一、贪心算法"></a>一、贪心算法</h3><p>1.选择贪心策略，根据贪心策略，一步一步地得到局部最优解，最后把所有的局部最优解合成原来问题的一个最优解。</p>
<p>2.基本思路：</p>
<p>（1）建立数学模型来描述问题</p>
<p>（2）把求解的问题分成若干个子问题</p>
<p>（3）对每一个子问题求解，得到子问题的局部最优解</p>
<p>（4）把子问题的局部最优解合成原来问题的一个解</p>
<p>3.适用的问题：</p>
<p>局部最优的策略能导致产生全局最优解</p>
<h3 id="二、分治算法"><a href="#二、分治算法" class="headerlink" title="二、分治算法"></a>二、分治算法</h3><p>1.所谓分治，就是分而治之，将大规模的问题分解成几个小规模的问题。通过求解小规模的问题来求出大规模问题的解。</p>
<p>2.当我们将问题分解成两个较小问题求解时的分治称为二分法</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习记录4</title>
    <url>/2023/01/22/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>1.动态规划是解最优化问题的一种途径，一种方法。</p>
<p>2.多阶段决策问题：</p>
<p>一个问题可以看作是一个前后关联具有链状结构的多阶段过程。</p>
<p>3.多阶段决策过程是指一类特殊的活动过程，问题可以按时间顺序分解成若干相互联系的阶段，在每一个阶段都要作出决策，全部过程的决策是一个决策序列。</p>
<p>4.相关的概念：</p>
<p>（1）阶段和阶段变量</p>
<p>（2）状态和状态变量</p>
<p>（3）决策、决策变量和决策允许集合</p>
<p>（4）策略和最优策略</p>
<p>（5）状态转移方程</p>
<p>5.能够用动态规划解决的问题必须满足的条件：</p>
<p>最优化原理和无后效性原则</p>
<p>6.解题步骤：</p>
<p>（1）阶段</p>
<p>（2）状态</p>
<p>（3）决策</p>
<p>（4）策略</p>
<p>（5）状态转移方程</p>
<p>7.注意事项：</p>
<p>（1）确定好dp数组以及下标的含义</p>
<p>（2）确定递推公式</p>
<p>（3）dp数组的初始化</p>
<p>（4）确定遍历顺序</p>
<p>（5）推导dp数组</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习记录1</title>
    <url>/2023/01/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h1><p>1.计算机系统：包含硬件系统和软件系统</p>
<p>2.硬件：借助电、磁、光、机械等原理构成的各种物理部件的有机组合，是系统工作的实体</p>
<p>主要有CPU，主存储器，I&#x2F;O控制系统，外围设备</p>
<p>（1）中央处理器：包含运算单元和控制单元</p>
<p>（2）外围设备：输入、输出设备</p>
<p>（3）总线（BUS）是计算机各种功能部件之间传送信息的公共通信干线，它是CPU、内存、输入输出设备传递信息的公用通道。包括控制总线、地址总线、数据总线</p>
<p>计算机的各个部件通过总线相连接</p>
<p>总线的类型：</p>
<p>内部总线</p>
<p>系统总线</p>
<p>通信总线</p>
<p>（4）CPU：中央处理器是计算机的运算核心，主要包括运算逻辑单元，寄存器部件，控制部件</p>
<p>（5）存储器：</p>
<p>cache：高速缓存</p>
<p>SARM：静态随机存储器</p>
<p>DARM：动态随机存储器（主存）</p>
<p>3.软件：各种程序和文件，用于指挥计算机系统按指定的要求进行协同工作</p>
<p>包括系统软件、支撑软件和应用软件</p>
<p>关键的系统软件是：操作系统和语言处理系统</p>
<p>（1）系统软件：</p>
<p>操作系统、实用程序、语言处理程序、数据库管理程序</p>
<p>（2）支撑软件：</p>
<p>接口软件、工具软件、软件数据库、</p>
<p>（3）应用软件：</p>
<p>用户按其需要自行编写的专用程序</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录1</title>
    <url>/2023/01/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h3 id="一、评估方法"><a href="#一、评估方法" class="headerlink" title="一、评估方法"></a>一、评估方法</h3><p>（获得测试结果）</p>
<h4 id="测试集的获取："><a href="#测试集的获取：" class="headerlink" title="测试集的获取："></a>测试集的获取：</h4><p>1.测试集和训练集应该互斥</p>
<p>2.常见的获取测试集的方法：</p>
<p>（1）留出法：</p>
<p>保持数据的一致性，如分层采样；多次重复划分；测试集不能太大，也不能太小</p>
<p>（2）交叉验证法</p>
<p>k折交叉验证</p>
<p>（3）自助法：自助采样</p>
<h3 id="二、调参与验证集"><a href="#二、调参与验证集" class="headerlink" title="二、调参与验证集"></a>二、调参与验证集</h3><h4 id="调参与最终模型："><a href="#调参与最终模型：" class="headerlink" title="调参与最终模型："></a>调参与最终模型：</h4><p>1.算法的参数：一般由人工设定，亦称为“超参数”</p>
<p>2.模型的参数：一般由学习确定</p>
<p>3.调参过程相似：先产生若干模型，然后基于某种评估方法进行选择</p>
<p>4.验证集：训练集中专门用来调参数的过程</p>
<h3 id="三、性能度量"><a href="#三、性能度量" class="headerlink" title="三、性能度量"></a>三、性能度量</h3><p>（评估性能的优劣）</p>
<p>1.性能度量是衡量模型泛化能力的评估标准，反映了任务需求。使用不同的性能度量往往会导致不同的评估结果。</p>
<p>2.什么样的模型是“好”的，不仅取决于算法和数据，还取决于任务需求。</p>
<p>3.回归任务常采用均方误差</p>
<p>4.对于分类任务，可以得到混淆矩阵。根据混淆矩阵，得到查准率（P）和查全率（R），进而得到F1度量<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.6ex;" xmlns="http://www.w3.org/2000/svg" width="20.533ex" height="4.636ex" role="img" focusable="false" viewBox="0 -1342 9075.4 2049"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(594.5,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mrow" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mn" transform="translate(749,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><rect width="1449" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(1966.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(3022.6,0)"><g data-mml-node="mn" transform="translate(220,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mn" transform="translate(220,-686)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="700" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(4184.8,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="mo" transform="translate(4685,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mfrac" transform="translate(5074,0)"><g data-mml-node="mn" transform="translate(345.5,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(220,-686)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><rect width="951" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(6487.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mfrac" transform="translate(7487.4,0)"><g data-mml-node="mn" transform="translate(349.5,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(220,-686)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><rect width="959" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8686.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
<h3 id="四、比较检验"><a href="#四、比较检验" class="headerlink" title="四、比较检验"></a>四、比较检验</h3><p>（判断实质差别）</p>
<p>1.在某种度量下取得评估结果后，不能直接比较以评判优劣</p>
<p>2.t检验</p>
<p>3.卡方检验</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录2</title>
    <url>/2023/01/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h1><h4 id="一、线性回归"><a href="#一、线性回归" class="headerlink" title="一、线性回归"></a>一、线性回归</h4><p>1.线性回归要把离散转换为连续</p>
<p>2.离散属性的处理：</p>
<p>若有序，则连续化；否则，转换为k维向量</p>
<p>3.使用最小二乘法求解目标函数的最小值</p>
<h4 id="二、多元线性回归"><a href="#二、多元线性回归" class="headerlink" title="二、多元线性回归"></a>二、多元线性回归</h4><p>1.引入正则化（归纳偏好）</p>
<h4 id="三、广义线性模型"><a href="#三、广义线性模型" class="headerlink" title="三、广义线性模型"></a>三、广义线性模型</h4><p>1.对数线性回归，用线性回归来逼近对数的目标</p>
<h4 id="四、对率回归（logistic-regression）"><a href="#四、对率回归（logistic-regression）" class="headerlink" title="四、对率回归（logistic regression）"></a>四、对率回归（logistic regression）</h4><p>1.二分类任务，使用对率函数</p>
<p>2.对率回归的优点：</p>
<p>（1）无需事先假设数据分布</p>
<p>（2）可得到“类别”的近似概率预测</p>
<p>（3）可直接应用现有的数值优化算法求取最优解</p>
<p>3.对率回归是分类学习算法</p>
<h4 id="五、类别不平衡"><a href="#五、类别不平衡" class="headerlink" title="五、类别不平衡"></a>五、类别不平衡</h4><p>1.不同类别的样本比例相差很大，“小类”往往更重要</p>
<p>2.常用的类别不平衡学习方法：</p>
<p>（1）过采样</p>
<p>（2）欠采样</p>
<p>（3）阈值移动</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录3</title>
    <url>/2023/01/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h1><p>之前只是听说过xgboost这个模型，但是没有具体的学习。这次的学习总结就来具体的认识xgboost，这里没有深入的研究其中的数学原理，仅仅是从初学者的角度来认识，一些地方存在错误是在所难免的，希望大家多多指正交流。</p>
<p>1.Xgboost是一个监督模型，其对应于特殊的决策树——分类回归树（CART树）</p>
<p>2.用CART树做预测：将各个树的预测分数相加</p>
<p>3.对于监督学习来说，建立模型后的参数调整是非常重要的，知识藏在这些参数之中</p>
<p>4.xgboost的目标函数包含了损失函数和正则项</p>
<p>5.xgboost模型由CART树组成，参数存在于每棵CART树中</p>
<p>6.xgboost用GBDT（梯度提升树）算法分步骤优化目标函数，先优化第一棵树，在优化第二棵，直到第k棵</p>
<p>7.由官方的文档我们可以得知，xgboost代表极端梯度提升</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录4</title>
    <url>/2023/01/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h1 id="Sklearn"><a href="#Sklearn" class="headerlink" title="Sklearn"></a>Sklearn</h1><h3 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h3><p>1.sklearn是一个开源的python机器学习算法库</p>
<h3 id="二、-线性分类"><a href="#二、-线性分类" class="headerlink" title="二、 线性分类"></a>二、 线性分类</h3><p>1.鸢尾花数据的分类：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X_iris,y_iris = iris.data,iris.target</span><br><span class="line">X,y = X_iris[:, :<span class="number">2</span>],y_iris</span><br><span class="line"><span class="comment"># print(X.shape)</span></span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="number">0.25</span>,random_state=<span class="number">33</span>)</span><br><span class="line"><span class="built_in">print</span>(X_train.shape,y_train.shape)</span><br><span class="line"></span><br><span class="line">scaler = preprocessing.StandardScaler().fit(X_train)</span><br><span class="line">X_train = scaler.transform(X_train)</span><br><span class="line">X_test  = scaler.transform(X_test)</span><br><span class="line"></span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;greenyellow&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(colors)):</span><br><span class="line">	xs = X_train[:,<span class="number">0</span>][y_train == i]</span><br><span class="line">	ys = X_train[:,<span class="number">1</span>][y_train == i]</span><br><span class="line">	plt.scatter(xs,ys,c=colors[i])</span><br><span class="line">plt.legend(iris.target_names)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sepal length&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Sepal width&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 山鸢尾setosa</span></span><br><span class="line"><span class="comment"># 杂色鸢尾vcersicolor</span></span><br><span class="line"><span class="comment"># 弗吉尼亚鸢尾 virginca0</span></span><br><span class="line"><span class="comment"># 上面的模型对山鸢尾的分类效果很好，但是不能将杂色鸢尾和弗吉尼亚鸢尾很好的分开</span></span><br></pre></td></tr></table></figure></div>

<p>2.在线性模型中使用梯度下降法：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X_iris,y_iris = iris.data,iris.target</span><br><span class="line">X,y = X_iris[:, :<span class="number">2</span>],y_iris</span><br><span class="line"><span class="comment"># print(X.shape)</span></span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="number">0.25</span>,random_state=<span class="number">33</span>)</span><br><span class="line"><span class="built_in">print</span>(X_train.shape,y_train.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clf = SGDClassifier()</span><br><span class="line">clf.fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(clf.coef_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sklearn中的三种流行的评估函数</span></span><br><span class="line"><span class="comment"># 精确率</span></span><br><span class="line"><span class="comment"># 召回率</span></span><br><span class="line"><span class="comment"># F1度量</span></span><br><span class="line">y_train_pred = clf.predict(X_train)</span><br><span class="line"><span class="built_in">print</span>(metrics.accuracy_score(y_train,y_train_pred))</span><br><span class="line">y_pred = clf.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(metrics.accuracy_score(y_test,y_pred))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(metrics.classification_report(y_test,y_pred,target_names=iris.target_names))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------------&quot;</span>)</span><br><span class="line"><span class="comment"># 打印混淆矩阵</span></span><br><span class="line"><span class="built_in">print</span>(metrics.confusion_matrix(y_test,y_pred))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="二、支持向量机和图像识别"><a href="#二、支持向量机和图像识别" class="headerlink" title="二、支持向量机和图像识别"></a>二、支持向量机和图像识别</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_olivetti_faces</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score,KFold</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> sem</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">faces = fetch_olivetti_faces()</span><br><span class="line"><span class="built_in">print</span>(faces.DESCR)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(faces.keys())</span><br><span class="line"></span><br><span class="line">svc_1 = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(faces.data,faces.target,test_size=<span class="number">0.25</span>,random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evalute_cross_validation</span>(<span class="params">clf,X,y,K</span>)</span><br><span class="line">    cv = KFold(<span class="built_in">len</span>(y),K,shuffle=<span class="literal">True</span>,random_state=<span class="number">0</span>)</span><br><span class="line">    scores = cross_val_score(clf,X,y,cv=cv)</span><br><span class="line">    <span class="built_in">print</span>(scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Mean score:&#123;0:.3f&#125;(+/-&#123;1:.3f&#125;))&quot;</span>.<span class="built_in">format</span>(np.mean(scores),sem(scores))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">evalute_cross_validation(svc_1,X_train,y_train,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_and_evaluate</span>(<span class="params">clf,X_train,X_test,y_train,y_test</span>):</span><br><span class="line">    clf.fit(X_train,y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Accuracy on training set:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(clf.score(X_train,y_train))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Accuracy on testing set:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(clf.score(X_test,y_test))</span><br><span class="line">    y_pred = clf.predict(X_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Classification Report:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(metrics.classification_report(y_test,y_pred))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Confusion Matrix:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(metrics.confusion_matrix(y_test,y_pred))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_and_evaluate(svc_1,X_train,X_test,y_train,y_test)</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录5</title>
    <url>/2023/01/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</url>
    <content><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><h3 id="一、决策树模型："><a href="#一、决策树模型：" class="headerlink" title="一、决策树模型："></a>一、决策树模型：</h3><p>1.决策树基于“树”的结构进行决策</p>
<p>每个“内部”结点对应某个属性上的“测试”</p>
<p>每个分支对应于该测试的一种可能结果（即该属性的某个取值）</p>
<p>每个“叶结点”对应于一个“预测结果”</p>
<p>2.学习过程：</p>
<p>通过对训练样本的分析来确定“划分属性”（即内部结点所对应的属性）</p>
<p>3.预测过程：</p>
<p>将测试实例从根结点开始，沿着划分属性所构成的“判定测试序列”下行，直到叶结点	</p>
<p>4.三种停止的条件：</p>
<p>（1）当前结点包含的样本全属于同一类别，无需划分；</p>
<p>（2）当前属性集为空，或是所有样本在所有属性上的取值相同，无需划分</p>
<p>（3）当前结点所包含的样本集合为空，不能划分</p>
<h3 id="二、信息增益的划分："><a href="#二、信息增益的划分：" class="headerlink" title="二、信息增益的划分："></a>二、信息增益的划分：</h3><p>1.信息增益直接以信息熵为基础，计算当前划分对信息熵所造成的影响（ID3算法使用）</p>
<h3 id="三、其他属性的划分："><a href="#三、其他属性的划分：" class="headerlink" title="三、其他属性的划分："></a>三、其他属性的划分：</h3><p>1.增益率</p>
<p>2.启发式：先从候选划分属性中找到信息增益高于平均水平的，再从中选取增益率最高的（C4.5算法使用）</p>
<p>3.基尼系数</p>
<p>在候选属性集合中，选取那个使划分后基尼系数最小的属性（CART算法使用）</p>
<h3 id="四、决策树的剪枝："><a href="#四、决策树的剪枝：" class="headerlink" title="四、决策树的剪枝："></a>四、决策树的剪枝：</h3><p>1.剪枝是决策树用来防止过拟合的主要手段</p>
<p>2.基本策略：</p>
<p>预剪枝</p>
<p>后剪枝</p>
<p>3.在使用单个决策树的时候，一定要考虑剪枝</p>
<h3 id="五、缺失值的处理："><a href="#五、缺失值的处理：" class="headerlink" title="五、缺失值的处理："></a>五、缺失值的处理：</h3><p>1.样本赋权，权重划分</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习记录1</title>
    <url>/2023/01/28/java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="一、面向对象的概念："><a href="#一、面向对象的概念：" class="headerlink" title="一、面向对象的概念："></a>一、面向对象的概念：</h3><p>1.在面向对象（oop）中，程序被看做相互协作的对象集合，每个对象都是某个类的实例，所有类构成一个通过继承关系相联系的层次结构。</p>
<p>2.面向对象的特性：</p>
<p>封装、继承、多态</p>
<h3 id="二、类和对象："><a href="#二、类和对象：" class="headerlink" title="二、类和对象："></a>二、类和对象：</h3><p>1.在java中使用class关键字来定义类，使用new关键字可以实例化一个对象。</p>
<p>2.可以在类体中声明两种类的成员：成员变量和成员方法</p>
<p>成员变量是类的属性</p>
<p>3.一个方法最多只能有一个变长参数</p>
<p>4.this关键字指向的是当前对象的引用 </p>
<p>5.系统常用的类：</p>
<p>Date类、GregorianCalendar类</p>
<h3 id="三、访问控制符："><a href="#三、访问控制符：" class="headerlink" title="三、访问控制符："></a>三、访问控制符：</h3><p>1.java中有公共的（public）、私有的（private）、保护的（protected）和默认的（default）四种访问控制符</p>
<p>public：所定义的类中的成员变量或方法能够被其他包中的类所访问</p>
<p>default：什么访问控制符都不加，就是默认访问级别，表示一个类的资源仅允许在包内访问，同一子类不能访问</p>
<p>protected：定义为保护级别的成员除了可以在同一类中被访问外，还可以被同一包中的类和子类访问，同一子类可以访问</p>
<p>private：凡是private声明的成员变量或方法只能在类内访问</p>
<p>2.static关键字表示“全局”、“静态”的概念。被static修饰的成员变量和成员方法独立于该类的任何对象，不依赖类的特定实例，被类的所有实例共享。</p>
<p>static修饰的成员变量和成员方法习惯上被称为静态变量和静态方法，可以直接通过类名来访问</p>
<p>3.final关键字表示“不可变”</p>
<p>final成员变量在对象生成时只初始化一次</p>
<p>4.package的使用：</p>
<p>package是类（接口）的集合</p>
<p>包名一般为小写，而类名的第一个字母一般为大写</p>
<p>使用import关键字导入包</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录6</title>
    <url>/2023/01/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956/</url>
    <content><![CDATA[<h1 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h1><h3 id="一、支持向量机基本型："><a href="#一、支持向量机基本型：" class="headerlink" title="一、支持向量机基本型："></a>一、支持向量机基本型：</h3><p>1.线性分类器：正中间的鲁棒性好，泛化能力强</p>
<p>2.间隔与支持向量</p>
<p>3.寻找最大间隔（凸优化）</p>
<p>4.寻找一个线性可分的超平面</p>
<h3 id="二、对偶问题与解的特性："><a href="#二、对偶问题与解的特性：" class="headerlink" title="二、对偶问题与解的特性："></a>二、对偶问题与解的特性：</h3><p>1.使用拉格朗日乘子法</p>
<p>2.解必须满足KKT条件</p>
<p>3.解的稀疏性：训练完成后，最终模型仅与支持向量有关</p>
<h3 id="三、求解方法："><a href="#三、求解方法：" class="headerlink" title="三、求解方法："></a>三、求解方法：</h3><p>1.求解方法：SMO（求解凸优化问题）</p>
<p>2.通常使用所有支持向量求解的平均值</p>
<h3 id="四、特征空间的映射："><a href="#四、特征空间的映射：" class="headerlink" title="四、特征空间的映射："></a>四、特征空间的映射：</h3><p>1.如果原始空间是有限维（属性数有限），那么一定存在一个高维特征空间使样本线性可分</p>
<h3 id="五、核函数（kernel-function）："><a href="#五、核函数（kernel-function）：" class="headerlink" title="五、核函数（kernel function）："></a>五、核函数（kernel function）：</h3><p>1.绕过显式考虑特征映射，以及计算高维内积的困难</p>
<p>2.Mercer定理：若一个对称函数所对应的核矩阵半正定，则它就能作为核函数使用</p>
<p>3.任何一个核函数，都隐式地定义了一个RKHS（再生核希尔伯特空间）</p>
<p>4.核函数选择成为了决定支持向量机性能的关键</p>
<h3 id="六、如何使用SVM："><a href="#六、如何使用SVM：" class="headerlink" title="六、如何使用SVM："></a>六、如何使用SVM：</h3><p>1.以回归学习为例：</p>
<p>允许模型输出与实际输出之间存在2ε的差别</p>
<p>2.支持向量回归使用的ε-不敏感损失函数</p>
<p>3.支持向量回归（SVR）</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习记录2</title>
    <url>/2023/01/29/java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h3 id="一、什么是继承："><a href="#一、什么是继承：" class="headerlink" title="一、什么是继承："></a>一、什么是继承：</h3><p>1.面向对象类中存在以下常见的关系：</p>
<p>USES-A关系，类A用到了类B</p>
<p>HAS-A关系，类A中有类B的成员引用变量，则类A拥有类B</p>
<p>IS-A关系，继承关系，一个类是另一个类的一种</p>
<p>2.被继承的类一般称为“超类”或“父类”，继承的类被称为“子类”</p>
<p>3.使用extends关键字来描述继承</p>
<p>4.一个类可以同时被任意多个类继承</p>
<h3 id="二、继承与隐藏："><a href="#二、继承与隐藏：" class="headerlink" title="二、继承与隐藏："></a>二、继承与隐藏：</h3><p>1.当成员变量声明为private类型时，任何子类均不能继承该成员</p>
<p>2.当成员变量被修饰为protected类型时，若访问该变量的类位于包外，则只有通过继承才能访问该变量</p>
<h3 id="三、方法的重写："><a href="#三、方法的重写：" class="headerlink" title="三、方法的重写："></a>三、方法的重写：</h3><p>1.在子类自身的方法中，若与继承过来的方法具有相同的签名，便构成了方法的重写</p>
<p>2.如果子类重写了方法，则调用子类重写的方法，否则将调用从父类继承的方法</p>
<p>3.重写是基于继承的，如果不能继承一个方法，则不能构成重写，也就不必遵循重写规则</p>
<p>4.可以使用super调用父类被重写的方法</p>
<h3 id="四、方法的重载："><a href="#四、方法的重载：" class="headerlink" title="四、方法的重载："></a>四、方法的重载：</h3><p>1.方法重载是指在同一个类里面，有两个使用或两个以上具有相同名称、不同参数序列的方法</p>
<h3 id="五、final与继承："><a href="#五、final与继承：" class="headerlink" title="五、final与继承："></a>五、final与继承：</h3><p>1.任何其他类都不能继承用final修饰的类</p>
<p>2.什么时候使用final修饰类：需要确保类中的所有方法都不要被重写改进</p>
<h3 id="六、抽象类："><a href="#六、抽象类：" class="headerlink" title="六、抽象类："></a>六、抽象类：</h3><p>1.把很多类具有相同特征的事物归为一个抽象类</p>
<p>2.使用abstract关键字声明抽象类</p>
<p>3.抽象类不能实例化，即不能创建对象</p>
<p>4.当某类继承自抽象类时，如果其本身不是抽象类，则必须实现所继承抽象类中的抽象方法。</p>
<p>也就是说抽象类的第一个非抽象子类必须实现其父类所有的抽象方法，其中也包括父类继承的抽象方法</p>
<p>5.方法永远不可能同时标识为abstract和final，其之间存在着相反的含义</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习记录1</title>
    <url>/2023/01/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="Numpy基础"><a href="#Numpy基础" class="headerlink" title="Numpy基础"></a>Numpy基础</h1><h4 id="一、生成numpy数组："><a href="#一、生成numpy数组：" class="headerlink" title="一、生成numpy数组："></a>一、生成numpy数组：</h4><p>1.numpy封装了一个新的数据类型ndarray，它是一个多维数组对象</p>
<p>2.可以直接对列表、元组等进行转换来生成ndarray</p>
<p>3.使用random模块生成数组：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">np.random.random   <span class="comment"># 生成0到1之间的随机数</span></span><br><span class="line">np.random.uniform  <span class="comment"># 生成均匀分布的随机数</span></span><br><span class="line">np.random.randn    <span class="comment"># 生成标准正态的随机数</span></span><br><span class="line">np.random.randint  <span class="comment"># 生成随机的整数</span></span><br><span class="line">np.random.normal   <span class="comment"># 生成正态分布</span></span><br><span class="line">np.random.shuffle  <span class="comment"># 随机打乱顺序</span></span><br><span class="line">np.random.seed     <span class="comment"># 设置随机种子</span></span><br><span class="line">random_sample      <span class="comment"># 生成随机的浮点数</span></span><br></pre></td></tr></table></figure></div>

<p>4.创建特定形状的多维数组：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros((<span class="number">3</span>,<span class="number">4</span>))    <span class="comment"># 创建3*4的元素全为0的数组</span></span><br><span class="line">np.ones((<span class="number">3</span>,<span class="number">4</span>))     <span class="comment"># 创建3*4的元素全为1的数组</span></span><br><span class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>))    <span class="comment"># 创建2*3的空数组，数据的值并不为0，而是没有初始化的垃圾值</span></span><br><span class="line">np.zero_like(ndarr)<span class="comment"># 以ndarr相同维度创建元素全为0数组</span></span><br><span class="line">np.ones_like(ndarr)<span class="comment"># 以ndarr相同维度创建元素全为1数组</span></span><br><span class="line">np.empty_like(ndarr)<span class="comment"># 以ndarr相同维度创建空数组</span></span><br><span class="line">np.eye(<span class="number">5</span>)          <span class="comment"># 该函数用来创建一个5*5的矩阵，对角线元素为1，其余元素都为0</span></span><br><span class="line">np.full((<span class="number">3</span>,<span class="number">5</span>),<span class="number">666</span>) <span class="comment"># 创建3*5的元素全为666数组，666为指定值</span></span><br></pre></td></tr></table></figure></div>

<p>5.利用arange、linspace函数生成数组：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">arange([start,],[stop][,step,],dtype=<span class="literal">None</span>)</span><br><span class="line">linspace(start,stop,num=<span class="number">50</span>,endpoint=<span class="literal">True</span>,restep=<span class="literal">False</span>,dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></div>

<h4 id="二、获取元素："><a href="#二、获取元素：" class="headerlink" title="二、获取元素："></a>二、获取元素：</h4><p>1.使用切片的方式获取对应的数据</p>
<h4 id="三、numpy算术运算："><a href="#三、numpy算术运算：" class="headerlink" title="三、numpy算术运算："></a>三、numpy算术运算：</h4><p>1.np.multiply用于数组或函数对应元素相乘</p>
<p>2.numpy.dot用来计算矩阵的点积</p>
<h4 id="四、更改数组的形状："><a href="#四、更改数组的形状：" class="headerlink" title="四、更改数组的形状："></a>四、更改数组的形状：</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">arr.reshape    <span class="comment"># 重新将向量arr维度进行改变，不改变向量本身</span></span><br><span class="line">arr.resize     <span class="comment"># 重新将向量arr维度进行变换，修改向量本身</span></span><br><span class="line">arr.T          <span class="comment"># 对向量arr进行转置</span></span><br><span class="line">arr.ravel      <span class="comment"># 对向量arr进行展平，即将多维数组变为一维数组，不会产生原来数组的副本</span></span><br><span class="line">arr.flatten    <span class="comment"># 对向量arr进行展平，即将多维数组变成一维数组，返回原数组的副本</span></span><br><span class="line">arr.squeeze    <span class="comment"># 只能对维数为1的维度进行降维</span></span><br><span class="line">arr.transpose  <span class="comment"># 对高维矩阵进行轴对换</span></span><br></pre></td></tr></table></figure></div>

<h4 id="五、合并数组："><a href="#五、合并数组：" class="headerlink" title="五、合并数组："></a>五、合并数组：</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">np.append      <span class="comment"># 内存占用较大</span></span><br><span class="line">np.concatenate <span class="comment"># 没有内存问题</span></span><br><span class="line">np.stack       <span class="comment"># 沿着新的轴加入一系列数组</span></span><br><span class="line">np.hstack      <span class="comment"># 堆栈数组垂直顺序（行）</span></span><br><span class="line">np.vstack      <span class="comment"># 堆栈数组垂直顺序（列）</span></span><br><span class="line">np.dstack      <span class="comment"># 堆栈数组按顺序深入（沿第三维）</span></span><br><span class="line">np.vsplit      <span class="comment"># 将数组分解成垂直的多个子数组列表</span></span><br></pre></td></tr></table></figure></div>

<h4 id="六、广播机制："><a href="#六、广播机制：" class="headerlink" title="六、广播机制："></a>六、广播机制：</h4><p>1.numpy的Universal functions中要求输入的数组shape是一致的，当数组的shape不相等 时，则会使用广播机制 </p>
<p>2.广播机制满足的规则：</p>
<p>（1）让所有输入数组都向其中shape最长的数组看齐，不足的部分则通过在前面加1补齐</p>
<p>（2）输出数组的shape是输入数组shape的各个轴上的最大值 </p>
<p>（3）如果输入数组的某个轴和输出数组的对应轴的长度相同或者某个轴的长度为1时， 这个数组能被用来计算，否则出错 </p>
<p>（4）当输入数组的某个轴的长度为1时，沿着此轴运算时都用（或复制）此轴上的第一组值 </p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习记录2</title>
    <url>/2023/01/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="Pytorch基础"><a href="#Pytorch基础" class="headerlink" title="Pytorch基础"></a>Pytorch基础</h1><h3 id="一、什么是pytorch："><a href="#一、什么是pytorch：" class="headerlink" title="一、什么是pytorch："></a>一、什么是pytorch：</h3><p>1.Pytorch是一个建立在Torch库上的python包</p>
<p>2.pytorch主要的四个组成：</p>
<p>(1).torch：类似于numpy的通用数组库，可以将张量类型转换为torch.cuda.TensorFloat，在GPU上进行计算</p>
<p>(2).torch.autograd：用于构建计算图形并自动获取梯度的包</p>
<p>(3).torch.nn：具有共享层和损失函数的神经网络库</p>
<p>(4).torch.optim：具有通用优化算法的优化包</p>
<h3 id="二、创建Tensor"><a href="#二、创建Tensor" class="headerlink" title="二、创建Tensor:"></a>二、创建Tensor:</h3><ol>
<li></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">torch.Tensor(*size)     <span class="comment"># 直接从参数构建一个张量，支持list，numpy数组</span></span><br><span class="line">torch.eye(row,column)   <span class="comment"># 创建指定行数，列数的二维单位Tensor</span></span><br><span class="line">torch.linspace(srart,end,steps)   <span class="comment"># 从start到end，均匀切成steps份</span></span><br><span class="line">torch.logspace(start,end,steps)   <span class="comment"># 从10^start，到10^end，均匀切分成steps份</span></span><br><span class="line">torch.rand/randn(*size) <span class="comment"># 生成[0,1)均匀分布/标准正态分布的数据</span></span><br><span class="line">torch.ones(*size)       <span class="comment"># 返回指定shape的张量，元素初始化为1</span></span><br><span class="line">torch.zeros(*size)      <span class="comment"># 返回指定shape的张量，元素初始化为0</span></span><br><span class="line">torch.ones_like(t)      <span class="comment"># 返回与t的shape相同的张量，元素初始化为1</span></span><br><span class="line">torch.zeros_like(t)     <span class="comment"># 返回与他的shape相同的张量，元素初始化为0</span></span><br><span class="line">torch.arange(start,end,step)      <span class="comment"># 在区间[start,end)上以间隔step生成一个序列张量</span></span><br><span class="line">torch.from_Numpy(ndarray)         <span class="comment"># 从ndarray创建一个Tensor</span></span><br></pre></td></tr></table></figure></div>

<h3 id="三、修改tensor的形状："><a href="#三、修改tensor的形状：" class="headerlink" title="三、修改tensor的形状："></a>三、修改tensor的形状：</h3><ol>
<li></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">size()         <span class="comment"># 返回张量的shape属性值</span></span><br><span class="line">numel(<span class="built_in">input</span>)   <span class="comment"># 计算tensor的元素个数</span></span><br><span class="line">view(*shape)   <span class="comment"># 修改tensor的shape，返回原来的tensor</span></span><br><span class="line">resize         <span class="comment"># 类似于view，但是size超出时会重新分配内存空间</span></span><br><span class="line">item           <span class="comment"># 若tensor为单元素，则返回python的标量</span></span><br><span class="line">unsqueeze      <span class="comment"># 在指定的维度增加一个“1”</span></span><br><span class="line">squeeze        <span class="comment"># 在指定的维度压缩一个“1”</span></span><br></pre></td></tr></table></figure></div>

<h3 id="四、索引操作："><a href="#四、索引操作：" class="headerlink" title="四、索引操作："></a>四、索引操作：</h3><ol>
<li></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">index_select(<span class="built_in">input</span>,dim,index)   <span class="comment"># 在指定维度上选择一些行或列</span></span><br><span class="line">nonzero(<span class="built_in">input</span>)                  <span class="comment"># 获取非0元素的下标</span></span><br><span class="line">masked_select(<span class="built_in">input</span>,mask)       <span class="comment"># 使用二元值进行选择</span></span><br><span class="line">gather(<span class="built_in">input</span>,dim,index)         <span class="comment"># 在指定维度上选择数据，输出形状与index一致</span></span><br><span class="line">scatter_(<span class="built_in">input</span>,dim,index,src)   <span class="comment"># 为gather的反操作，根据指定索引补充数据</span></span><br></pre></td></tr></table></figure></div>

<h3 id="五、广播机制："><a href="#五、广播机制：" class="headerlink" title="五、广播机制："></a>五、广播机制：</h3><p>1.与numpy中的广播机制类似，pytorch也支持广播机制</p>
<h3 id="六、归并操作："><a href="#六、归并操作：" class="headerlink" title="六、归并操作："></a>六、归并操作：</h3><ol>
<li></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">cumprod(t,axis)     <span class="comment"># 在指定维度对t进行累积</span></span><br><span class="line">cumsum              <span class="comment"># 在指定维度对t进行累加</span></span><br><span class="line">dist(a,b,p=<span class="number">2</span>)       <span class="comment"># 返回a,b之间的p阶范数</span></span><br><span class="line">mean/median         <span class="comment"># 均值/中位数</span></span><br><span class="line">std/var             <span class="comment"># 标准差/方差</span></span><br><span class="line">norm(t,p=<span class="number">2</span>)         <span class="comment"># 返回t的p阶范数</span></span><br><span class="line">prod(t)/<span class="built_in">sum</span>(t)      <span class="comment"># 返回t的所有元素的积/和</span></span><br></pre></td></tr></table></figure></div>

<h3 id="七、比较操作："><a href="#七、比较操作：" class="headerlink" title="七、比较操作："></a>七、比较操作：</h3><ol>
<li></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">eq                  <span class="comment"># 比较tensor是否相等，支持broadcast</span></span><br><span class="line">equal               <span class="comment"># 比较tensor是否有相同的shape与值</span></span><br><span class="line">ge/le/gt/lt         <span class="comment"># 大于/小于比较/大于等于/小于等于比较</span></span><br><span class="line"><span class="built_in">max</span>/<span class="built_in">min</span>(t,axis)     <span class="comment"># 返回最值，若指定axis，则额外返回下标</span></span><br><span class="line">top(t,k,axis)       <span class="comment"># 在指定的axis维上取最高的K个值</span></span><br></pre></td></tr></table></figure></div>

<h3 id="八、矩阵操作："><a href="#八、矩阵操作：" class="headerlink" title="八、矩阵操作："></a>八、矩阵操作：</h3><ol>
<li></li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">dot(t1,t2)         <span class="comment"># 计算张量（1D）的内积或点积</span></span><br><span class="line">mm(mat1,mat2)/bmm(batch1,batch2)   <span class="comment"># 计算矩阵乘法/含batch的3D矩阵乘法</span></span><br><span class="line">mv(t1,v1)          <span class="comment"># 计算矩阵与向量乘法</span></span><br><span class="line">t                  <span class="comment"># 计算转置</span></span><br><span class="line">svd(t)             <span class="comment"># 计算t的SVD分解</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录7</title>
    <url>/2023/01/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%957/</url>
    <content><![CDATA[<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><h4 id="一、神经网络模型："><a href="#一、神经网络模型：" class="headerlink" title="一、神经网络模型："></a>一、神经网络模型：</h4><p>1.神经网络是由具有适应性的简单单元组成的广泛并行互连的网络</p>
<p>2.神经网络是一个很大的学科领域，在机器学习中研究的是神经网络学习，亦称为连接主义学习</p>
<p>3.神经网络学到的知识蕴含在连接权重和阈值</p>
<p>4.神经网络需要激活函数，如sigmoid函数</p>
<p>5.前馈网络：神经元之间不存在同层连接也不存在跨层连接</p>
<h4 id="二、万有逼近能力："><a href="#二、万有逼近能力：" class="headerlink" title="二、万有逼近能力："></a>二、万有逼近能力：</h4><p>1.多层前馈神经网络有强大的表示能力</p>
<p>2.仅需一个包含足够多神经元的隐层，多层前馈神经网络就能以任意精度逼近任意复杂度的连续函数</p>
<h4 id="三、BP算法（误差反向传播算法）："><a href="#三、BP算法（误差反向传播算法）：" class="headerlink" title="三、BP算法（误差反向传播算法）："></a>三、BP算法（误差反向传播算法）：</h4><p>1.BP是一个迭代学习算法，在迭代的每一轮中采用广义感知机学习规则</p>
<p>2.BP算法基于梯度下降策略，以目标的负梯度方向对参数进行调整</p>
<p>3.学习率不能太大，也不能太小。取值在0-1之间</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录8</title>
    <url>/2023/02/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%958/</url>
    <content><![CDATA[<h1 id="贝叶斯分类器"><a href="#贝叶斯分类器" class="headerlink" title="贝叶斯分类器"></a>贝叶斯分类器</h1><h3 id="一、贝叶斯决策论："><a href="#一、贝叶斯决策论：" class="headerlink" title="一、贝叶斯决策论："></a>一、贝叶斯决策论：</h3><p>1.概率框架下实施决策的基本理论</p>
<p>2.h*称为贝叶斯最优分类器，其总体风险称为贝叶斯风险</p>
<p>反映了学习性能的理论上限</p>
<h3 id="二、生成式和判别式模型："><a href="#二、生成式和判别式模型：" class="headerlink" title="二、生成式和判别式模型："></a>二、生成式和判别式模型：</h3><p>1.判别式：直接对条件概率分布建模</p>
<p>2.生成式：先对联合概率分布建模，再由此得到条件概率</p>
<h3 id="三、贝叶斯分类器和贝叶斯学习："><a href="#三、贝叶斯分类器和贝叶斯学习：" class="headerlink" title="三、贝叶斯分类器和贝叶斯学习："></a>三、贝叶斯分类器和贝叶斯学习：</h3><p>1.频率主义：统计学习，点估计</p>
<p>2.贝叶斯主义：贝叶斯学习，分布估计</p>
<h3 id="四、极大似然估计："><a href="#四、极大似然估计：" class="headerlink" title="四、极大似然估计："></a>四、极大似然估计：</h3><p>1.先假设某种概率分布形式，再基于训练样例对参数进行估计</p>
<h3 id="五、朴素贝叶斯分类器："><a href="#五、朴素贝叶斯分类器：" class="headerlink" title="五、朴素贝叶斯分类器："></a>五、朴素贝叶斯分类器：</h3><p>1.主要的障碍：所有属性上的联合概率难以从有限的训练样本获得、组合爆炸、样本稀疏</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习记录9</title>
    <url>/2023/02/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%959/</url>
    <content><![CDATA[<h1 id="集成学习和聚类"><a href="#集成学习和聚类" class="headerlink" title="集成学习和聚类"></a>集成学习和聚类</h1><h3 id="一、集成学习："><a href="#一、集成学习：" class="headerlink" title="一、集成学习："></a>一、集成学习：</h3><p>1.使用多个模型来学习</p>
<p>分为同质集成学习和异质集成学习</p>
<h3 id="二、好而不同："><a href="#二、好而不同：" class="headerlink" title="二、好而不同："></a>二、好而不同：</h3><p>1.个体学习器“好而不同”</p>
<p>2.误差-分歧分解</p>
<p><a href="https://imgse.com/i/ppJWMMn"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJWMMn.png"
                      alt="ppJWMMn.png"
                ></a></p>
<h3 id="三、两类常用的集成学习方法："><a href="#三、两类常用的集成学习方法：" class="headerlink" title="三、两类常用的集成学习方法："></a>三、两类常用的集成学习方法：</h3><p>1.序列化方法：boosting</p>
<p>2.并行化方法：bagging</p>
<h3 id="四、Boosting："><a href="#四、Boosting：" class="headerlink" title="四、Boosting："></a>四、Boosting：</h3><p>1.残差最小化，残差逼近</p>
<p>2.序列化模型</p>
<h3 id="五、Bagging："><a href="#五、Bagging：" class="headerlink" title="五、Bagging："></a>五、Bagging：</h3><p>1.使用可重复采样</p>
<p>2.投票做分类，平均做回归</p>
<h3 id="六、多样性度量："><a href="#六、多样性度量：" class="headerlink" title="六、多样性度量："></a>六、多样性度量：</h3><p>1.多样性是集成学习的关键</p>
<p>2.多样性度量：一般通过两分类器的预测结果列联表定义</p>
<p>如不合度量、相关系数、Q-统计量、K-统计量</p>
<h3 id="七、聚类："><a href="#七、聚类：" class="headerlink" title="七、聚类："></a>七、聚类：</h3><p>1.聚类是“无监督学习”中研究最多、应用最广的任务</p>
<p>2.聚类的目标：将数据样本划分为若干个通常不相交的“簇”</p>
<p>既可以作为一个单独任务（用于寻找数据内在的分布结构），也可以作为分类等其他学习任务的前驱过程</p>
<h3 id="八、聚类方法概述："><a href="#八、聚类方法概述：" class="headerlink" title="八、聚类方法概述："></a>八、聚类方法概述：</h3><p>1.聚类的好坏不存在绝对标准</p>
<p>2.在聚类中，总能找到一个新的“标准”，使得以往的算法对它无能为力</p>
<p>3.常用的聚类方法：</p>
<p>（1）原型聚类：亦称为“基于原型的聚类”</p>
<p>​	 假设：聚类结构能通过一组原型刻画</p>
<p>​	 过程：先对原型初始化，然后对原型进行迭代更新求解</p>
<p>​	 代表：K均值聚类，学习向量量化（LVQ），高斯混合聚类</p>
<p>（2）密度聚类：亦称为“基于密度的聚类”</p>
<p>​	 假设：聚类结构能通过样本分布的紧密程度确定</p>
<p>​	 过程：从样本密度的角度来考察样本之间的可连接性，并基于可连接性样本不断扩展聚类簇</p>
<p>​	 代表：DBSCAN，OPTICS，DENCLUE</p>
<p>（3）层次聚类：</p>
<p>​	 假设：能够产生不同粒度的聚类结果</p>
<p>​	 过程：在不同层次对数据集进行划分，从而形成树形的聚类结构</p>
<p>​	 代表：AGNES（自底向上），DIANA（自顶向下）</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录1</title>
    <url>/2023/02/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h1><h4 id="一、计算机系统的组成"><a href="#一、计算机系统的组成" class="headerlink" title="一、计算机系统的组成"></a>一、计算机系统的组成</h4><p><a href="https://imgse.com/i/ppJosot"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJosot.png"
                      alt="ppJosot.png"
                ></a></p>
<h4 id="二、软件"><a href="#二、软件" class="headerlink" title="二、软件"></a>二、软件</h4><p>（1）系统软件：</p>
<p>​	语言处理系统</p>
<p>​	操作系统</p>
<p>​	服务性程序</p>
<p>​	数据库管理系统</p>
<p>​	网络软件</p>
<p>（2）应用软件：</p>
<p>​	按任务需要编制的各种软件</p>
<h4 id="三、层次结构"><a href="#三、层次结构" class="headerlink" title="三、层次结构"></a>三、层次结构</h4><p>   微指令系统—————-微程序的机器M1</p>
<p>   机器语言——————-实际的机器M1</p>
<p>   操作系统——————- 虚拟机器</p>
<p>   汇编语言——————-虚拟的机器M2</p>
<p>   高级语言——————-虚拟的机器M3</p>
<h4 id="四、计算机组成："><a href="#四、计算机组成：" class="headerlink" title="四、计算机组成："></a>四、计算机组成：</h4><p>1.实现计算机体系结构所体现出来的属性（集体指令的实现）</p>
<h4 id="五、计算机的基本组成："><a href="#五、计算机的基本组成：" class="headerlink" title="五、计算机的基本组成："></a>五、计算机的基本组成：</h4><p>1.（冯诺依曼计算机）计算机由五大部件组成</p>
<p><a href="https://imgse.com/i/ppJowsH"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJowsH.png"
                      alt="ppJowsH.png"
                ></a></p>
<p>2.指令和数据以同等的地位存储在存储器中，可以按照地址访问</p>
<p>3.指令和数据由二进制表示</p>
<p>4.指令由操作码和地址码组成 </p>
<p>5.程序存储在存储器中</p>
<p>6.以运算器（ALU）为中心</p>
<p>运算器的功能：算术运算和逻辑运算</p>
<p>控制器（CU）的功能：分析指令，发出控制信号</p>
<h4 id="六、冯诺依曼系统的改进"><a href="#六、冯诺依曼系统的改进" class="headerlink" title="六、冯诺依曼系统的改进"></a>六、冯诺依曼系统的改进</h4><p>1.以存储器为核心</p>
<p>2.将运算器（ALU）和控制器（CU）合起来组成CPU</p>
<p><a href="https://imgse.com/i/ppYSFpj"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYSFpj.png"
                      alt="ppYSFpj.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录2</title>
    <url>/2023/02/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h4 id="一、硬件结构："><a href="#一、硬件结构：" class="headerlink" title="一、硬件结构："></a>一、硬件结构：</h4><p><a href="https://imgse.com/i/ppJf0pQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJf0pQ.png"
                      alt="ppJf0pQ.png"
                ></a></p>
<h4 id="二、系统复杂性管理的方法："><a href="#二、系统复杂性管理的方法：" class="headerlink" title="二、系统复杂性管理的方法："></a>二、系统复杂性管理的方法：</h4><p>1.3Y方法：层次化、模块化、规则化</p>
<h4 id="三、存储器的基本组成："><a href="#三、存储器的基本组成：" class="headerlink" title="三、存储器的基本组成："></a>三、存储器的基本组成：</h4><p>1.指令的结构包括操作码和地址码</p>
<p>2.指令和数据都保存在存储器中</p>
<p>3.<a href="https://imgse.com/i/ppJfRtU"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfRtU.png"
                      alt="ppJfRtU.png"
                ></a></p>
<p>4.存储体—–存储单元——-存储元件</p>
<p>存储单元存放一串二进制代码</p>
<p>存储字：存储单元中二进制代码的组合</p>
<p>存储字长：存储单元中二进制代码的位数</p>
<p>每一个存储单元都有一个地址</p>
<p>5.MAR：存储器地址寄存器，反映了存储单元的个数</p>
<p>  MDR：存储器数据寄存器，反映了存储字长</p>
<h4 id="四、运算器的基本组成和功能："><a href="#四、运算器的基本组成和功能：" class="headerlink" title="四、运算器的基本组成和功能："></a>四、运算器的基本组成和功能：</h4><p>1.ACC、X和MQ（乘商寄存器）都是寄存器</p>
<p><a href="https://imgse.com/i/ppJfdfg"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfdfg.png"
                      alt="ppJfdfg.png"
                ></a></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th>ACC</th>
<th>MQ</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td align="left">加法</td>
<td>被加数    和</td>
<td></td>
<td>加数</td>
</tr>
<tr>
<td align="left">减法</td>
<td>被减数     差</td>
<td></td>
<td>减数</td>
</tr>
<tr>
<td align="left">乘法</td>
<td>乘积高位</td>
<td>乘数    乘积低位</td>
<td>被乘数</td>
</tr>
<tr>
<td align="left">除法</td>
<td>被除数     余数</td>
<td>商</td>
<td>除数</td>
</tr>
</tbody></table>
<h4 id="五、控制器的基本组成和功能："><a href="#五、控制器的基本组成和功能：" class="headerlink" title="五、控制器的基本组成和功能："></a>五、控制器的基本组成和功能：</h4><p>1.控制器的功能：</p>
<p>解释指令、保证指令的按序执行</p>
<p>2.完成一条指令的过程：取指令、分析指令、执行指令</p>
<p>3.取指令用到的寄存器：PC、分析指令用到的寄存器：IR、执行指令用到的寄存器：CU</p>
<p>4.取指令的过程：</p>
<p>PC→MAR→主存→MDR→IR， （PC）+ 1 →PC</p>
<p>5.分析指令的过程：</p>
<p>op(IR)→CU</p>
<p>6.执行指令的过程（以加法为例）：</p>
<p>Ad(IR)→MAR→主存→MDR→ACC</p>
<h4 id="六、硬件结构："><a href="#六、硬件结构：" class="headerlink" title="六、硬件结构："></a>六、硬件结构：</h4><p><a href="https://imgse.com/i/ppJfrXn"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfrXn.png"
                      alt="ppJfrXn.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习记录3</title>
    <url>/2023/02/02/java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="java中类的特性"><a href="#java中类的特性" class="headerlink" title="java中类的特性"></a>java中类的特性</h1><h3 id="一、构造函数："><a href="#一、构造函数：" class="headerlink" title="一、构造函数："></a>一、构造函数：</h3><p>1.构造方法是一种特殊的方法，它是在对象被创建时初始化对象成员的方法</p>
<p>2.构造方法的名称必须与它所在的类名完全相同</p>
<p>3.构造方法没有返回值，但在定义构造方法时，构造方法名前不能用修饰符void来修饰，这是因为一个类的构造方法的返回值类型就是该类本身</p>
<p>4.构造方法定义后，创建对象时就会自动调用它，因此构造方法不需要在程序中直接调用，而是在对象创建时自动调用并执行。这一点不同于一般的方法，一般的方法在用到时才调用</p>
<p>5.从某一构造方法内调用另一构造方法，必须通过this（）语句来调用。</p>
<h3 id="二、构造方法的重载："><a href="#二、构造方法的重载：" class="headerlink" title="二、构造方法的重载："></a>二、构造方法的重载：</h3><p>1.当一个类有多个构造方法时，则这多个构造方法可以重载</p>
<h3 id="三、java语言的垃圾回收："><a href="#三、java语言的垃圾回收：" class="headerlink" title="三、java语言的垃圾回收："></a>三、java语言的垃圾回收：</h3><p>1.在java程序的生命周期中，java运行环境提供了一个系统的垃圾回收线程，负责自动回收那些没有被引用的对象所占用的内存。</p>
<p>2.当一个对象被创建时，JVM会为该对象分配一定的内存、调用该对象的构造方法并开始跟踪该对象。当该对象停止使用时，JVM将通过垃圾回收器回收该对象所占用的内存</p>
<p>3.垃圾回收的优点：</p>
<p>（1）把程序员从复杂的内存追踪、检测、释放的工作中解放出来</p>
<p>（2）防止系统的内存被非法释放，从而使得系统更加稳定</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习记录1</title>
    <url>/2023/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念:"></a>一、基本概念:</h4><p>1.互联网：特指internet，起源于美国，已经发展成为世界上最大的、覆盖全球的计算机网络</p>
<p>2.网络：由若干结点和连接这些结点的链路组成</p>
<p>3.互连网：通过路由器把网络互连起来（网络的网络）</p>
<p>4.习惯上，与网络相连的计算机称为主机</p>
<h4 id="二、互联网发展的阶段："><a href="#二、互联网发展的阶段：" class="headerlink" title="二、互联网发展的阶段："></a>二、互联网发展的阶段：</h4><p>1.第一阶段：从单个网络ARPANET向互联网发展的过程</p>
<p>人们把1983年作为因特网的诞生时间</p>
<p>2.第二阶段：建成了三级结构的互联网</p>
<p>3.第三阶段：逐渐形成了多层次ISP结构的互联网</p>
<p>出现了互联网服务提供者ISP</p>
<h4 id="三、互联网的标准化："><a href="#三、互联网的标准化：" class="headerlink" title="三、互联网的标准化："></a>三、互联网的标准化：</h4><p>1.互联网协会ISOC</p>
<p>2.所有的互联网标准都以RFC（文档）的形式在互联网上发表</p>
<h4 id="四、互联网的组成："><a href="#四、互联网的组成：" class="headerlink" title="四、互联网的组成："></a>四、互联网的组成：</h4><p>1.互联网的边缘部分：由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来通信（传送数据、音频和视频）和资源共享</p>
<p>边缘部分也称为边缘子网</p>
<p>2.处在边缘部分的主机也称为端系统</p>
<p>3.端系统之间的通信方式可划分成两大类：</p>
<p>（1）客户-服务器方式（C&#x2F;S方式）</p>
<p>描述进程之间服务和被服务的关系</p>
<p>客户是服务的请求方，服务器是服务的提供方</p>
<p>（2）对等方式（P2P方式）</p>
<p>对等连接是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方</p>
<p>只要两个主句都运行了对等连接软件（P2P软件），它们就可以进行对等的、对等连接通信</p>
<p>4.互联网的核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务（提供连通性和变换）</p>
<p>核心部分也称为通信子网</p>
<p>5.路由器是实现分组交换的关键构件，器任务是转发收到的分组，这是网络核心部分的重要功能</p>
<h4 id="五、电路交换："><a href="#五、电路交换：" class="headerlink" title="五、电路交换："></a>五、电路交换：</h4><p>1.电路交换的特点：</p>
<p>电路交换必定是面向连接的</p>
<p>2.电路交换的三个阶段：</p>
<p>建立连接、通信、释放连接	</p>
<p>3.电路交换的缺点：</p>
<p>（1）计算机数据具有突发性</p>
<p>（2）传送计算机数据时，通信线路的利用率低</p>
<h4 id="六、分组交换："><a href="#六、分组交换：" class="headerlink" title="六、分组交换："></a>六、分组交换：</h4><p>1.分组交换采用存储转发技术</p>
<p>2.在发送端，先把较长的报文划分成较短的、固定长度的数据段</p>
<p>3.在每一个数据段前面添加上首部构成分组</p>
<p><a href="https://imgse.com/i/ppYpqsI"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYpqsI.png"
                      alt="ppYpqsI.png"
                ></a></p>
<p>4.分组交换网以“分组”作为数据传输单元，依次把各个分组发送到接收端</p>
<p>5.每一个分组的首部都含有地址和控制信息</p>
<p>6.每一个分组在互联网独立地选择传输路径</p>
<p>7.路由器处理分组的过程：</p>
<p>（1）把收到的分组先放入缓存（暂时存储）</p>
<p>（2）查找转发表，找到某个目的地址应该从哪个端口转发</p>
<p>（3）把分组送到适当的端口转发出去</p>
<p>8.分组交换的优点：</p>
<p>高效、灵活、迅速、可靠</p>
<p>9.分组交换的缺点：</p>
<p>会有一定的时延、分组必须携带的首部会造成一定的开销</p>
<p>10、存储转发在报文交换中也会出现</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习记录4</title>
    <url>/2023/02/03/java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h1 id="接口与枚举"><a href="#接口与枚举" class="headerlink" title="接口与枚举"></a>接口与枚举</h1><h4 id="一、接口"><a href="#一、接口" class="headerlink" title="一、接口"></a>一、接口</h4><p>1.接口的结构与抽象类非常类似。其本身也有数据成员、抽象方法、默认方法和静态方法</p>
<p>2.接口的数据成员都是静态的且必须初始化，即数据成员必须是静态常量	</p>
<p>3.接口中除了声明抽象方法外，还可以定义静态方法和默认方法</p>
<p>4.接口中的静态方法是用public static修饰的；而默认方法是用public default修饰的。接口中的抽象方法不能有方法的实现，即不能有方法体</p>
<p>5.接口与抽象类一样不能使用new运算符直接创建对象。</p>
<p>6.接口的事项类似于继承，在声明类的同时使用implements关键字来实现一个接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">class 类名 implements 接口名</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>7.接口可以实现多重继承</p>
<p>8.如果子接口中定义了与父接口同名的常量或者相同名称的方法，则父接口中的常量被隐藏，方法被覆盖。</p>
<h4 id="二、枚举"><a href="#二、枚举" class="headerlink" title="二、枚举"></a>二、枚举</h4><p>1.枚举是一种特殊的类，所以枚举也称为枚举类，它是一种引用类型</p>
<p>其语法格式如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符]<span class="keyword">enum</span> 枚举类型名</span><br><span class="line">&#123;</span><br><span class="line">	枚举成员</span><br><span class="line">        方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>2.枚举的所有枚举成员必须在枚举体的第一行显式列出，否则该枚举不能产生枚举成员</p>
<p>3.枚举可以实现一个或多个接口，使用enum关键字声明的枚举默认继承了java.lang.Enum类</p>
<p>4.使用enum定义非抽象的枚举类时默认使用final修饰，因此枚举类不能派生子类</p>
<p>5.创建枚举类型的对象时不能使用new运算符，而是直接将枚举成员赋值给枚举对象</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql学习记录1</title>
    <url>/2023/02/04/Mysql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h4 id="一、mysql的基本概念："><a href="#一、mysql的基本概念：" class="headerlink" title="一、mysql的基本概念："></a>一、mysql的基本概念：</h4><p>1.MySQL是一个小型关系数据库管理系统。</p>
<p>2.mysql的主要优势：</p>
<p>速度快、可移植性强、接口丰富</p>
<p>3.mysql8.0的新特性：</p>
<p>（1）数据字典</p>
<p>（2）原子数据定义</p>
<p>（3）安全和账户管理</p>
<p>（4）资源管理</p>
<p>（5）InnoDB的增强</p>
<p>（6）字符集的支持</p>
<p>（7）增强json功能</p>
<p>（8）数据类型支持</p>
<p>（9）查询优化</p>
<p>（10）共用表表达式</p>
<p>（11）窗口函数</p>
<p>（12）统计直方图</p>
<p>（13）备份锁</p>
<h4 id="二、数据库基本操作："><a href="#二、数据库基本操作：" class="headerlink" title="二、数据库基本操作："></a>二、数据库基本操作：</h4><p>1.创建数据库：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;   # 查看当前所有存在的数据库</span><br><span class="line">create database database_name; # 创建一个数据库</span><br></pre></td></tr></table></figure></div>

<p>2.删除数据库：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database database_name;   # 删除数据库 </span><br></pre></td></tr></table></figure></div>

<p>3.从MySQL 8.0开始，系统表全部换成事务型的InnoDB表，默认的MySQL实例将不包含任何MyISAM表，除非手动创建MyISAM表</p>
<h4 id="三、数据表的基本操作："><a href="#三、数据表的基本操作：" class="headerlink" title="三、数据表的基本操作："></a>三、数据表的基本操作：</h4><p>1.创建数据表：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建员工数据表</span><br><span class="line">CREATE TABLE tb_emp1</span><br><span class="line">(</span><br><span class="line">    id   INT(11),</span><br><span class="line">    NAME VARCHAR(25),</span><br><span class="line">    deptid INT(11),</span><br><span class="line">    salary FLOAT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>2.主键约束：</p>
<p>主键，又称主码，是表中一列或多列的组合。主键约束（Primary Key Constraint）要求主键列的数据唯一，并且不允许为空</p>
<p>3.主键分为单字段主键和多字段联合主键</p>
<p>4.外键约束：</p>
<p>外键用来在两个表的数据之间建立连接，可以是一列或者多列。一个表可以有一个或多个外键</p>
<p>外键：首先它是表中的一个字段，虽可以不是本表的主键，但要对应另外一个表的主键。</p>
<p>5.非空约束：</p>
<p>非空约束（Not Null Constraint）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统会报错唯一性约束</p>
<p>6.唯一性约束</p>
<p>唯一性约束（Unique Constraint）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值</p>
<p>7.查看数据表的结构：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">describe 表名;   # 查看表的基本结构</span><br><span class="line">show create table 表名; # 查看表的详细结构</span><br></pre></td></tr></table></figure></div>

<p>8.修改数据表：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table &lt;旧表名&gt; rename &lt;新表名&gt;; </span><br><span class="line"># 修改表名，修改表名并不修改表的结构，因此修改名称后的表和修改名称前的表的结构必然是相同的</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_emp6 MODIFY NAME VARBINARY(30);  # 修改表的字段类型</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_emp1 ADD managerId INT(10) PRIMARY KEY;  #在表的最后添加字段</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_emp1 ADD column3 INT(11) AFTER NAME;  #在表的指定列添加一个字段</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_emp1 DROP column3;  # 删除字段</span><br><span class="line"></span><br><span class="line">ALTER TABLE tb_emp1 MODIFY NAME VARCHAR(25) FIRST;  # 修改name字段为表的第一个字段</span><br><span class="line">DROP TABLE IF EXISTS tb_emp7; # 删除数据表tb_emp7</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql学习记录2</title>
    <url>/2023/02/05/Mysql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h3 id="一、数学函数："><a href="#一、数学函数：" class="headerlink" title="一、数学函数："></a>一、数学函数：</h3><p>1.绝对值函数ABS（）</p>
<p>2.返回圆周率的函数PI（）</p>
<p>3.平方根函数SQRT（）</p>
<p>4.求余数函数MOD（x，y）</p>
<p>5.获取整数的函数CEIL（x），CEILING（x）和FLOOR（x）</p>
<p>6.获取随机数的函数RAND（）和RAND（x）</p>
<p>7.四舍五入ROUND（x）</p>
<p>8.符号函数SIGN（x）</p>
<p>9.幂运算POW（x,y）</p>
<p>10.对数运算LOG（x），返回自然对数</p>
<p>11.角度与弧度转换：</p>
<p>RADIANS（x）将角度转换为弧度</p>
<p>DEGREES（x）将弧度转换为角度</p>
<p>12.正弦函数SIN（x）</p>
<p>13.反正弦函数ASIN（x）</p>
<p>14.余弦函数COS（x）</p>
<p>15.反余弦函数ACOS（x）</p>
<p>16.正切函数TAN（x）</p>
<p>17.反正切函数ATAN（x）</p>
<p>18.余切函数COT（x）</p>
<p>注：使用函数时要加select</p>
<h3 id="二、字符串函数："><a href="#二、字符串函数：" class="headerlink" title="二、字符串函数："></a>二、字符串函数：</h3><p>1.CHAR_LENGTH(str)返回值为字符串str所包含的字符个数。一个多字节字符算作一个单字符</p>
<p>2.LENGTH(str)返回值为字符串的字节长度，使用utf8编码字符集时，一个汉字是3字节，一个数字或字母算1字节</p>
<p>3.CONCAT(s1,s2……)返回结果为连接参数产生的字符串，或许有一个或多个参数</p>
<p>4.CONCAT_WS函数连接带分隔符的字符串</p>
<p>5.INSERT(s1,x,len,s2)返回字符串s1，其子字符串起始于x位置和被字符串s2取代的len字符</p>
<p>6.LOWER (str)或者LCASE (str)可以将字符串str中的字母字符全部转换成小写字母</p>
<p>7.LEFT(s,n)返回字符串s开始的最左边n个字符</p>
<p>8.RIGHT(s,n)返回字符串str最右边的n个字符</p>
<p>9.LPAD(s1,len,s2)返回字符串s1，其左边由字符串s2填补到len字符长度。假如s1的长度大于len，则返回值被缩短至len字符</p>
<p>10.PAD(s1,len,s2)返回字符串sl，其右边被字符串s2填补至len字符长度。假如字符串s1的长度大于len，则返回值被缩短到len字符长度</p>
<p>11.LTRIM(s)返回字符串s，字符串左侧空格字符被删除</p>
<p>12.RTRIM(s)返回字符串s，字符串右侧空格字符被删除。</p>
<p>13.TRIM(s)删除字符串s两侧的空格</p>
<p>14.TRIM(s1 FROM s)删除字符串s中两端所有的子字符串s1。s1为可选项，在未指定情况下，删除空格1</p>
<p>15.REPEAT(s,n)返回一个由重复的字符串s组成的字符串，字符串s的数目等于n。若n&lt;&#x3D;0，则返回一个空字符串。若s或n为NULL，则返回NULL</p>
<p>16.SPACE(n)返回一个由n个空格组成的字符串</p>
<p>17.REPLACE(s,s1,s2)使用字符串s2替代字符串s中所有的字符串s1</p>
<p>18.STRCMP(s1,s2)：若所有的字符串均相同，则返回0；若根据当前分类次序，第一个参数小于第二个，则返回-1；其他情况返回1</p>
<p>19.SUBSTRING(s,n,len)带有len参数的格式，从字符串s返回一个长度与len字符相同的子字符串，起始于位置n</p>
<p>20.MID()函数获取指定位置处的子字符串</p>
<p>21.LOCATE(str1,str)、POSITION(str1 IN str)和INSTR(str, str1)3个函数的作用相同，返回子字符串str1在字符串str中的开始位置</p>
<p>22.REVERSE(s)将字符串s反转，返回的字符串的顺序和s字符串顺序相反</p>
<p>23.ELT(N，字符串1，字符串2，字符串3，…，字符串N)：若N &#x3D; 1，则返回值为字符串1；若N&#x3D;2，则返回值为字符串2；以此类推；若N小于1或大于参数的数目，则返回值为NULL</p>
<p>24.FIELD(s,s1,s2,…,sn)返回字符串s在列表s1,s2,…,sn中第一次出现的位置，在找不到s的情况下，返回值为0。如果s为NULL，则返回值为0，原因是NULL不能同任何值进行同等比较</p>
<p>25.FIND_IN_SET(s1,s2)返回字符串s1在字符串列表s2中出现的位置，字符串列表是一个由多个逗号‘,’分开的字符串组成的列表</p>
<p>26.MAKE_SET(x,s1,s2,…,sn)函数按x的二进制数从s1，s2,…,sn中选取字符串</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习记录5</title>
    <url>/2023/02/06/java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h3 id="一、什么是JDBC："><a href="#一、什么是JDBC：" class="headerlink" title="一、什么是JDBC："></a>一、什么是JDBC：</h3><p>1.jdbc表示java数据库连接，是用java语言与数据库连接的API</p>
<p>2.jdbc是一个规范，提供了一整套接口。通过JDBC API，用Java语言编写的应用程序能够执行SQL语句、获取结果、显示数据等，并且可以将所做的修改传回数据库</p>
<p>3.通过jdbc与数据库建立连接，发送sql语句，处理sql语句执行的结果</p>
<p>4.访问MySQL数据库需要使用MySQL JDBC驱动程序</p>
<p>5.JDBC API主要位于Java的java.sql包与javax.sql包中</p>
<h3 id="二、建立jdbc连接："><a href="#二、建立jdbc连接：" class="headerlink" title="二、建立jdbc连接："></a>二、建立jdbc连接：</h3><p>1.建立jdbc连接的步骤：</p>
<p>（1）导入jdbc包</p>
<p>（2）注册jdbc驱动程序</p>
<p>（3）数据库url配置</p>
<p>（4）创建连接对象</p>
<p>2.使用java开发数据库应用需要用到的四个接口：</p>
<p>Driver、Connection、Statement和ResultSet</p>
<p>3.使用jdbc访问数据库的一般步骤：</p>
<p>加载驱动程序、建立数据库连接、创建执行方式语句、执行sql语句、处理返回结果和关闭创建的各种对象</p>
<p>4.jdbc中的三种sql查询方式：不含参数的静态查询、含有参数的动态查询和存储过程调用。分别对应Statement、PreparedStatement和CallableStatement接口</p>
<p>5.通过Statement接口实现静态sql查询、通过PreparedStatement接口实现动态SQL查询、通过CallableStatement接口实现存储过程的调用</p>
<p>6.通过DatebaseMentData接口获得关于数据库的信息，通过ResultSetMetaData接口获取结果集的结构</p>
<p>7.通过ResultSet返回查询结果集，并使用记录指针对其记录进行定位</p>
<p>8.可以使用setAutoCommit（）方法控制事物提交的方式，使用rollback（）方法实现事物回滚</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录3</title>
    <url>/2023/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h3 id="一、计算机硬件的主要技术指标："><a href="#一、计算机硬件的主要技术指标：" class="headerlink" title="一、计算机硬件的主要技术指标："></a>一、计算机硬件的主要技术指标：</h3><p>1.机器字长：CPU一次能够处理数据的位数，与CPU中的寄存器位数有关</p>
<p>2.运算速度：</p>
<p><a href="https://imgse.com/i/ppJfD6s"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfD6s.png"
                      alt="ppJfD6s.png"
                ></a></p>
<p>3.存储容量：存放二进制信息的总位数</p>
<p><a href="https://imgse.com/i/ppJf5c9"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJf5c9.png"
                      alt="ppJf5c9.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录4</title>
    <url>/2023/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h3 id="一、计算机的产生和发展："><a href="#一、计算机的产生和发展：" class="headerlink" title="一、计算机的产生和发展："></a>一、计算机的产生和发展：</h3><p>1.1946年，美国ENIAC</p>
<p><a href="https://imgse.com/i/ppJocJf"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJocJf.png"
                      alt="ppJocJf.png"
                ></a></p>
<p>2.现代计算机产生的驱动：需求、技术发展</p>
<p>3.微型计算机的出现和发展：</p>
<p>inter公司为代表</p>
<p>4.摩尔定律:集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍 </p>
<p>5.软件技术的兴起和发展:</p>
<p>机器语言——-面向机器</p>
<p>汇编语言——-面向机器</p>
<p>高级语言——-面向问题</p>
<p>6.软件发展的特点：</p>
<p>（1）开发周期长</p>
<p>（2）制作成本昂贵</p>
<p>（3）检测软甲产品质量的特殊性</p>
<h3 id="二、计算机的应用和展望"><a href="#二、计算机的应用和展望" class="headerlink" title="二、计算机的应用和展望"></a>二、计算机的应用和展望</h3><p>1.科学计算和数据处理</p>
<p>2.工业控制和实时控制</p>
<p>3.网络技术：</p>
<p>（1）电子商务</p>
<p>（2）网络教育</p>
<p>（3）敏捷制造</p>
<p>4.虚拟现实</p>
<p>5.办公自动化和管理信息系统</p>
<p>6.CAD、CAM、CIMS</p>
<p>7.多媒体技术</p>
<p>8.人工智能</p>
<p>9.未来计算机的发展：</p>
<p>（1）光计算机</p>
<p>（2）DNA生物计算机</p>
<p>（3）量子计算机</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录5</title>
    <url>/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</url>
    <content><![CDATA[<h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><h3 id="一、总线的基本概念"><a href="#一、总线的基本概念" class="headerlink" title="一、总线的基本概念"></a>一、总线的基本概念</h3><p>1.总线是连接各个部件的信息传输线，是各个部件共享的传输介质</p>
<p>2.总线上信息的传送：</p>
<p>串行、并行</p>
<p>3.单总线</p>
<p><a href="https://imgse.com/i/ppJoGIx"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJoGIx.png"
                      alt="ppJoGIx.png"
                ></a></p>
<p>4.面向CPU的双总线结构</p>
<p><a href="https://imgse.com/i/ppJordI"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJordI.png"
                      alt="ppJordI.png"
                ></a></p>
<p>5.以存储器为中心的双总线结构</p>
<p><a href="https://imgse.com/i/ppYSZn0"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYSZn0.png"
                      alt="ppYSZn0.png"
                ></a></p>
<h3 id="二、总线的分类"><a href="#二、总线的分类" class="headerlink" title="二、总线的分类"></a>二、总线的分类</h3><p>1.片内总线</p>
<p>2.系统总线：计算机各部件之间的信息传输线</p>
<p><a href="https://imgse.com/i/ppYSEXq"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYSEXq.png"
                      alt="ppYSEXq.png"
                ></a></p>
<p>3.通信总线：用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信等）之间的通信</p>
<p>传输方式：串行通信总线、并行通信总线</p>
<h3 id="三、总线的特性和性能指标"><a href="#三、总线的特性和性能指标" class="headerlink" title="三、总线的特性和性能指标"></a>三、总线的特性和性能指标</h3><p>1.机械特性：尺寸、形状、管脚数及排列顺序</p>
<p>2.电气特性：传输方向和有效的电平范围</p>
<p>3.功能特性：</p>
<p>每根传输线的功能：地址、数据、控制</p>
<p>4.时间特性：信号的时序关系</p>
<p>5.性能指标：</p>
<p>（1）总线宽度</p>
<p>（2）标准传输率：每秒传输的最大字节数（MBps）</p>
<p>（3）时钟同步&#x2F;异步</p>
<p>（4）总线复用</p>
<p>（5）信号线数</p>
<p>（6）总线控制方式</p>
<p>（7）其他的指标：负载能力</p>
<p>6.总线的标准：ISA、EISA、VESA、PCI、AGP、RS-232、USB</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录6</title>
    <url>/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956/</url>
    <content><![CDATA[<h1 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h1><h3 id="一、多总线结构"><a href="#一、多总线结构" class="headerlink" title="一、多总线结构"></a>一、多总线结构</h3><p>1.双总线结构</p>
<p>通道：具有特殊功能的处理器，由通道对I&#x2F;O统一管理</p>
<p>2.三总线结构：</p>
<p><a href="https://imgse.com/i/ppJoNRO"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJoNRO.png"
                      alt="ppJoNRO.png"
                ></a></p>
<p>3.三总线结构的另一种形式：</p>
<p><a href="https://imgse.com/i/ppJo0Ld"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJo0Ld.png"
                      alt="ppJo0Ld.png"
                ></a></p>
<p>4.四总线结构：</p>
<p><a href="https://imgse.com/i/ppYSm7T"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYSm7T.png"
                      alt="ppYSm7T.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习记录3</title>
    <url>/2023/02/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="自然语言处理学习记录"><a href="#自然语言处理学习记录" class="headerlink" title="自然语言处理学习记录"></a>自然语言处理学习记录</h1><h3 id="一、自然语言处理（NLP）概述"><a href="#一、自然语言处理（NLP）概述" class="headerlink" title="一、自然语言处理（NLP）概述"></a>一、自然语言处理（NLP）概述</h3><p>1.自然语言处理是计算机科学和人工智能的一个研究领域，它关注自然语言的处理。这种处理通常包括将自然语言转换成计算机能够用于理解这个世界的数据（数字）。同时，这种对世界的理解有时被用于生成能够体现这种理解的自然语言文本（自然语言生成）</p>
<p>2.正则表达式使用了一类特殊的称为正则语法的形式语言语法</p>
<p>3.有限状态机：FSM</p>
<p>4.自然语言处理的应用：</p>
<p>自动文摘、情感分析、信心提取、关系提取、聊天机器人、社交媒体分析、个人语音助理、语法检查5.语料库：语料库是存储在计算机上，用于研究语言是如何使用的书面或口头的自然语言材料集合。更准确地说，语料库是用于语言分析和语料分析的系统化和计算机化的真实语言集合。</p>
<p>6.语料分析可以被定义为一种以真实上下文和交际语境为基础的，深入研究语言概念的方法</p>
<p>7.为nlp应用准备数据集的基本步骤：</p>
<p>（1）挑选数据</p>
<p>（2）预处理数据</p>
<p>（3）转换数据</p>
<p>8.自然语言处理中最常见的文本预处理技术：</p>
<p>（1）大小写转换</p>
<p>（2）去噪</p>
<p>（3）文本规范化：常用的方法是字典映射</p>
<p>（4）词干提取：在语料库上执行词干提取以将词语减少到词干或词根形式</p>
<p>（5）词形还原：在语料库上执行词干提取以将词语减少到词干或词根形式</p>
<p>（6）标记化：在语料库上执行词干提取以将词语减少到词干或词根形式</p>
<p>（7）删除停止词</p>
<p>9.词嵌入：是文本实值向量形式的数值表示。具有相似含义的词映射到相似的向量，因此具有相似的表示</p>
<p>10.自然语言处理的关键作用是将预处理的文本数据转换为数值数据，数值数据是文本数据的数字表示</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习记录4</title>
    <url>/2023/02/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<h1 id="自然语言处理学习记录"><a href="#自然语言处理学习记录" class="headerlink" title="自然语言处理学习记录"></a>自然语言处理学习记录</h1><h3 id="一、nlp的组成："><a href="#一、nlp的组成：" class="headerlink" title="一、nlp的组成："></a>一、nlp的组成：</h3><p>1.自然语言理解（NLU）：nlp的第一个任务</p>
<p>2.nlu需要利用下列的分析把自然语言转换成合理的表示：</p>
<p>形态分析、词法分析、句法分析、语义分析、消歧、篇章整合、语用分析</p>
<p>3.自然语言生成（NLG）：nlp的第二个任务</p>
<p>使用计算机来生成自然语言的过程</p>
<h3 id="二、上下文无关文法："><a href="#二、上下文无关文法：" class="headerlink" title="二、上下文无关文法："></a>二、上下文无关文法：</h3><p>1.在nlu中，上下文无关文法的定义主要包括四个主要的组成部分：</p>
<p>（1）一个非终结符集合N</p>
<p>（2）一个终结符集合T</p>
<p>（3）一个开始符S，S也是一个非终结符</p>
<p>（4）一个产生规则集合P，用来生成句子</p>
<h3 id="三、形态分析："><a href="#三、形态分析：" class="headerlink" title="三、形态分析："></a>三、形态分析：</h3><p>1.形态学是语言学的一个分支，主要研究词语是怎样被构造和生成的</p>
<p>2.词素：语言学中，词素是给定语言的最小意义单元，词素是形态学的基本单元</p>
<p>3.词干：词干是词的一部分，可以允许一个词缀附在上面</p>
<p>4.形态分析被定义为语法层面上的分析任务，它分析词是怎么由词素构成的，以及哪些是语义构成的最小单元</p>
<p>5.形态分析被用来分词、词性标注</p>
<p>6.自由词素：自由词素可以独立存在并充当一个词。它也被称为无边界词素或独立词素</p>
<p>7、边界词素：边界词素通常带有词缀，它们被进一步分为两类—-屈折词素</p>
<h3 id="四、词法分析："><a href="#四、词法分析：" class="headerlink" title="四、词法分析："></a>四、词法分析：</h3><p>1词法分析：把一段文本分割成词、短语和其他意义单元的过程</p>
<p>2.词条：词条被定义为词法分析过程中得到的有意义元素</p>
<p>3.词性：指一类词或是词法项具有相似的语法属性。具有相同词性的词在句子的语法结构中具有相似的行为</p>
<p>4.词条化：指一类词或是词法项具有相似的语法属性。具有相同词性的词在句子的语法结构中具有相似的行为</p>
<h3 id="五、句法分析："><a href="#五、句法分析：" class="headerlink" title="五、句法分析："></a>五、句法分析：</h3><p>1.句法分析是指给定句子或句子片段来做逻辑意义分析的过程。也要考虑语法规则来定义句子的逻辑意义和句子的正确程度	</p>
<h3 id="六、语义分析："><a href="#六、语义分析：" class="headerlink" title="六、语义分析："></a>六、语义分析：</h3><p>1.语义分析：生成自然语言语义的表示</p>
<p>2.词汇语义：包括词、字词、子单元、复合词、短语</p>
<p>3.上下位关系：描述一个泛化的项和其具体的实例之间的关系，这个泛化的项被称为上位词。泛化项的具体实例被称为下位词</p>
<p>4.同形异义词：指具有相同结构、拼写或形式，但具有不同语义且彼此相互无关的一些词</p>
<p>5.多义性：指一个词或是短语具有不同但相关的意义</p>
<h3 id="七、消歧："><a href="#七、消歧：" class="headerlink" title="七、消歧："></a>七、消歧：</h3><p>1.歧义的类型有：词法歧义、句法歧义、语义歧义、语用歧义</p>
<h3 id="八、篇章整合："><a href="#八、篇章整合：" class="headerlink" title="八、篇章整合："></a>八、篇章整合：</h3><p>1.篇章整合：小部分的自然语言结构所处的大环境</p>
<h3 id="九、语用分析："><a href="#九、语用分析：" class="headerlink" title="九、语用分析："></a>九、语用分析：</h3><p>1.语用分析处理外部的词汇知识</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习记录6</title>
    <url>/2023/02/13/java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956/</url>
    <content><![CDATA[<h1 id="java中的异常机制"><a href="#java中的异常机制" class="headerlink" title="java中的异常机制"></a>java中的异常机制</h1><h3 id="一、异常的定义："><a href="#一、异常的定义：" class="headerlink" title="一、异常的定义："></a>一、异常的定义：</h3><p>1.操作的过程中可能有很多出错的情况，出错的原因可能是多方面的。非正常的情况在java中统一被认为是异常，java使用异常机制来统一处理</p>
<p>2.异常是相对于return的一种退出机制，可以由系统触发，也可以由程序通过throw语句触发，异常可以通过try&#x2F;catch语句进行捕获并处理，如果没有捕获，则会导致程序退出并输出异常栈信息</p>
<h3 id="二、异常类的体系："><a href="#二、异常类的体系：" class="headerlink" title="二、异常类的体系："></a>二、异常类的体系：</h3><p>1.以Throwable为根，Java定义了非常多的异常类，表示各种类型的异常</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://mystorage9.oss-cn-hangzhou.aliyuncs.com/img/%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84%E4%BD%93%E7%B3%BB.png"
                     
                ></p>
<p>2.除了Java API中定义的异常类，也可以自己定义异常类，一般是继承Exception或者它的某个子类</p>
<h3 id="三、异常的处理："><a href="#三、异常的处理：" class="headerlink" title="三、异常的处理："></a>三、异常的处理：</h3><p>1.java中对异常的处理有：catch、throw、finally、try-with-resources和throws</p>
<p>2.catch可以有很多个，每一个对应一种异常类型。异常处理机制将根据抛出的异常类型找第一个匹配的catch块，找到后，执行catch块内的代码，不再执行其他catch块，如果没有找到，会继续到上层方法中查找</p>
<p>3.在catch块内处理完后，可以重新抛出异常，异常可以是原来的，也可以是新建的</p>
<p>4.异常机制中还有一个重要的部分，就是finally。catch后面可以跟finally语句。finally内的代码不管有无异常发生，都会执行</p>
<p>5.异常机制中，还有一个和throw很像的关键字throws，用于声明一个方法可能抛出的异常。throws跟在方法的括号后面，可以声明多个异常，以逗号分隔。这个声明的含义是，这个方法内可能抛出这些异常，且没有对这些异常进行处理，至少没有处理完，调用者必须进行处理</p>
<p>6.无论是受检异常还是未受检异常，无论是否出现在throws声明中，都应该在合适的地方以适当的方式进行处理</p>
<p>7.真正出现异常的时候，应该抛出异常，而不是返回特殊值</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录7</title>
    <url>/2023/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%957/</url>
    <content><![CDATA[<h1 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h1><h3 id="一、总线的判优控制："><a href="#一、总线的判优控制：" class="headerlink" title="一、总线的判优控制："></a>一、总线的判优控制：</h3><p>1.主设备：对总线有控制权</p>
<p>2.从设备：响应从主设备发来的总线命令</p>
<p>3.<a href="https://imgse.com/i/ppJf600"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJf600.png"
                      alt="ppJf600.png"
                ></a></p>
<p>4.链式查询：</p>
<p><a href="https://imgse.com/i/ppJotJK"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJotJK.png"
                      alt="ppJotJK.png"
                ></a></p>
<p>5.计数器定时查询：</p>
<p><a href="https://imgse.com/i/ppJo6FP"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJo6FP.png"
                      alt="ppJo6FP.png"
                ></a></p>
<p>6.独立请求：</p>
<p><a href="https://imgse.com/i/ppJo3ZR"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJo3ZR.png"
                      alt="ppJo3ZR.png"
                ></a></p>
<h3 id="二、总线通信控制："><a href="#二、总线通信控制：" class="headerlink" title="二、总线通信控制："></a>二、总线通信控制：</h3><p>1.目的：解决通信双方协调配合的问题</p>
<p>2.总线传输周期：</p>
<p><a href="https://imgse.com/i/ppJf2kT"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJf2kT.png"
                      alt="ppJf2kT.png"
                ></a></p>
<p>3.总线通信的四种方式：</p>
<p>（1）同步通信：由统一时标控制数据穿送</p>
<p>（2）异步通信：采用应答方式，没有公共时钟标准</p>
<p>（3）半同步通信：同步、异步结合</p>
<p>（4）分离式通信：充分挖掘系统总线每个瞬间的潜力</p>
<p>4.同步：发送方用时钟前沿发信号、接收方用系统时钟后沿判断、识别</p>
<p>5.异步：允许不同速度的模块和谐工作，增加一条等待响应信号（wait信号）</p>
<p>6.一个总线传输周期（以输入数据为例）：</p>
<p>（1）主模块发地址、命令  （占用总线）</p>
<p>（2）从模块准备数据    （不占用总线，总线空闲）</p>
<p>（3）从模块向主模块发送数据    （占用总线）</p>
<p>7.分离式通信：</p>
<p><a href="https://imgse.com/i/ppJo8d1"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJo8d1.png"
                      alt="ppJo8d1.png"
                ></a></p>
<p>8.分离通信的特点：</p>
<p>（1）各模块有权申请占用总线</p>
<p>（2）采用同步方式通信，不等对方回答</p>
<p>（3）各模块准备数据时，不占用总线</p>
<p>（4）总线被占用时，无空闲</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录8</title>
    <url>/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%958/</url>
    <content><![CDATA[<h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><h3 id="一、存储器的概述"><a href="#一、存储器的概述" class="headerlink" title="一、存储器的概述"></a>一、存储器的概述</h3><p>1.存储器的分类：</p>
<p>（1）按存储介质分类：</p>
<p>半导体存储器、TTL、MOS</p>
<p>磁表面存储器、磁头、磁载体</p>
<p>磁芯存储器、硬磁材料、环状元件</p>
<p>光盘存储器、激光、磁光材料</p>
<p>后面三种的数据不易失</p>
<p>（2）按存取方式分类：</p>
<p>随机存储器    在程序执行的过程中可读可写</p>
<p>只读存储器    在程序执行的过程中只读</p>
<p>上面两种的存取时间与物理地址无关（随机访问）</p>
<p>顺序存取存储器   磁带</p>
<p>直接存取存储器   磁盘</p>
<p>上面两种的存取时间与区里地址有关（串行访问）</p>
<p>（3）按在计算机中的作用分类：</p>
<p><a href="https://imgse.com/i/ppJfWhF"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfWhF.png"
                      alt="ppJfWhF.png"
                ></a></p>
<h3 id="二、存储器的层次结构"><a href="#二、存储器的层次结构" class="headerlink" title="二、存储器的层次结构"></a>二、存储器的层次结构</h3><p>1.<a href="https://imgse.com/i/ppJfhp4"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfhp4.png"
                      alt="ppJfhp4.png"
                ></a></p>
<p>2.缓存-主存层次和主存-辅存层次：</p>
<p><a href="https://imgse.com/i/ppJoDeA"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJoDeA.png"
                      alt="ppJoDeA.png"
                ></a></p>
<p>3.缓存-主存（速度）：主存储器、实地址、物理地址</p>
<p>4.主存-辅存（容量）：虚拟存储器、虚地址、逻辑地址</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录9</title>
    <url>/2023/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%959/</url>
    <content><![CDATA[<h1 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h1><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>1.主存储器的基本组成：</p>
<p><a href="https://imgse.com/i/ppJfBlj"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfBlj.png"
                      alt="ppJfBlj.png"
                ></a></p>
<p>2.主存和CPU的联系：</p>
<p><a href="https://imgse.com/i/ppJfymq"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfymq.png"
                      alt="ppJfymq.png"
                ></a></p>
<p>3.主存储器中存储单元地址的分配：</p>
<p>12345678H在存储器中的存储</p>
<p>（1）高位字节地址为字地址 、大端大尾方式</p>
<p><a href="https://imgse.com/i/ppJf41J"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJf41J.png"
                      alt="ppJf41J.png"
                ></a></p>
<p>（2）低位字节地址为字地址、小端、小尾方式</p>
<p><a href="https://imgse.com/i/ppYSeBV"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYSeBV.png"
                      alt="ppYSeBV.png"
                ></a></p>
<p>（3）一个字四个字节</p>
<p>假设地址线有24根，按字节寻址 2的24次方&#x3D;16MB</p>
<p>若字长为16位，按字寻址，得到8MW</p>
<p>若字长为32位，按字寻址，得到4MW</p>
<p>4.主存的技术指标：</p>
<p>（1）存储容量：主存存放二进制代码的总位数</p>
<p>（2）存储速度：</p>
<p>存取时间：存储器的访问时间、读出时间、访问时间</p>
<p>存取周期：连续两次独立的存储器操作（读或写）所需要的最小间隔时间</p>
<p>（3）存储器的带宽  位&#x2F;秒</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习记录5</title>
    <url>/2023/02/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/</url>
    <content><![CDATA[<h1 id="Tensorflow2学习记录1"><a href="#Tensorflow2学习记录1" class="headerlink" title="Tensorflow2学习记录1"></a>Tensorflow2学习记录1</h1><h3 id="一、Tensorflow的建模流程"><a href="#一、Tensorflow的建模流程" class="headerlink" title="一、Tensorflow的建模流程"></a>一、Tensorflow的建模流程</h3><p>1.准备数据</p>
<p>数据的类型一般有结构化数据、图片数据、文本数据、时间序列数据</p>
<p>2.定义模型</p>
<p>3.训练模型</p>
<p>4.评估模型</p>
<p>5.使用模型</p>
<p>6.保存模型 </p>
<p>将模型打包导出为统一的格式，方便迁移和部署</p>
<p>后续的模型部署也是我们应该关心的，比如在服务器上进行部署、在移动端和嵌入式设备上进行部署、在网页端部署等等</p>
<h3 id="二、Tensorflow的核心概念"><a href="#二、Tensorflow的核心概念" class="headerlink" title="二、Tensorflow的核心概念"></a>二、Tensorflow的核心概念</h3><p>1.tensorflow是一个采用数据流图，用于数值计算的开源软件库</p>
<p>2.tensorflow底层的核心概念是张量，计算图和自动微分</p>
<p>3.张量</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tf.constant()    <span class="comment"># 定义一个常量</span></span><br><span class="line">tf.tensor()      <span class="comment"># 定义一个张量</span></span><br><span class="line">tf.Variable()    <span class="comment"># 定义一个变量</span></span><br></pre></td></tr></table></figure></div>

<p>4.在tensorflow2中使用动态计算图和自动微分</p>
<p>5.可以说，tensorflow2是新的架构、新的开始</p>
<h3 id="三、Tensorflow2的层次结构"><a href="#三、Tensorflow2的层次结构" class="headerlink" title="三、Tensorflow2的层次结构"></a>三、Tensorflow2的层次结构</h3><p>1.这里将tensorflow2分为5个层次结构：硬件层、内核层、低阶API、中阶API、高阶API</p>
<p>2.在之后的学习中将会重点学习低阶API、中阶API、高阶API</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习记录1</title>
    <url>/2023/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="一、监听模式"><a href="#一、监听模式" class="headerlink" title="一、监听模式"></a>一、监听模式</h3><p>1.监听模式是一种一对多的关系，可以有任意个（一个或多个）观察者对象同时监听某一个对象</p>
<p>2.监听模式中可以分为观察者和被观察者</p>
<p>3.监听模式的核心思想就是在被观察者与观察者之间建立一种自动触发的关系</p>
<p>4.设计方案：Observable是被观察者的抽象类，Observer是观察者的抽象类</p>
<p>5.监听模式根据侧重的功能可以分为推模型和拉模型：</p>
<p>（1）推模型：被观察者对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据</p>
<p>（2）拉模型：被观察者在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到被观察者对象中获取，相当于观察者从被观察者对象中拉数据</p>
<h3 id="二、状态模式"><a href="#二、状态模式" class="headerlink" title="二、状态模式"></a>二、状态模式</h3><p>1.状态模式是说一个对象在其内部状态发生改变时，其外表的行为和外在属性不一样，看上去就像改变了它的类型一样</p>
<p>2.状态模式的优缺点：</p>
<p>（1）优点：封装了状态的转换规则，在状态模式中可以将状态的转换代码封装到环境类中；</p>
<p>允许状态转换逻辑与状态对象合为一体</p>
<p>（2）缺点：会增加系统类和对象的个数；结构较为复杂，使用不当会导致程序的混乱</p>
<p>最近在看人人都懂设计模式这本书，就对学习的内容做一个记录吧</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习记录6</title>
    <url>/2023/02/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956/</url>
    <content><![CDATA[<h1 id="自然语言处理学习记录"><a href="#自然语言处理学习记录" class="headerlink" title="自然语言处理学习记录"></a>自然语言处理学习记录</h1><h3 id="一、预处理"><a href="#一、预处理" class="headerlink" title="一、预处理"></a>一、预处理</h3><p>1.处理原始的语料数据：</p>
<p>可以从三种资源获取原始的文本数据：原始文本文件、用脚本定义局部变量定义原始的语料文本、从nltk获取语料库</p>
<p>2.词形还原是识别正确的词性和句子中出现的单词的含义的过程</p>
<p>3.处理原始语料库的句子：</p>
<p>词条化是将一段文字切成单词、句子和有意义的短语的过程。它的输出是单词，也叫作词条</p>
<h3 id="二、特征工程与NLP算法"><a href="#二、特征工程与NLP算法" class="headerlink" title="二、特征工程与NLP算法"></a>二、特征工程与NLP算法</h3><p>1.特征是机器学习算法的输入参数，算法基于这些输入生成输出</p>
<p>2.在nlp中，特征工程是从原始数据或语料中生成用于开发nlp应用或解决nlp相关问题的特征的过程</p>
<p>3.特征工程的重点是特征的选择</p>
<p>4.通过进行句法，可以得到几乎所有重要的nlp特征</p>
<p>5.句法分析器的结果通常表示为一个句法分析树或抽象语法树，它们通过文法规则生成。句法分析器工具按照文法规则执行句法分析过程并生成句法树</p>
<p>6.词性标注：</p>
<p>词性标注被定义为对语料库中的单词标注其在参与部分中的词性的过程</p>
<p>词性标注也被称为语法标注或词类消歧。单词的词性也依赖于它和所处短语、句子和段落中相邻的单词的关系</p>
<p>7.命名实体识别（NER）：</p>
<p>命名实体识别，又称作专名识别、命名实体，是指识别文本中具有特定意义的实体，主要包括人名、地名、机构名、专有名词等，以及时间、数量、货币、比例数值等文字 </p>
<p>8.TF-IDF：指词频-逆文档频率，它属于数值统计的范畴。使用TF-IDF，我们能够学习一个词对于数据集中的一个文档的重要性</p>
<p>9.向量化：是nlp领域提取的一个重要的方法，主要是将文本转换为向量形式。主要表现为是将每个词映射为一个整数</p>
<p>10.编码：使用one-hot编码</p>
<p>11.word2vec算法接收向量化的one-hot编码单词作为输入</p>
<p>12.规范化：文本规范化是将给定文本转换成单一规范形式的过程</p>
<p>13.概率模型：重要的一个概率模型是语言模型（LM）</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录10</title>
    <url>/2023/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9510/</url>
    <content><![CDATA[<h1 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h1><h3 id="一、半导体存储芯片的基本结构："><a href="#一、半导体存储芯片的基本结构：" class="headerlink" title="一、半导体存储芯片的基本结构："></a>一、半导体存储芯片的基本结构：</h3><p>1.<a href="https://imgse.com/i/ppJfc7V"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJfc7V.png"
                      alt="ppJfc7V.png"
                ></a></p>
<p>2.半导体片选线</p>
<p><a href="https://imgse.com/i/ppJoYi6"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJoYi6.png"
                      alt="ppJoYi6.png"
                ></a></p>
<p>3.片选线的作用：使某一个或某些芯片同时工作</p>
<h3 id="二、半导体存储芯片的译码驱动方式："><a href="#二、半导体存储芯片的译码驱动方式：" class="headerlink" title="二、半导体存储芯片的译码驱动方式："></a>二、半导体存储芯片的译码驱动方式：</h3><p>1.线选法：对容量大的数据不适用</p>
<p>2.重合法：行、列地址分别进行译码，只能有一组是有效的</p>
<h3 id="三、随机存取存储器："><a href="#三、随机存取存储器：" class="headerlink" title="三、随机存取存储器："></a>三、随机存取存储器：</h3><p>1.静态RAM：</p>
<p>基本电路由触发器、开关等元件组成</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习记录2</title>
    <url>/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>1.物理层—–数据链路层——–网络层——–传输层——-应用层</p>
<p>2.分层的优点：</p>
<p>（1）各层之间相互独立</p>
<p>（2）灵活性好</p>
<p>（3）结构上可以分开</p>
<p>（4）易于维护和实现</p>
<p>（5）能够促进标准化工作</p>
<p>3.协议：为网络中的数据交换建立的规则、标准或约定称之为协议</p>
<p>4.协议的组成：语法、语义、同步</p>
<p>5.常见的计算机网络协议：</p>
<p><a href="https://imgse.com/i/ppYpLLt"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYpLLt.png"
                      alt="ppYpLLt.png"
                ></a></p>
<p>6.协议是水平的、服务是垂直的</p>
<p>7.实体：任何可以发送或接收信息的硬件或软件进程</p>
<p>8.ICMP（互联网控制消息协议 ）：网络设备用来诊断网络通信问题的网络层协议 </p>
<p>9.数据通信：计算机网络最基本的功能，包括连接控制、传输控制、差错控制、流量控制、路由选择、多路复用等子功能</p>
<p>10.<a href="https://imgse.com/i/ppYpbQA"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYpbQA.png"
                      alt="ppYpbQA.png"
                ></a></p>
<p>11.<a href="https://imgse.com/i/ppYpXeP"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYpXeP.png"
                      alt="ppYpXeP.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录11</title>
    <url>/2023/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9511/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h3 id="查漏补缺1"><a href="#查漏补缺1" class="headerlink" title="查漏补缺1"></a>查漏补缺1</h3><p>1.冯诺依曼机器最根本的特征是采用“存储程序”的原理。基本工作方式是控制流驱动方式</p>
<p>2.冯诺依曼机工作方式的基本特点：按地址访问并顺序执行指令</p>
<p>3.软件和硬件具有逻辑上的等效性，硬件实现具有更高的执行速度，软件实现具有更好的灵活性，软件的功能可以由硬件实现</p>
<p>4.IR存放当前欲指行的指令，PC存放下一条指令的地址（跟踪下一条要执行的指令在主存储器的地址）</p>
<p>MAR用来存放欲访问的存储单元的地址，MDR存放从存储单元取来的数据</p>
<p>5.运算器的核心部件是ALU（算术逻辑运算单元），地址寄存器位于CPU，并没有集成到运算器和控制器中。内存和CPU之间存在操作速度上的差别</p>
<p>6.计算机只能从主存中取指令和操作数，不能直接与外存交换数据</p>
<p>7.编译程序是先完整编译后运行的程序，解释程序是一句一句翻译且边翻译边执行的程序</p>
<p>解释程序的速度比编译程序慢</p>
<p>8.由高级语言转换为汇编语言的过程称为编译，把汇编语言源代码翻译成机器语言程序的过程称为汇编</p>
<p>9.CPU有控制器和运算器两个部件组成，运算器和控制器中都含有寄存器。</p>
<p>存储器是一个独立部件</p>
<p>10.数据库系统是指在计算机系统引入数据库后的系统，一般由数据库、数据库管理系统、应用程序、数据库管理员构成，其中数据库管理系统是系统程序</p>
<p>11.相联存储器既可以按地址寻址又可以按内容（通常是某些字段）寻址，为与传统的存储器相区别，又称按内容寻址的寄存器</p>
<p>12.翻译程序把高级语言源程序转换为机器语言程序</p>
<p>13.汇编语言也是一种翻译程序</p>
<p>14.除了立即寻址以外，数据均存放在存储器中</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录12</title>
    <url>/2023/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9512/</url>
    <content><![CDATA[<h3 id="半导体存储芯片的译码驱动方式"><a href="#半导体存储芯片的译码驱动方式" class="headerlink" title="半导体存储芯片的译码驱动方式"></a>半导体存储芯片的译码驱动方式</h3><h3 id="一、线选法"><a href="#一、线选法" class="headerlink" title="一、线选法"></a>一、线选法</h3><p><a href="https://imgse.com/i/ppYSAcn"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppYSAcn.png"
                      alt="ppYSAcn.png"
                ></a></p>
<h3 id="二、重合法"><a href="#二、重合法" class="headerlink" title="二、重合法"></a>二、重合法</h3><p>1.行译码</p>
<p>2.列译码</p>
<h3 id="随机存取存储器（RAM）"><a href="#随机存取存储器（RAM）" class="headerlink" title="随机存取存储器（RAM）"></a>随机存取存储器（RAM）</h3><p>一、静态RAM（SARM）</p>
<p><a href="https://imgse.com/i/ppJodQe"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJodQe.png"
                      alt="ppJodQe.png"
                ></a></p>
<p>T1~4是触发器；T5、T6是行开关；T7、T8是列开关；T7、T8一列共用；A是触发器的原端</p>
<p>二、动态RAM（DRAM）</p>
<p>读数据线、写数据线</p>
<p>1.读出与原信息相反，写入与输入信息相同</p>
<p>2.三管动态RAM芯片</p>
<p>3.单管动态RAM（4116）</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录13</title>
    <url>/2023/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9513/</url>
    <content><![CDATA[<h3 id="一、动态RAM的刷新"><a href="#一、动态RAM的刷新" class="headerlink" title="一、动态RAM的刷新"></a>一、动态RAM的刷新</h3><p>1.刷新与行地址有关</p>
<p>2.刷新的方法：</p>
<p>（1）集中式刷新（存取周期为0.5微秒）</p>
<p>（2）分散式刷新（存取周期为1微秒）</p>
<p>（3）异步刷新：分散式刷新和集中式刷新相结合、</p>
<p>将刷新安排在指令译码阶段</p>
<h3 id="二、动态RAM和静态RAM的比较"><a href="#二、动态RAM和静态RAM的比较" class="headerlink" title="二、动态RAM和静态RAM的比较"></a>二、动态RAM和静态RAM的比较</h3><p><a href="https://imgse.com/i/ppJoUzD"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/18/ppJoUzD.png"
                      alt="ppJoUzD.png"
                ></a></p>
<h3 id="三、只读存储器（ROM）"><a href="#三、只读存储器（ROM）" class="headerlink" title="三、只读存储器（ROM）"></a>三、只读存储器（ROM）</h3><p>1.掩模ROM（MROM）</p>
<p>行列选择线交叉处有MOS管为“1“</p>
<p>行列选择线交叉处无MOS管为“0”</p>
<p>2.PROM（一次性编程）</p>
<p>熔丝断开为0</p>
<p>熔丝连接为1</p>
<p>3.EPROM（多次编程）</p>
<p>N型沟道浮动栅MOS电路</p>
<p>4.EEPROM（多次编程）</p>
<p>电可擦写</p>
<p>局部擦写</p>
<p>全部擦写</p>
<p>5.FLash Memory（闪速型存储器）</p>
<h3 id="四、存储器与CPU的连接"><a href="#四、存储器与CPU的连接" class="headerlink" title="四、存储器与CPU的连接"></a>四、存储器与CPU的连接</h3><p>1.存储器容量的扩展</p>
<p>（1）位扩展（增加存储字长）</p>
<p>（2）字扩展（增加存储字的数量）</p>
<p>（3）字、位扩展</p>
<p>2.连接方式：</p>
<p>（1）地址线的连接</p>
<p>（2）数据线的连接</p>
<p>（3）读&#x2F;写命令线的连接</p>
<p>（4）片选线的连接</p>
<p>（5）合理选择存储芯片</p>
<p>（6）其他、时序、负载</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习记录3</title>
    <url>/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><p>1.计算机网络已经由一种通信基础设施发展成为一种重要的信息服务基础设施</p>
<h1 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h1><h3 id="一、网络、互联网和因特网"><a href="#一、网络、互联网和因特网" class="headerlink" title="一、网络、互联网和因特网"></a>一、网络、互联网和因特网</h3><p>1.网络由若干结点和连接这些结点的链路组成。</p>
<p>2.多个网络通过互联网互连起来，即互联网</p>
<p>3.因特网是世界上最大的互连网络</p>
<h3 id="二、因特网发展的三个阶段"><a href="#二、因特网发展的三个阶段" class="headerlink" title="二、因特网发展的三个阶段"></a>二、因特网发展的三个阶段</h3><p>1.<a href="https://imgse.com/i/ppdh7ZQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/22/ppdh7ZQ.png"
                      alt="ppdh7ZQ.png"
                ></a></p>
<p>2.因特网服务提供者ISP</p>
<p>3.第一层ISP：因特网主干网</p>
<p>3.因特网制定标准的特点：面向公众</p>
<p>4.指定标准的四个阶段：</p>
<p>（1）因特网草案（还不是RFC文档）</p>
<p>（2）建议标准（这个阶段称为RFC文档）</p>
<p>（3）草案标准</p>
<p>（4）因特网标准</p>
<p>并非所有的RFC文档都是因特网标准</p>
<h3 id="三、因特网的组成："><a href="#三、因特网的组成：" class="headerlink" title="三、因特网的组成："></a>三、因特网的组成：</h3><p>边缘部分：由所有连接在因特网的主机组成，用户直接使用，用来进行通信</p>
<p>核心部分：由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录14</title>
    <url>/2023/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9514/</url>
    <content><![CDATA[<h3 id="一、存储器与CPU的连接"><a href="#一、存储器与CPU的连接" class="headerlink" title="一、存储器与CPU的连接"></a>一、存储器与CPU的连接</h3><p>（1）写出对应的二进制地址码</p>
<p>（2）确定芯片数量及类型</p>
<p>（3）分配地址线</p>
<p>（4）确定片选信号</p>
<p>（5）确定片选逻辑</p>
<h3 id="二、存储器的校验"><a href="#二、存储器的校验" class="headerlink" title="二、存储器的校验"></a>二、存储器的校验</h3><p>1.三倍冗余的代码可以检1位错，纠1位错</p>
<p>四倍冗余的代码可以检2位错，纠1位错</p>
<p>五倍冗余的代码可以检2位错，纠2位错</p>
<p>（集合中有两个合法代码）</p>
<p>2.编码的检测能力和纠错能力与任意两组合法代码之间二进制的最小差异数有关</p>
<p>3.编码的最小距离：任意两组合法代码之间二进制位数的最小差异</p>
<p>4.编码的检错能力、纠错能力与编码的最小距离有关</p>
<p><a href="https://imgse.com/i/ppaPQit"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/21/ppaPQit.png"
                      alt="ppaPQit.png"
                ></a></p>
<p>5.汉明码的组成：</p>
<p>汉明码采用奇偶校验，分组校验</p>
<p>6.汉明码是一种非划分的方式</p>
<p>7.<a href="https://imgse.com/i/ppaiMm4"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/21/ppaiMm4.png"
                      alt="ppaiMm4.png"
                ></a></p>
<p>8.汉明码检测位的取值：</p>
<p>检测位的取值与该位所在的检测“小组”承担的奇偶校验任务有关</p>
<p>9.各检测位Ci所承担的检测小组为</p>
<p><a href="https://imgse.com/i/ppaiQ0J"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/21/ppaiQ0J.png"
                      alt="ppaiQ0J.png"
                ></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录15</title>
    <url>/2023/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9515/</url>
    <content><![CDATA[<h1 id="调高主存的访问速度"><a href="#调高主存的访问速度" class="headerlink" title="调高主存的访问速度"></a>调高主存的访问速度</h1><p>1.采用高速的器件</p>
<p>2.采用层次结构：Cache-主存</p>
<p>3.调整主存结构</p>
<h3 id="一、单体多字系统"><a href="#一、单体多字系统" class="headerlink" title="一、单体多字系统"></a>一、单体多字系统</h3><p>1.<a href="https://imgse.com/i/ppBdBex"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/24/ppBdBex.png"
                      alt="ppBdBex.png"
                ></a></p>
<h3 id="二、多体并行系统"><a href="#二、多体并行系统" class="headerlink" title="二、多体并行系统"></a>二、多体并行系统</h3><p>1.高位交叉 顺序编址</p>
<p>2.多体并行系统是采用多体模块组成的存储器，各模块有独立的地址寄存器（MAR），数据寄存器（MDR）、地址译码、驱动电路和读&#x2F;写电路，它们可以并行工作，又能交叉工作</p>
<p>3.高位交叉编址的多体存储器：</p>
<p><a href="https://imgse.com/i/ppBdcfe"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/24/ppBdcfe.png"
                      alt="ppBdcfe.png"
                ></a></p>
<p>4.低位交叉，各个体轮流编址</p>
<p>低位交叉在不改变存取周期的前提下，增加存储器的带宽</p>
<p>5.<a href="https://imgse.com/i/ppBw9tU"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/03/24/ppBw9tU.png"
                      alt="ppBw9tU.png"
                ></a></p>
<p>6.高位交叉用于存储器容量的扩展，低位交叉用于存储器带宽和访问速度的提高</p>
<p>7.高性能存储芯片：</p>
<p>（1）SDRAM（同步DRAM）：在系统时钟控制下进行读出和写入，CPU无需等待</p>
<p>（2）RDRAM：主要解决存储器的带宽问题</p>
<p>（3）带cache的DRAM：在DRAM中集成了一个由SRAM组成的Cache，有利于猝发式读取</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录16</title>
    <url>/2023/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9516/</url>
    <content><![CDATA[<h1 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h1><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>1.使用cache的原因：</p>
<p><a href="https://imgse.com/i/pphcb5t"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/03/pphcb5t.png"
                      alt="pphcb5t.png"
                ></a></p>
<p>2.cache的工作原理：</p>
<p><a href="https://imgse.com/i/pphcLPP"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/03/pphcLPP.png"
                      alt="pphcLPP.png"
                ></a></p>
<p>主存和缓存按块存储，块的大小相同、</p>
<p>3.主存数量远远大于缓存</p>
<p>命中：主存块调入缓存，主存块和缓存块建立了对应关系</p>
<p>未命中：主存块未调入缓存，主存块和缓存块未建立对应关系</p>
<p>用标记记录与某缓存块建立了对应关系的主存块号</p>
<p>4.cache的命中率：</p>
<p>CPU欲访问的信息在cache中的比率</p>
<p>5.命中率和cache的容量与块长有关</p>
<p>6.一般的cache块的大小取4~8个字</p>
<p>7.块长取一个存取周期从主存调出的信息长度</p>
<p>8.块的大小和多体交叉有关</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录17</title>
    <url>/2023/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9517/</url>
    <content><![CDATA[<h1 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h1><h3 id="一、主存系统的效率："><a href="#一、主存系统的效率：" class="headerlink" title="一、主存系统的效率："></a>一、主存系统的效率：</h3><p>1.效率e与命中率有关</p>
<p><a href="https://imgse.com/i/ppjEqYQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/12/ppjEqYQ.png"
                      alt="ppjEqYQ.png"
                ></a></p>
<p><a href="https://imgse.com/i/ppjELWj"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/12/ppjELWj.png"
                      alt="ppjELWj.png"
                ></a></p>
<p>2.访问cache和访问内存是同时进行的</p>
<h3 id="二、cache的基本结构："><a href="#二、cache的基本结构：" class="headerlink" title="二、cache的基本结构："></a>二、cache的基本结构：</h3><p>1.<a href="https://imgse.com/i/ppjEXSs"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/12/ppjEXSs.png"
                      alt="ppjEXSs.png"
                ></a></p>
<h3 id="三、cache的读写操作："><a href="#三、cache的读写操作：" class="headerlink" title="三、cache的读写操作："></a>三、cache的读写操作：</h3><p>1.读操作：当CPU发出主存的地址后，首先判断该存储字是否在cache中，若命中，直接访问cache，将该字送至CPU中，若未命中，一方面要访问主存，将该字传送给CPU，与此同时，要将该字所在的主存块装入cache中，如果此时cache已经装满，就要执行替换算法，腾出空位	才将新的主存块调入</p>
<p>2.写操作：</p>
<p>写直达法</p>
<p>写回法</p>
<h3 id="四、cache的改进："><a href="#四、cache的改进：" class="headerlink" title="四、cache的改进："></a>四、cache的改进：</h3><p>1.增加cache的级数：</p>
<p>片载cache</p>
<p>片外cache</p>
<p>2.统一缓存和分立缓存</p>
<p>统一缓存是指指令和数据都存放在同一缓存内的cache中，分立缓存是指指令和数据分别存放在两个缓存中，一个称为指令cache，一个称为数据cache</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录18</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9518/</url>
    <content><![CDATA[<h1 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h1><h3 id="一、cache-主存的地址映射："><a href="#一、cache-主存的地址映射：" class="headerlink" title="一、cache-主存的地址映射："></a>一、cache-主存的地址映射：</h3><p>1.直接映射：</p>
<p><a href="https://imgse.com/i/ppxafe0"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppxafe0.png"
                      alt="ppxafe0.png"
                ></a></p>
<p>每个缓存块i可以和若干个主存块对应</p>
<p>每个主存块j只能和一个缓存块对应</p>
<p>2.全相联映射：</p>
<p><a href="https://imgse.com/i/ppxa2yn"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppxa2yn.png"
                      alt="ppxa2yn.png"
                ></a></p>
<p>3.组相联映射：</p>
<p><a href="https://imgse.com/i/ppxaRLq"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppxaRLq.png"
                      alt="ppxaRLq.png"
                ></a></p>
<p>某一主存块j按模Q映射到缓存的第i组中的任一块</p>
<h3 id="二、替换算法："><a href="#二、替换算法：" class="headerlink" title="二、替换算法："></a>二、替换算法：</h3><p>1.先进先出（FIFO算法）</p>
<p>2.近期最少使用（LRU）算法</p>
<h3 id="三、总结："><a href="#三、总结：" class="headerlink" title="三、总结："></a>三、总结：</h3><p>1.直接：某一主存块只能固定映射到某一缓存块（不灵活）</p>
<p>2.全相联：某一主存块能映射到任一缓存块（成本高）</p>
<p>3.组相联：某一主存块只能映射到某一缓存组中的任一缓存块（直接映射和全相联映射的折中）</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习记录19</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9519/</url>
    <content><![CDATA[<h1 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h1><h3 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h3><p>1.特点：不直接与cpu交换信息</p>
<p>2.磁表面存储器的技术指标：</p>
<p>（1）记录密度、  道密度 、位密度</p>
<p>（2）存储容量</p>
<p>（3）平均寻址时间  寻道时间 + 等待时间</p>
<p>辅存的速度：</p>
<p>寻址时间</p>
<p>磁头读写时间</p>
<p>（4）数据传输率</p>
<p>（5）误码率</p>
<h3 id="二、磁记录的原理和方式："><a href="#二、磁记录的原理和方式：" class="headerlink" title="二、磁记录的原理和方式："></a>二、磁记录的原理和方式：</h3><p>1.写</p>
<p><a href="https://imgse.com/i/ppx0cSe"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppx0cSe.png"
                      alt="ppx0cSe.png"
                ></a></p>
<p>2.读</p>
<p><a href="https://imgse.com/i/ppx0ROA"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppx0ROA.png"
                      alt="ppx0ROA.png"
                ></a></p>
<h3 id="三、硬磁盘存储器："><a href="#三、硬磁盘存储器：" class="headerlink" title="三、硬磁盘存储器："></a>三、硬磁盘存储器：</h3><p>1.硬磁盘存储器的类型：</p>
<p>（1）固定磁头和移动磁头</p>
<p>（2）可换盘和固定盘</p>
<p>2.硬磁盘存储器的结构：</p>
<p><a href="https://imgse.com/i/ppx0gQH"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppx0gQH.png"
                      alt="ppx0gQH.png"
                ></a></p>
<p>3.磁盘控制器：</p>
<p>（1）接受主机发来的命令，转换成磁盘驱动器的控制命令</p>
<p>（2）实现主机和驱动器之间的数据格式转换</p>
<p>（3）控制磁盘驱动器读写</p>
<p>（4）磁盘控制器是主机和磁盘驱动器之间的接口，对主机来说，通过总线连接，对硬盘直接进行控制</p>
<p>4.盘片：一般采用硬质铝合金材料制作</p>
<h3 id="四、软磁盘存储器："><a href="#四、软磁盘存储器：" class="headerlink" title="四、软磁盘存储器："></a>四、软磁盘存储器：</h3><p>1.软磁盘存储器和硬磁盘存储器的对比：</p>
<p><a href="https://imgse.com/i/ppx0feI"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppx0feI.png"
                      alt="ppx0feI.png"
                ></a></p>
<h3 id="五、光盘存储器："><a href="#五、光盘存储器：" class="headerlink" title="五、光盘存储器："></a>五、光盘存储器：</h3><p>1.采用光存储技术、利用激光写入和读出</p>
<p>2.<a href="https://imgse.com/i/ppx02yd"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/04/13/ppx02yd.png"
                      alt="ppx02yd.png"
                ></a></p>
<p>3.光盘的存储原理：</p>
<p>（1）只读型和只写一次型：热作用</p>
<p>（2）可擦写光盘：热磁效应</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
</search>
